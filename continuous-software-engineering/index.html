<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SGSE 18 | Continuous Software Engineering</title>
    <meta name="description" content="Kursmaterial f√ºr das Fach &quot;Spezielle Gebiete zum Software Engineering&quot;">
    <link rel="icon" href="/book/logo.png">
    
    <link rel="preload" href="/book/assets/css/32.styles.bfc63ef0.css" as="style"><link rel="preload" href="/book/assets/js/app.1ad18c78.js" as="script"><link rel="preload" href="/book/assets/js/16.6f3b5537.js" as="script"><link rel="prefetch" href="/book/assets/js/0.a5abddcb.js"><link rel="prefetch" href="/book/assets/js/1.b87bf68b.js"><link rel="prefetch" href="/book/assets/js/2.92a65972.js"><link rel="prefetch" href="/book/assets/js/3.9a5bd47a.js"><link rel="prefetch" href="/book/assets/js/4.b94d7581.js"><link rel="prefetch" href="/book/assets/js/5.384e7c34.js"><link rel="prefetch" href="/book/assets/js/6.c891b197.js"><link rel="prefetch" href="/book/assets/js/7.3bd92e69.js"><link rel="prefetch" href="/book/assets/js/8.dda31553.js"><link rel="prefetch" href="/book/assets/js/9.9d92bf37.js"><link rel="prefetch" href="/book/assets/js/10.defdaed2.js"><link rel="prefetch" href="/book/assets/js/11.36d9ae2b.js"><link rel="prefetch" href="/book/assets/js/12.79ae054e.js"><link rel="prefetch" href="/book/assets/js/13.c9cf75c0.js"><link rel="prefetch" href="/book/assets/js/14.75e882af.js"><link rel="prefetch" href="/book/assets/js/15.5e579c8b.js"><link rel="prefetch" href="/book/assets/js/17.29f57daf.js"><link rel="prefetch" href="/book/assets/js/18.121a2d1d.js"><link rel="prefetch" href="/book/assets/js/19.3dec5ca5.js"><link rel="prefetch" href="/book/assets/js/20.e18394db.js"><link rel="prefetch" href="/book/assets/js/21.d858ad9e.js"><link rel="prefetch" href="/book/assets/js/22.4566376b.js"><link rel="prefetch" href="/book/assets/js/23.76a0c4c7.js"><link rel="prefetch" href="/book/assets/js/24.c956bde8.js"><link rel="prefetch" href="/book/assets/js/25.34056b0d.js"><link rel="prefetch" href="/book/assets/js/26.0f0ebb92.js"><link rel="prefetch" href="/book/assets/js/27.9bfd9643.js"><link rel="prefetch" href="/book/assets/js/28.49854a59.js"><link rel="prefetch" href="/book/assets/js/29.92200fe0.js"><link rel="prefetch" href="/book/assets/js/30.22eb0019.js"><link rel="prefetch" href="/book/assets/js/31.95f4b5f3.js">
    <link rel="stylesheet" href="/book/assets/css/32.styles.bfc63ef0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/book/" class="home-link router-link-active"><!----><span class="site-name">
      SGSE 18
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/book/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Grundlagen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Distributed Ledger</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Continuous Software Engineering</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/book/continuous-software-engineering/" class="active sidebar-link">Continuous Software Engineering</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#definition" class="sidebar-link">Definition</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-integration" class="sidebar-link">Continuous Integration</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#was-gehort-zu-einem-build" class="sidebar-link">Was geh√∂rt zu einem Build?</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#build-tools" class="sidebar-link">Build-Tools</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-delivery" class="sidebar-link">Continuous Delivery</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#warum" class="sidebar-link">Warum?</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#vorteile-der-automatisierung" class="sidebar-link">Vorteile der Automatisierung</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#automatisierte-softwaretests" class="sidebar-link">Automatisierte Softwaretests</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#risikominimierung" class="sidebar-link">Risikominimierung</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-delivery-pipeline" class="sidebar-link">Continuous Delivery Pipeline</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-testing" class="sidebar-link">Continuous Testing</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-deployment" class="sidebar-link">Continuous Deployment</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#definition-2" class="sidebar-link">Definition</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#entwicklung-it-operations" class="sidebar-link">Entwicklung/IT-Operations</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#devsecops" class="sidebar-link">DevSecOps</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#devops-als-agiler-prozess" class="sidebar-link">DevOps als agiler Prozess</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#lean" class="sidebar-link">Lean</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#automatisierung" class="sidebar-link">Automatisierung</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#automatisiertes-testen" class="sidebar-link">Automatisiertes Testen</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#time-to-market" class="sidebar-link">Time to Market</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#feedback" class="sidebar-link">Feedback</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#itil" class="sidebar-link">ITIL</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#tools" class="sidebar-link">Tools</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#container" class="sidebar-link">Container</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#docker" class="sidebar-link">Docker</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#jira" class="sidebar-link">JIRA</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#jenkins" class="sidebar-link">Jenkins</a></li></ul></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Architekturen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Fullstack Development</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>AI - machine learning</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Embedded</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Blockchain</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="continuous-software-engineering"><a href="#continuous-software-engineering" aria-hidden="true" class="header-anchor">#</a> Continuous Software Engineering</h1><p>Autor: Nils Dralle</p><h2 id="definition"><a href="#definition" aria-hidden="true" class="header-anchor">#</a> Definition</h2><p>&quot;Continuous Software Engineering&quot; beschreibt eine M√∂glichkeit der iterativen Softwareentwicklung. Dabei wird der agile Softwareentwicklungsprozess unterst√ºtzt.
Continuous Software Engineering ist interdisziplin√§r und bezieht im Gegensatz zu reinen agilen Softwareentwicklungsmodellen mehr als die reine Softwareentwicklung mit ein.
Continuous Software Engineering l√§sst sich grob in folgende Teilbereiche einteilen:</p><ul><li>Continuous Integration</li><li>Continuous Delivery</li><li>Continuous Testing</li><li>Continuous Deployment</li></ul><p>Diese Teilbereiche sind nicht scharf definiert. Die individuelle Ausgestaltung der Teilbereiche wird dem Anwender √ºberlassen.</p><h2 id="continuous-integration"><a href="#continuous-integration" aria-hidden="true" class="header-anchor">#</a> Continuous Integration</h2><p>&quot;Continuous Integration&quot; beschreibt den Prozess, mit dem automatisiert von einer Software ein lauff√§higer Build erzeugt werden kann. Einfache Tests, wie beispielsweise Unit-Tests, geh√∂ren ebenfalls zur &quot;Continuous Integration&quot;.
&quot;Continuous Integration&quot; ist Grundlage und erster Schritt von &quot;Continuous Delivery&quot;.</p><h3 id="was-gehort-zu-einem-build"><a href="#was-gehort-zu-einem-build" aria-hidden="true" class="header-anchor">#</a> Was geh√∂rt zu einem Build?</h3><p>Aufgabe von Continuous Integration ist die Automatisierung des Build-Prozesses. Welche Schritte dabei ausgef√ºhrt werden, h√§ngt nat√ºrlich stark von verwendeter Programmiersprache und angestrebter Zielumgebung ab. Im folgenden wird der Build-Prozess in einige typische Schritte zerlegt.</p><h4 id="kompilieren"><a href="#kompilieren" aria-hidden="true" class="header-anchor">#</a> Kompilieren</h4><p>Beim kompilieren wird der Sourcecode einer Anwendung in ein Format √ºbersetzt, welches effizient vom Computer ausgef√ºhrt werden kann. Das Zielformat ist typischerweise nicht &quot;menschenlesbar&quot;. Bei interpretierten Programmiersprachen entf√§llt dieser Schritt h√§ufig.</p><h4 id="unit-tests"><a href="#unit-tests" aria-hidden="true" class="header-anchor">#</a> Unit-Tests</h4><p>Zu einem Build geh√∂rt auch das Ausf√ºhren und Auswerten von Unit-Tests. Unit-Tests testen einzelne in sich geschlossene Einheiten des Software-Systems, beispielsweise einzelne Klassen oder Dateien. Einfache Fehler k√∂nnen somit sehr schnell erkannt werden.</p><h4 id="ressourcen"><a href="#ressourcen" aria-hidden="true" class="header-anchor">#</a> Ressourcen</h4><p>Wenn die Software externe Ressourcen, beispielsweise Dateien, verwendet, m√ºssen diese m√∂glicherweise in ein Format umgewandelt werden, welches der Anwendung erm√∂glicht, diese Ressourcen effizienter zu verwenden. In bestimmten F√§llen kann es beispielsweise vorteilhaft sein, in der Entwicklung genutzte Dateien zu komprimieren, um Dateisystemoperationen zu beschleunigen.</p><h4 id="artefakte"><a href="#artefakte" aria-hidden="true" class="header-anchor">#</a> Artefakte</h4><p>Am Ende des Build-Prozesses muss die Anwendung in wiederverwendbare Artefakte, beispielsweise executables oder Container, verpackt werden. Damit kann die Anwendung auch au√üerhalb der Entwicklungsumgebung ausgef√ºhrt werden.
Ein immer h√§ufiger f√ºr diesen Schritt genutztes Werkzeug sind Container, wie sie zum Beispiel Docker bereitstellt. Dabei wird nicht nur die Anwendung eingepackt, sondern auch die Abh√§ngigkeiten.</p><h4 id="dokumentation"><a href="#dokumentation" aria-hidden="true" class="header-anchor">#</a> Dokumentation</h4><p>Wenn die Dokumentation des Sourcecode in einem passenden Format, beispielsweise JavaDoc f√ºr Java, geschrieben wurde, kann auch die automatisierte Erstellung des Sourcecode im Rahmen der Continuous Integration erfolgen.</p><h3 id="build-tools"><a href="#build-tools" aria-hidden="true" class="header-anchor">#</a> Build-Tools</h3><p>Viele der Aufgaben in einem Build werden dem Software-Entwickler von der verwendeten Entwicklungsumgebung abgenommen. Um den Build jedoch von der Entwicklungsumgebung unabh√§ngig zu machen, wird ein Build-Tool verwendet. Dies kann beispielsweise notwendig sein, wenn der Build-Prozess nicht auf dem Entwicklerger√§t stattfindet.
In der einfachsten Form ist ein Build-Tool ein Script, welches die oben genannten zu einem Build geh√∂renden Aufgaben nacheinander ausf√ºhrt. Build-Tools sollen dem Entwickler einen Gro√üteil der Konfiguration abnehmen.
Viele Build-Tools sind Programmiersprachen-spezifisch. F√ºr Java gibt es unter anderem folgende Build-Tools:</p><ul><li>Ant</li></ul><p>Bei Ant muss sich der Entwickler selbst um alle Aspekte des Builds k√ºmmern und beispielsweise Ablageorte f√ºr kompilierten Sourcecode selbst festlegen. Dadurch kann Ant aber auch auf fast jede Build-Umgebung angepasst werden.
Ant orientiert sich stark an dem Unix-Build-Tool make, wird aber im Gegensatz zu diesem in XML geschrieben.</p><ul><li>Maven</li></ul><p>Maven verfolgt einen anderen Ansatz und definiert 'Konventionen' f√ºr beispielsweise den Ablageort von Sourcecode und die Phasen eines Builds. Wenn Projekt und Build-Prozess diesen Konventionen folgen, wird der Build-Prozess sehr einfach und erfordert nur sehr wenig Konfiguration durch den Entwickler. Dadurch muss aber im Zweifelsfall sehr viel an der Build-Umgebung an das verwendete Tool angepasst werden.</p><ul><li>Gradle</li></ul><p>Gradle versucht, einen Mittelweg zu finden. √Ñhnlich wie bei Maven wird vieles √ºber Konventionen abgebildet. Weicht das Projekt von den Konventionen ab, m√ºssen die Abweichungen mit einer Gradle-spezifischen Skriptsprache definiert werden.</p><p>Anders als bei Ant k√∂nnen bei Maven und Gradle (und einigen anderen Build-Tools) Abh√§ngigkeiten definiert werden. Das Build-Tool k√ºmmert sich dann um das managen der Abh√§ngigkeiten, wohingegen diese Aufgabe bei Build-Tools wie Ant dem Entwickler √ºberlassen bleibt.</p><h2 id="continuous-delivery"><a href="#continuous-delivery" aria-hidden="true" class="header-anchor">#</a> Continuous Delivery</h2><p>&quot;Continuous Delivery&quot; beschreibt ein Vorgehen aus dem Umfeld der agilen Softwareentwicklung, welches es erm√∂glicht, Software schneller und vor allem zuverl√§ssiger in Produktion zu bringen. Grundlage daf√ºr ist die sogenannte &quot;Continuous Delivery Pipeline&quot;, die viele der n√∂tigen Prozesse automatisiert und den Gesamtprozess der Auslieferung somit reproduzierbar macht.</p><h3 id="warum"><a href="#warum" aria-hidden="true" class="header-anchor">#</a> Warum?</h3><p>Dadurch, dass Continuous Delivery vieles automatisiert und reproduzierbar macht, kann jede neue Version der Software daraufhin getestet werden, ob sie problemlos ver√∂ffentlicht werden kann. Somit werden Fehler schneller erkannt und k√∂nnen entsprechend behoben werden, bevor sie m√∂glicherweise Monate sp√§ter bei der Auslieferung der Software an den Kunden zu Problemen und Verz√∂gerungen f√ºhren.
Zudem kann die Software √∂fter als &quot;gesamtes&quot; getestet werden, und durch den hohen Grad an Automatisierung (und die bereits angesprochene Reproduzierbarkeit) ist sichergestellt, dass Fehler in der Testumgebung erkannt werden und nicht zu &quot;false positives&quot; f√ºhren.</p><h3 id="vorteile-der-automatisierung"><a href="#vorteile-der-automatisierung" aria-hidden="true" class="header-anchor">#</a> Vorteile der Automatisierung</h3><p>Durch die hohe Automatisierung von Continuous Delivery Prozessen werden die am Release beteiligten Personen entlastet und k√∂nnen sich auf ihre eigentliche Aufgabe konzentrieren, beispielsweise das Beheben von Fehlern. Die m√∂gliche hohe Frequenz an Ver√∂ffentlichungen und damit einhergehend die hohe Zahl an getesteten Versionen macht es m√∂glich, problematische √Ñnderungen schnell zu identifizieren.</p><h3 id="automatisierte-softwaretests"><a href="#automatisierte-softwaretests" aria-hidden="true" class="header-anchor">#</a> Automatisierte Softwaretests</h3><p>Soweit m√∂glich, werden die bei der Auslieferung n√∂tigen Tests der Software automatisiert. Dadurch k√∂nnen Tests ohne erh√∂hten Aufwand mehrfach durchgef√ºhrt werden. Tests k√∂nnen beispielsweise nach jeder √Ñnderung am Quellcode automatisiert ausgef√ºhrt werden und Fehler somit zeitnah erkannt und behoben werden. Wenn Tests h√§ufiger ausgef√ºhrt werden, bekommen Entwickler/Entwicklerteams schnelles Feedback zu durchgef√ºhrten √Ñnderungen.</p><h3 id="risikominimierung"><a href="#risikominimierung" aria-hidden="true" class="header-anchor">#</a> Risikominimierung</h3><p>Menschen machen Fehler. Und so unwahrscheinlich es auch klingt, auch Software-Entwickler machen Fehler. Repetitive Aufgaben k√∂nnen die Wahrscheinlichkeit von Fehlern erh√∂hen. Deshalb automatisiert Continuous Delivery solche Aufgaben, um die Wahrscheinlichkeit von Fehlern zu minimieren.
Die bei Continuous Delivery angestrebte hohe Frequenz minimiert zudem das Risiko jedes einzelnen Release, da jedes Release weniger potentiell fehleranf√§llige √Ñnderungen enth√§lt.</p><h3 id="continuous-delivery-pipeline"><a href="#continuous-delivery-pipeline" aria-hidden="true" class="header-anchor">#</a> Continuous Delivery Pipeline</h3><p><img src="/book/assets/img/cdp.418a8480.png" alt="Continuous Delivery Pipeline" title="Continuous Delivery Pipeline"></p><p>Abbildung 1 - Continuous Delivery Pipeline (Quelle: <a><a href="#ref_wolf14">[WOLF14]</a></a>)</p><p>Abbildung 1 zeigt die Continuous Delivery Pipeline. Die Phasen werden sequentiell durchlaufen, wenn also beispielsweise die Akzeptanztests fehlschlagen, werden die Kapazit√§tstest gar nicht erst ausgef√ºhrt. Die Pipeline wird abgebrochen, und sobald der Fehler, welcher zum Abbruch gef√ºhrt hat, behoben wurde, wird die Pipeline vom Anfang erneut durchlaufen.</p><h4 id="commit"><a href="#commit" aria-hidden="true" class="header-anchor">#</a> Commit</h4><p>Diese Phase deckt alles ab, was typischerweise Continuous Integration macht: Build, Unit-Test und statische Analysen.</p><h4 id="akzeptanztests"><a href="#akzeptanztests" aria-hidden="true" class="header-anchor">#</a> Akzeptanztests</h4><p>In dieser Phase werden, soweit m√∂glich, automatisiert die Anforderungen des Kunden an die Anwendung getestet. Zus√§tzlich k√∂nnen die Anforderungen mithilfe automatisierter GUI-Tests getestet werden.</p><h4 id="kapazitatstests"><a href="#kapazitatstests" aria-hidden="true" class="header-anchor">#</a> Kapazit√§tstests</h4><p>Kapazit√§tstest testen das Verhalten der Anwendung unter erwartbaren Lastbedingungen. Dabei geht es nicht unbedingt um die Leistungsf√§higkeit einer Anwendung, sondern um Skalierbarkeit. Dadurch k√∂nnen auch in einer Umgebung, die nicht der Produktionsumgebung entspricht, R√ºckschl√ºsse auf das Verhalten der Anwendung geschlossen werden.
Auch nicht funktionale Anforderungen k√∂nnen von den Kapazit√§tstests abgedeckt werden.</p><h4 id="explorativer-test"><a href="#explorativer-test" aria-hidden="true" class="header-anchor">#</a> Explorativer Test</h4><p>Beim explorativen Test wird die Anwendung mit Fokus auf neue Features und unvorhergesehenes Verhalten getestet. Diese Tests m√ºssen nicht automatisiert erfolgen. Dadurch, dass viele der sonstigen Tests aber automatisiert sind, bleibt f√ºr diesen Testschritt mehr Zeit.</p><h4 id="produktion"><a href="#produktion" aria-hidden="true" class="header-anchor">#</a> Produktion</h4><p>Bei der Einf√ºhrung in die Produktion geht es darum, die Anwendung in einer neuen Umgebung zu installieren. Durch die hohe Zahl an vorher ausgef√ºhrten Tests, die teilweise in einer der Produktionsumgebung √§hnlichen Umgebung erfolgt sind, kann das Risiko an dieser Stelle verringert werden.</p><h4 id="dokumentation-2"><a href="#dokumentation-2" aria-hidden="true" class="header-anchor">#</a> Dokumentation</h4><p>Soweit die Dokumentation des Sourcecodes mit einem geeigneten Tool (wie JavaDoc f√ºr Java) erfolgt ist, kann auch die automatische Erstellung einer Sourcecode-Dokumentation Teil der Continuous Integration sein.</p><h2 id="continuous-testing"><a href="#continuous-testing" aria-hidden="true" class="header-anchor">#</a> Continuous Testing</h2><p>Continuous Testing baut auf der Continuous Delivery auf und wird h√§ufig als deren Teil betrachtet. Teil vom Continuous Testing sind manuelle Tests, wie beispielsweise explorative Tests und manuelle Akzeptanztests, aber auch alle anderen Test, die entweder nicht automatisiert werden k√∂nnen oder effizienter von einem dedizierten Testteam durchgef√ºhrt werden k√∂nnen. Auch eine vom Entwicklerteam unabh√§ngige Qualit√§tskontrolle kann vom Continuous Testing abgedeckt sein.
Beim Continuous Testing testet das Testteam kontinuierlich den neuesten lauff√§higen Stand der Software und gibt gefundene Fehler und sonstiges Feedback an das Entwicklungsteam weiter, sobald Fehler gefunden werden. Anders als bei traditionellen manuellen Testmethoden wird davon ausgegangen, dass die getestete Software sich mit der Zeit ver√§ndert, da jeweils das neueste verf√ºgbare Release getestet wird.</p><h2 id="continuous-deployment"><a href="#continuous-deployment" aria-hidden="true" class="header-anchor">#</a> Continuous Deployment</h2><p>Continuous Deployment ist eine Alternative zur Continuous Delivery, die zwar schneller, aber auch risikoreicher sein kann. Beim Continuous Deployment wird die Continuous Delivery Pipeline nicht sequentiell durchlaufen, sondern die Software nach minimalen Tests dem Endkunden zur Verf√ºgung gestellt.
Bei diesem Vorgehen bekommt der Kunde sehr schnell die neueste Version und der Entwickler bekommt sehr schnell Feedback zur neuen Version vom Kunden, aber das Risiko, dass Fehler in der Produktion landen, ist sehr hoch.</p><h1 id="devops"><a href="#devops" aria-hidden="true" class="header-anchor">#</a> DevOps</h1><p><img src="/book/assets/img/circle_of_life.8ae5ee4d.jpg" alt="DevOps" title="DevOps"></p><p>Abbildung 2 - DevOps Cycle (Quelle: <a><a href="#ref_pien18">[PIEN18]</a></a>)</p><h2 id="definition-2"><a href="#definition-2" aria-hidden="true" class="header-anchor">#</a> Definition</h2><p>DevOps ist ein Ansatz zur Prozessverbesserung in Unternehmen. Das hei√üt, Prozesse, insbesondere diejenigen, die IT und IT-Operations betreffen, sollen schneller und effizienter werden.
Als Teil von DevOps kann Continuous Software Engineering verwendet werden, dies ist jedoch nicht zwingend. Es geht darum, die am besten funktionierenden Prozesse f√ºr das Unternehmen zu finden. Anders als Continuous Software Engineering konzentriert sich DevOps dabei eher auf die Buisness Architektur des Unternehmens.
DevOps ist Unternehmenskultur, keine Werkzeug zum l√∂sen eines konkreten Problems. Werkzeuge des Continuous Engineering werden allerdings fast immer verwendet. Beispielsweise ist Automatisierung wichtiger Bestandteil von DevOps.</p><h2 id="entwicklung-it-operations"><a href="#entwicklung-it-operations" aria-hidden="true" class="header-anchor">#</a> Entwicklung/IT-Operations</h2><p><img src="/book/assets/img/fancy_devops.742d2b79.png" alt="DevOps Fancy" title="DevOps Fancy"></p><p>Abbildung 3 - DevOps als Folge von IT und IT-Operations betreffenden Prozessen (Quelle: <a><a href="#ref_rood16">[ROOD16]</a></a>)</p><p>Der Begriff DevOps setzt sich zusammen aus den Begriffen Development (Entwicklung) und Operations. Der Bereich Entwicklung ist f√ºr die Softwareentwicklung zust√§ndig, der Bereich Operations f√ºr die notwendige IT-Infrastruktur (z.b. Bereitstellung notwendiger Tools). Wenn zus√§tzlich der Bereich Sicherheit involviert ist, spricht man auch von DevSecOps. Ziel ist es, dass diese Bereiche enger zusammenarbeiten und gemeinsam effizienter sind.
Im Bereich IT-Development wird bereits seit einigen Jahren vermehrt auf agile Methoden gesetzt. In anderen Bereichen, gerade im Bereich der IT-Operations, werden aber keine agilen Methoden eingesetzt, was zu Spannungen f√ºhren kann. DevOps m√∂chte dieses Problem l√∂sen.</p><h2 id="devsecops"><a href="#devsecops" aria-hidden="true" class="header-anchor">#</a> DevSecOps</h2><p>Der Bereich Sicherheit, insbesondere die IT-Sicherheit, spielt bei DevOps eine gro√üe Rolle. Viele Softwarel√∂sungen werden heutzutage in der Cloud verwendet, stehen also im Internet. Sicherheitsl√ºcken m√ºssen dann schnell erkannt und behoben werden. Dev(Sec-)Ops-Prozesse k√∂nnen dabei helfen.</p><h2 id="devops-als-agiler-prozess"><a href="#devops-als-agiler-prozess" aria-hidden="true" class="header-anchor">#</a> DevOps als agiler Prozess</h2><p>2001 wurde das &quot;Agile Mainfest&quot; geschrieben. In einem Ausschnitt hei√üt es</p><p>&quot;Individuals and interactions over processes and tools</p><p>Working software over comprehensive documentation</p><p>Customer collaboration over contract negotiation</p><p>Responding to change over following a plan</p><p>That is, while there is value in the items on the right, we value the items on the left
more.&quot;</p><p>Der erste Punkt, &quot;Individuals and interactions over processes and tools&quot;, also frei √ºbersetzt &quot;Der individuelle Mitarbeiter ist wichtiger als Prozesse und Werkzeuge&quot;, wird von DevOps sehr ernst genommen. Interaktionen zwischen Mitarbeitern sind wichtiger als die verwendeten Werkzeuge. Die verwendeten Werkzeuge sollen Interaktionen unterst√ºtzen, nicht bestimmen, wie diese ablaufen.
Trotzdem ist die Verwendung geeigneter Werkzeuge bei DevOps wichtig, mit Betonung auf geeignet. Wenn ein Werkzeug f√ºr Unruhe oder Streit innerhalb eines Teams f√ºhrt, ist es eventuell nicht geeignet.</p><h2 id="lean"><a href="#lean" aria-hidden="true" class="header-anchor">#</a> Lean</h2><p>Ein Grundgedanke bei DevOps ist &quot;Lean&quot;. Jede √Ñnderung, f√ºr die der Kunde nicht zahlt, entspricht verschwendeten Entwicklerressourcen. Eine √Ñnderung, die der Kunde nicht hat, wird vom Kunden nicht bezahlt. Tools wie Automatisierung und Continuous Delivery helfen dabei, √Ñnderungen m√∂glichst schnell an den Kunden auszuliefern.</p><h2 id="automatisierung"><a href="#automatisierung" aria-hidden="true" class="header-anchor">#</a> Automatisierung</h2><p>Bestandteil von DevOps ist die gr√∂√ütm√∂gliche Automatisierung des (Software-)Auslieferungsprozesses durch den Einsatz geeigneter Tools und Continuous Delivery. Einfache, repetitive Aufgaben werden automatisiert, und mehr Wert auf menschliche Interaktionen gelegt. Am Ende muss aber immer ein Mehrwert f√ºr das Unternehmen entstehen.</p><h3 id="automatisiertes-testen"><a href="#automatisiertes-testen" aria-hidden="true" class="header-anchor">#</a> Automatisiertes Testen</h3><p>Soweit m√∂glich, wird bei DevOps automatisiert, bspw. mithilfe von Unit-Tests, getestet. Jedesmal wenn aus dem Quellcode ein neuer Build erstellt wird, werden automatisierten Tests ausgef√ºhrt und deren Ergebnisse an den Entwickler weitergeleitet. Nicht alle Test k√∂nnen automatisiert ausgef√ºhrt werden. Hier helfen dann Ans√§tze wie Continuous Testing.</p><h3 id="time-to-market"><a href="#time-to-market" aria-hidden="true" class="header-anchor">#</a> Time to Market</h3><p>DevOps hat zum Ziel, die &quot;Time to market&quot;, also die Zeit, die es braucht, um ein (Software-)produkt auf den Markt zu bringen, zu verringern und im besten Fall damit Geld zu verdienen, zu verk√ºrzen. Dabei ist es auch wichtig, zu messen, ob Prozess√§nderungen wirklich die erwarteten Verbesserungen bringen. Die Nutzung von mehr Technologie zur Automatisierung ist oft vorteilhaft, wenn dies allerdings am Ende durch mehr Administrationsaufwand zu keiner Verbesserung oder sogar einer Verschlechterung f√ºhrt, ist auch keinem geholfen.</p><h2 id="feedback"><a href="#feedback" aria-hidden="true" class="header-anchor">#</a> Feedback</h2><p>Um Feedback m√∂glichst schnell zum Entwickler zu bekommen, wird bei DevOps h√§ufig ein Bugtracker verwendet. Ein Bugtracker dient dazu, Feedback von Testern zu sammeln, sodass der Entwickler die M√∂glichkeit hat, zeitnah auf Feedback einzugehen und eventuell gefundene Probleme zu beheben.
DevOps ist interdisziplin√§r, das hei√üt, am DevOps-Prozess sind mehre Teams beteiligt, und m√∂glicherweise nutzt jedes Team einen Bugtracker. Warum nicht ein und derselbe Bugtracker f√ºr alle am Prozess beteiligten Teams? Das ist oft effizienter und f√ºhrt zu weniger Reibereien zwischen den Teams.</p><h2 id="itil"><a href="#itil" aria-hidden="true" class="header-anchor">#</a> ITIL</h2><p>ITIL (Information Technology Infrastructure Library) ist ein umfangreiches Framework, welches von vielen gro√üen Unternehmen erfolgreich eingesetzt wird. ITIL bietet viele Werkzeuge, die den Softwareentwicklungsprozess (und dessen Supportprozesse) abbilden k√∂nnen. Besonders bei gro√üen, monolithischen Systemen ist ein Prozess wie ITIL zum managen aller Komponenten und Prozesse sehr n√ºtzlich.
ITIL ist nicht das selbe wie DevOps, allerdings gibt es f√ºr viele Prozesse in ITIL direkte Entsprechungen in DevOps. ITIL ist kein typisches agiles Framework, sondern dient eher zur Organisation von Prozessen in einem Unternehmen und hat damit einen √§hnlichen Grundgedanken wie DevOps.</p><h2 id="tools"><a href="#tools" aria-hidden="true" class="header-anchor">#</a> Tools</h2><h3 id="container"><a href="#container" aria-hidden="true" class="header-anchor">#</a> Container</h3><p>Ein bei DevOps sehr h√§ufig genutztes Tool sind Container. (Software-)Container kann man sich vorstellen als ein Image einer Laufzeitumgebung (wie z.b. eines Betriebssystems), welches speziell auf die Software zugeschnitten ist. F√ºr Container kann Virtualisierung eingesetzt werden. Virtualisierung ist allerdings recht ressourcenintensiv, deshalb werden h√§ufig Tools wie der containerd von Linux verwendet, um die vom Container genutzten Ressourcen und die vom Host-Betriebssystem genutzten auf Kernel-Ebene zu trennen. Ein Beispiel f√ºr ein solches Tool ist Docker von der Firma Docker Inc.</p><p>Ein gro√üer Vorteil von Container- (und teilweise auch Virtualisierungs-)umgebungen ist, sie ohne oder ohne gr√∂√üere √Ñnderungen von z.b. einer Testumgebung in eine Produktionsumgebung umzuziehen. Dies reduziert den Administrationsaufwand erheblich und macht es sehr einfach, die Software bereitzustellen.
Damit alle Plattformen, die Container unterst√ºtzen, kompatibel sind und ein Container ohne Anpassungen auf allen Plattformen lauff√§hig ist, wird Containerisierung von der Cloud Native Computing Foundation unter der Linux Foundation standardisiert.
An der Cloud Native Computing Foundation sind viele gro√üe IT-Firmen beteiligt, beispielsweise Amazon, Microsoft und Google. Diese Firmen bieten mit AWS, Azure und Google Cloud √§hnliche Cloud-Produkte, und √ºber den Standard ist garantiert, dass Container, die bei einem Anbieter lauff√§hig sind, auch bei einem anderen Anbieter funktionieren.</p><h3 id="docker"><a href="#docker" aria-hidden="true" class="header-anchor">#</a> Docker</h3><h4 id="definition-3"><a href="#definition-3" aria-hidden="true" class="header-anchor">#</a> Definition</h4><p>Docker ist ein Tool zur Containerisierung von Software. Dabei wird die Software mit allen ihren Abh√§ngigkeiten (z.b. Bibliotheken) in ein Image gepackt. Dieses Image kann dann von einem standardisierten Container ausgef√ºhrt werden.</p><p>Auch wenn Docker derzeit das bekannteste Containerisierungs-Werkzeug ist, es ist nicht das erste: Die Anf√§nge der Containerisierung gehen auf das in den 70ern und 80ern entwickelte chroot zur√ºck. Anders als Docker hat chroot die betroffenen Prozesse aber nur auf Benutzerebene voneinander isoliert, w√§hrend bei Docker einzelne Prozesse in unterschiedlichen Kernel-Namespaces laufen, um gr√∂√ütm√∂gliche Isolation ohne Virtualisierung zu erreichen.
Docker ist auch nicht das einzige solche Werkzeug. Es existiert eine Vielzahl anderer propriet√§rer und open-source L√∂sungen, von denen einige nach √§hnlichen Prinzipien aufgebaut sind wie Docker. Docker selbst basierte lange Zeit auf LXC, einer weiteren popul√§ren L√∂sung zur Containerisierung unter Linux.</p><p>Die Docker-Laufzeitumgebung ist an Linux angelehnt. Es stehen dem Entwickler somit alle die Funktionen von Linux zur Verf√ºgung. Docker selbst ist ebenfalls Linux-Software und damit standardm√§√üig nur unter Linux lauff√§hig. Soll Docker unter Windows oder Mac OS ausgef√ºhrt werden, muss ein Linux-System in einer virtuellen Maschine genutzt werden. Dazu stehen von Docker erweiternde Werkzeuge zur Verf√ºgung. Docker selbst nutzt jedoch keine Virtualisierung, sondern das Linux-Tool containerd zur Trennung von Betriebssystem- und Containerressourcen auf Kernel-Ebene. Das hat den Vorteil, dass im Gegensatz zur Virtualisierung wesentlich weniger Ressourcen reserviert werden m√ºssen und vom Container genutzt werden.</p><h4 id="aufbau"><a href="#aufbau" aria-hidden="true" class="header-anchor">#</a> Aufbau</h4><h5 id="image"><a href="#image" aria-hidden="true" class="header-anchor">#</a> Image</h5><p>Ein Image ist ein Abbild der Software mit ihren Abh√§ngigkeiten auf dem Dateisystem innerhalb des Image.</p><h5 id="layer"><a href="#layer" aria-hidden="true" class="header-anchor">#</a> Layer</h5><p>Ein Layer ist ein Set von √Ñnderungen innerhalb eines Image. F√ºr jede √Ñnderung wird im Image ein neues Layer angelegt.</p><h5 id="container-2"><a href="#container-2" aria-hidden="true" class="header-anchor">#</a> Container</h5><p>Ein Container ist die laufende Instanz eines Images. Container bieten eine standardisierte Laufzeitumgebung f√ºr Images. Standardm√§√üig wird das neueste Layer in einem Image zur Instanziierung verwendet, theoretisch kann aber jedes Layer verwendet werden.</p><h5 id="dockerfile"><a href="#dockerfile" aria-hidden="true" class="header-anchor">#</a> Dockerfile</h5><p>Das Dockerfile ist einer Skriptdatei, die den Aufbau eines Docker-Image beschreibt. Wenn ein Docker-Image von einem Dockerfile neu gebaut wird, wird ein neues Layer angelegt.</p><pre class="language-docker"><code><span class="token keyword">FROM</span> 32bit/ubuntu<span class="token punctuation">:</span>16.04
<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update
<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y openjdk<span class="token punctuation">-</span>8<span class="token punctuation">-</span>jdk<span class="token punctuation">-</span>headless
<span class="token keyword">VOLUME</span> <span class="token punctuation">[</span><span class="token string">&quot;/var/hellojavadocker&quot;</span><span class="token punctuation">]</span>
<span class="token keyword">COPY</span> HelloDocker.jar /var/hellojavadocker/
<span class="token keyword">CMD</span> java <span class="token punctuation">-</span>jar /var/hellojavadocker/HelloDocker.jar
</code></pre><p>Listing 1 - Beispiel eines Dockerfile</p><p>Listing 1 zeigt den Aufbau eines einfachen Dockerfile. Mit dem Befehl <code>FROM</code> wird festgelegt, auf Basis welchen Images das neue Image gebaut werden soll. Wird hier kein <em>tag</em> angegeben (nach dem 'üòÇ, wird standardm√§√üig der Tag latest verwendet und die neueste Version des Image verwendet.
Soll das Image ohne Inhalt initialisiert werden, also 'from scratch', so ist genau das der Befehl - <code>FROM scratch</code>. <em>scratch</em> ist ein spezielles leeres Image, welches von Docker bereitgestellt wird.
Die Befehle RUN und CMD dienen zum ausf√ºhren von Befehlen innerhalb des Containers. RUN-Befehle werden bei der Erstellung des Containers ausgef√ºhrt. Der Befehl CMD wird ausgef√ºhrt, wenn das fertige Image in einem Container gestartet wird. Jedes Dockerfile kann nur einen Befehl mit CMD ausf√ºhren.
Der Befehl VOLUME stellt einen bestimmten Pfad zur Verf√ºgung, der vom Host-Betriebssystem gemountet werden kann. Er ist in diesem Beispiel nicht unbedingt n√∂tig.
Der Befehl COPY kopiert eine Datei vom Host in den Container, wo diese dann verwendet werden kann. Ein alternativer Befehl zu COPY ist ADD. Dies ist nur eine Auswahl von Befehlen, die in einem Dockerfile verwendet werden k√∂nnen.</p><h4 id="containerisierung-vs-virtualisierung"><a href="#containerisierung-vs-virtualisierung" aria-hidden="true" class="header-anchor">#</a> Containerisierung vs. Virtualisierung</h4><p><img src="/book/assets/img/vm_vs_container.2fa38101.png" alt="Containerisierung vs. Virtualisierung" title="Containerisierung vs. Virtualisierung"></p><p>Abbildung 4 - Containerisierung vs. Virtualisierung (Quelle: <a><a href="#ref_rood16">[ROOD16]</a></a>)</p><p>√Ñhnlich wie bei der Virtualisierung wird auch bei der Containerisierung ein Gast-Betriebssystem innerhalb des Host-Systems emuliert, Containerisierung hat gegen√ºber der Virtualisierung aber den Unterschied, dass das Container-System sich Ressourcen mit dem Host-System teilt. Dies soll bei der Virtualisierung vermieden werden. Die obige Grafik soll den Unterschied verdeutlichen: Auf der linken Seite laufen mehrere vollst√§ndig voneinander getrennte Betriebssysteme zeitgleich auf einem System, auf der rechten l√§uft nur ein Betriebssystem. Die Anwendung l√§uft mit ihren Abh√§ngigkeiten in einem Container, der sich Betriebssystemressourcen mit anderen Containern teilt.</p><p>Im Falle der Containerisierung hat das zum Vorteil, das Ressourcen besser genutzt werden und der &quot;Overhead&quot; einer containerisierten Anwendung sehr viel geringer ist als der einer virtualisierten Anwendung. Dies erlaubt dem Entwickler, problemlos mehrere containerisierte Anwendungen gleichzeitig laufen zu lassen, was bei der Virtualisierung oft nicht ohne weiteres m√∂glich ist. Docker ist kein System zur Virtualisierung, sondern zur Containerisierung.</p><h4 id="betriebssystem-container-und-anwendungscontainer"><a href="#betriebssystem-container-und-anwendungscontainer" aria-hidden="true" class="header-anchor">#</a> Betriebssystem-Container und Anwendungscontainer</h4><p>Es gibt zwei Arten von Container. Betriebssystem-Container sind Container, in denen wie in einer VM ein vollwertiges Betriebssystem l√§uft. Jeder Betriebssystem-Container hat ein eigenes Dateisystem, und in jedem Betriebssystem-Container k√∂nnen mehrere Anwendungen laufen. Ein solcher Ansatz wird beispielsweise von LXC verfolgt.
Anwendungscontainer gehen einen anderen Weg. Jeder Container ist darauf ausgelegt, eine einzelne Anwendung auszuf√ºhren, und die ausgef√ºhrte Anwendung kann den Container selber nicht ver√§ndern. Dieser Ansatz ist schlanker als der der Betriebssystem-Container, allerdings kann die Isolierung vom Host-System auch nicht in gleichem Ma√üe garantiert werden.
Docker stellt Anwendungscontainer zur Verf√ºgung.</p><h4 id="tools-fur-docker"><a href="#tools-fur-docker" aria-hidden="true" class="header-anchor">#</a> Tools f√ºr Docker</h4><h5 id="docker-hub"><a href="#docker-hub" aria-hidden="true" class="header-anchor">#</a> Docker-Hub</h5><p>Docker-Hub ist ein zentrales Repository, welches vorkonfigurierte Dockercontainer bereitstellt und durch die Integration in Docker das Management und die Verteilung von Docker-Images vereinfacht. Docker-Hub erm√∂glicht es dem Nutzer, jeden Layer des Images, also jeden Versionsstand, als vollwertiges Image herunterzuladen. Das macht es sehr einfach, zwischen Versionen zu wechseln beziehungsweise auf dem neuesten Stand zu bleiben.</p><h5 id="kubernetes"><a href="#kubernetes" aria-hidden="true" class="header-anchor">#</a> Kubernetes</h5><p>Kubernetes ist eine Plattform, die die Verteilung von Docker-Images und deren Betrieb √ºber Netzwerke hinweg unterst√ºtzt. Kubernetes, urspr√ºnglich von Google entwickelt, wird inzwischen unter dem Dach der Cloud Native Computing Foundation entwickelt.
Kubernetes definiert sogenannte Pods oder Deployment Units. Jedes Pod kann ins oder mehrere Docker-Images gruppieren und ausliefern. Jedes Pod stellt einen Service bereit.
Diese Architektur ist auch als Microservice bekannt, deswegen soll hier nicht weiter darauf eingegangen werden.</p><h4 id="versionsverwaltung"><a href="#versionsverwaltung" aria-hidden="true" class="header-anchor">#</a> Versionsverwaltung</h4><p>Docker hat eine integrierte Versionsverwaltung. √Ñnderungen an einem Image werden innerhalb des Image in Form von Layern gespeichert. Mithilfe der Layer l√§sst sich die komplette Versionshistorie eines Image nachvollziehen.
Zus√§tzlich zur Versionierung mithilfe von Layern k√∂nnen einzelne Versionsst√§nde auch zum Release getaggt werden. √úber Tags lassen sich unterschiedliche Versionsst√§nde selektieren, wenn ein Container ausgef√ºhrt wird. Der standardm√§√üig von Docker genutzte Tag <em>latest</em> sollte beispielsweise immer auf die neueste Version zeigen. Die Nutzung des Tags <em>latest</em> ist bei Nutzung eine Continuous Delivery/Deployment Pipeline nicht immer vorteilhaft: Bei der Nutzung von <em>latest</em> √ºberpr√ºft Docker mithilfe der Online-Plattform DockerHub, ob eine neuere Version des Image als die lokale verf√ºgbar ist und installiert diese automatisch.</p><h4 id="sicherheit"><a href="#sicherheit" aria-hidden="true" class="header-anchor">#</a> Sicherheit</h4><p>Die Docker-Laufzeitumgebung l√§uft mit <em>root</em>-Rechten, um Zugriff auf s√§mtliche Betriebssystem-Funktionen zu haben. Die Ressourcen der Anwendung im Container werden mithilfe von containerd allerdings vom Betriebssystem getrennt, und Docker schr√§nkt den Zugriff auf wichtige Systemdateien ein.
Neben containerd nutzt Docker weitere Werkzeuge, um Container- und Betriebssystemressourcen zu trennen, zum Beispiel kernel namspaces und das speziell zur Unterst√ºtzung von Containern in den Linux-Kernel integrierte Werkzeug der cgroups.
Anders als bei Virtualisierung kann eine vollst√§ndige Trennung vom Betriebssystem nicht garantiert werden.</p><h3 id="jira"><a href="#jira" aria-hidden="true" class="header-anchor">#</a> JIRA</h3><p>JIRA ist eine webbasierte  Plattform f√ºr Projektmanagement in Softwareteams. Vor allem agile Workflows werden unterst√ºtzt, aber eine Anpassung an andere Workflows ist m√∂glich.
JIRA als Plattform ist recht umfangreich. Zu den Schritten, die von JIRA unterst√ºtzt werden, geh√∂ren das Anforderungsmanagement, das Statusmanagement und das Fehlermanagement.
Im Anforderungsmanagement werden die Anforderungen an das Softwareprojekt in das System √ºbertragen. Im Statusmanagement wird der aktuelle Fortschritt des Projekts mithilfe der Plattform im Team kommuniziert. JIRA unterst√ºtzt agile Workflows wie beispielsweise Scrum, und viele der in Scrum verwendeten Organisations- und Dokumentationsformen werden dabei unterst√ºtzt.
Schlie√ülich gibt es noch ein Fehlermanagement. Dies ist eigentlich ein klassischer Bugtracker, bei dem Tester gefundene Fehler (Bugs) in Form von Tickets eintragen k√∂nnen. Die Tickets k√∂nnen von weiteren Testern, und auch von den Entwicklern, um Informationen erweitert werden, sodass irgendwann ausreichend Informationen zur Verf√ºgung stehen, um den Fehler zu beheben.
Alle Informationen werden in JIRA in Tickets organisiert, die jeder am Projekt beteiligte kommentieren kann.</p><h3 id="jenkins"><a href="#jenkins" aria-hidden="true" class="header-anchor">#</a> Jenkins</h3><p>Jenkins ist ein serverbasiertes CI (Continuous Integration) und Continuous Delivery System. Jenkins ist open-source und ist darauf ausgelegt, m√∂glichst viel zu automatisieren. Die Jenkins-Software basiert auf Java, es kann aber Quellcode in jeder beliebigen Programmiersprache gebaut un d getestet werde. Der Build- und Testprozess wird √ºber Skripte gesteuert. Wo der zu bauende/testende Quellcode liegt, ist bei Jenkins (fast) egal: Mehrere VCS-Systeme wie Git und SVN werden unterst√ºtzt.</p><p>Mit der Erweiterung Blue Ocean kann Jenkins auch Continuous Delivery. Nach dem CI-Prozess k√∂nnen automatisiert beliebige Tests und Skripte ausgef√ºhrt werden. Blue Ocean unterst√ºtzt nicht nur sequentielle Pipelines, sondern kann Prozesse auch parallel ausf√ºhren. Das hei√üt, wenn ein Test auf mehreren Plattformen ausgef√ºhrt wird, werden die Tests auf allen Plattformen parallel ausgef√ºhrt. Wenn ein Test auf einer Plattform fehlschl√§gt, werden die Tests auf anderen Plattformen nicht beeinflusst.
Blue Ocean kann mit popul√§ren Plattformen wie Github integriert werden. Das hei√üt, der Quellcode, der als Basis f√ºr den CI und Continuous Delivery Prozess dient, wird von Github geholt und das Ergebnis dieser Prozesse wird an Github zur√ºckgemeldet und dort im Projekt angezeigt.</p><h1 id="quellen"><a href="#quellen" aria-hidden="true" class="header-anchor">#</a> Quellen</h1><p><a name="ref_kane16">[KANE16]</a>: &quot;Docker Praxiseinstieg&quot;, 2016, Sean P. Kane, Karl Matthias</p><p><a name="ref_pien18">[PIEN18]</a>: &quot;Wie DevOps die IT beschleunigen&quot;, 2018, Frank Pientka, https://www.computerwoche.de/a/wie-devops-die-it-beschleunigen,3071433 (abgerufen am 26.06.2018)</p><p><a name="ref_ravi16">[RAVI16]</a>: &quot;Practical DevOps&quot;, 2016, A. Ravichandran et. al.</p><p><a name="ref_rood16">[ROOD16]</a>: &quot;Docker, Microservices And Kubernetes&quot;, 2016, Resa Roodsari</p><p><a name="ref_vero16">[VERO16]</a>: &quot;Practical DevOps&quot;, 2016, Joakim Verona</p><p><a name="ref_wolf14">[WOLF14]</a>: &quot;Continuous Delivery : Der pragmatische Einstieg&quot;, 2014, Eberhard Wolff</p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ‚Üê <a href="/book/hyperledger/" class="prev">
          Hyperledger Fabric Extension
        </a></span><span class="next"><a href="/book/microservices/">
          Microservices
        </a> ‚Üí
      </span></p></div></div></div></div>
    <script src="/book/assets/js/16.6f3b5537.js" defer></script><script src="/book/assets/js/app.1ad18c78.js" defer></script>
  </body>
</html>
