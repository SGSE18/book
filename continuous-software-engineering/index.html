<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SGSE 18 | Continuous Software Engineering</title>
    <meta name="description" content="Kursmaterial für das Fach &quot;Spezielle Gebiete zum Software Engineering&quot;">
    <link rel="icon" href="/book/logo.png">
    
    <link rel="preload" href="/book/assets/css/33.styles.e6fa9992.css" as="style"><link rel="preload" href="/book/assets/js/app.2202b242.js" as="script"><link rel="preload" href="/book/assets/js/17.f69c1a07.js" as="script"><link rel="prefetch" href="/book/assets/js/0.90cad6ad.js"><link rel="prefetch" href="/book/assets/js/1.7dee0c7a.js"><link rel="prefetch" href="/book/assets/js/2.6a58011c.js"><link rel="prefetch" href="/book/assets/js/3.3ff61612.js"><link rel="prefetch" href="/book/assets/js/4.9b858ee0.js"><link rel="prefetch" href="/book/assets/js/5.ae8b4186.js"><link rel="prefetch" href="/book/assets/js/6.7a0784e9.js"><link rel="prefetch" href="/book/assets/js/7.cd45fe27.js"><link rel="prefetch" href="/book/assets/js/8.d540d671.js"><link rel="prefetch" href="/book/assets/js/9.b550536e.js"><link rel="prefetch" href="/book/assets/js/10.94e1aa9b.js"><link rel="prefetch" href="/book/assets/js/11.aa73c730.js"><link rel="prefetch" href="/book/assets/js/12.78da023d.js"><link rel="prefetch" href="/book/assets/js/13.0bb24f9e.js"><link rel="prefetch" href="/book/assets/js/14.fe8b3da6.js"><link rel="prefetch" href="/book/assets/js/15.1cda3e0e.js"><link rel="prefetch" href="/book/assets/js/16.434b6593.js"><link rel="prefetch" href="/book/assets/js/18.01ecc549.js"><link rel="prefetch" href="/book/assets/js/19.9190ad8d.js"><link rel="prefetch" href="/book/assets/js/20.3dfe3e8a.js"><link rel="prefetch" href="/book/assets/js/21.145259ea.js"><link rel="prefetch" href="/book/assets/js/22.99edac00.js"><link rel="prefetch" href="/book/assets/js/23.d3366a42.js"><link rel="prefetch" href="/book/assets/js/24.447c88f9.js"><link rel="prefetch" href="/book/assets/js/25.40cb6761.js"><link rel="prefetch" href="/book/assets/js/26.b39d3aba.js"><link rel="prefetch" href="/book/assets/js/27.81d02fad.js"><link rel="prefetch" href="/book/assets/js/28.74931b3f.js"><link rel="prefetch" href="/book/assets/js/29.1b88cf68.js"><link rel="prefetch" href="/book/assets/js/30.0a917f9c.js"><link rel="prefetch" href="/book/assets/js/31.c7091b5f.js"><link rel="prefetch" href="/book/assets/js/32.f3769622.js">
    <link rel="stylesheet" href="/book/assets/css/33.styles.e6fa9992.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/book/" class="home-link router-link-active"><!----><span class="site-name">
      SGSE 18
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Grundlagen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Distributed Ledger</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Continuous Software Engineering</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/book/continuous-software-engineering/" class="active sidebar-link">Continuous Software Engineering</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#definition" class="sidebar-link">Definition</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-integration" class="sidebar-link">Continuous Integration</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#was-gehort-zu-einem-build" class="sidebar-link">Was gehört zu einem Build?</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-delivery" class="sidebar-link">Continuous Delivery</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#lean" class="sidebar-link">Lean</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#warum" class="sidebar-link">Warum?</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#vorteile-der-automatisierung" class="sidebar-link">Vorteile der Automatisierung</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#automatisierte-softwaretests" class="sidebar-link">Automatisierte Softwaretests</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#risikominimierung" class="sidebar-link">Risikominimierung</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-delivery-pipeline" class="sidebar-link">Continuous Delivery Pipeline</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#agile-softwareentwicklung" class="sidebar-link">Agile Softwareentwicklung</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#fruhe-phase-mit-scrum" class="sidebar-link">Frühe Phase mit Scrum</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#devops" class="sidebar-link">DevOps</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#workflows" class="sidebar-link">Workflows</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#tools" class="sidebar-link">Tools</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#docker" class="sidebar-link">Docker</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#jira" class="sidebar-link">JIRA</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#jenkins" class="sidebar-link">Jenkins</a></li></ul></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Architekturen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Fullstack Development</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>AI - machine learning</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Embedded</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Blockchain</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="continuous-software-engineering"><a href="#continuous-software-engineering" aria-hidden="true" class="header-anchor">#</a> Continuous Software Engineering</h1><h2 id="definition"><a href="#definition" aria-hidden="true" class="header-anchor">#</a> Definition</h2><p>&quot;Continuous Software Engineering&quot; beschreibt eine Möglichkeit der iterativen Softwareentwicklung und fokussiert sich auf den Prozess der Auslieferung an den Benutzer. DAbei wird der agile Softwareentwicklungsprozess unterstützt. Continuous Software Engineering ist interdisziplinär und bezieht im Gegensatz zu reinen agilen Softwareentwicklungsmodellen mehr als die reine Softwareentwicklung mit ein.</p><h2 id="continuous-integration"><a href="#continuous-integration" aria-hidden="true" class="header-anchor">#</a> Continuous Integration</h2><p>&quot;Continuous Integration&quot; beschreibt den automatisierten Prozess, mit dem automatisiert von einer Software ein lauffähiger Build erzeugt werden kann. Einfache Tests, wie beispielsweise Unit-Tests, gehören ebenfalls zur &quot;Continuous Integration&quot;.
&quot;Continuous Integration&quot; ist Grundlage und erster Schritt von &quot;Continuous Delivery&quot;.</p><h3 id="was-gehort-zu-einem-build"><a href="#was-gehort-zu-einem-build" aria-hidden="true" class="header-anchor">#</a> Was gehört zu einem Build?</h3><p>Aufgabe von Continuous Integration ist die Automatisierung des Build-Prozesses. Welche Schritte dabei ausgeführt werden, hängt natürlich stark von verwendeter Programmiersprache und angestrebter Zielumgebung ab. Im folgenden wird der Build-Prozess in einige typische Schritte zerlegt.</p><h4 id="kompilieren"><a href="#kompilieren" aria-hidden="true" class="header-anchor">#</a> Kompilieren</h4><p>Beim kompilieren wird der Sourcecode einer Anwendung in ein Format übersetzt, welches effizient vom Computer ausgeführt werden kann. Das Zielformat ist typischerweise nicht &quot;menschenlesbar&quot;.</p><h4 id="unit-tests"><a href="#unit-tests" aria-hidden="true" class="header-anchor">#</a> Unit-Tests</h4><p>Zu einem Build gehört auch das Ausführen und Auswerten von Unit-Tests. Unit-Tests testen einzelne in sich geschlossene Einheiten des Software-Systems, beispielsweise einzelne Klassen oder Dateien. Einfache Fehler können somit sehr schnell erkannt werden.</p><h4 id="ressourcen"><a href="#ressourcen" aria-hidden="true" class="header-anchor">#</a> Ressourcen</h4><p>Wenn die Software externe Ressourcen, beispielsweise Dateien, verwendet, müssen diese möglicherweise in ein Format umgewandelt werden, welches der Anwendung ermöglicht, diese Ressourcen effizienter zu verwenden.</p><h4 id="artefakte"><a href="#artefakte" aria-hidden="true" class="header-anchor">#</a> Artefakte</h4><p>Am Ende des Build-Prozesses muss die Anwendung in wiederverwendbare Artefakte, beispielsweise executables oder Container, verpackt werden</p><h2 id="continuous-delivery"><a href="#continuous-delivery" aria-hidden="true" class="header-anchor">#</a> Continuous Delivery</h2><p>&quot;Continuous Delivery&quot; beschreibt ein Vorgehen aus dem Umfeld der agilen Softwareentwicklung, welches es ermöglicht, Software schneller und vor allem zuverlässiger in Produktion zu bringen. Grundlage dafür ist die sogenannte &quot;Continuous Delivery Pipeline&quot;, die viele der nötigen Prozesse automatisiert und den Gesamtprozess der Auslieferung somit reproduzierbar macht.</p><h3 id="lean"><a href="#lean" aria-hidden="true" class="header-anchor">#</a> Lean</h3><p>Ein Grundgedanke bei Continuous Delivery ist &quot;Lean&quot;. Jede Änderung, für die der Kunde nicht zahlt, entspricht verschwendeten Entwicklerressourcen. Eine Änderung, die der Kunde nicht hat, wird vom Kunden nicht bezahlt. Continuous Delivery hilft dabei, Änderungen möglichst schnell an den Kunden auszuliefern.</p><h3 id="warum"><a href="#warum" aria-hidden="true" class="header-anchor">#</a> Warum?</h3><p>Dadurch, dass Continuous Delivery vieles automatisiert und reproduzierbar macht, kann jede neue Version der Software daraufhin getestet werden, ob sie problemlos veröffentlicht werden kann. Somit werden Fehler schneller erkannt und können entsprechend behoben werden, bevor sie möglicherweise Monate später bei der Auslieferung der Software an den Kunden zu Problemen und Verzögerungen führen. Zudem kann die Software öfter als &quot;Gesamtes&quot; getestet werden, und durch den hohen Grad an Automatisierung (und die bereits angesprochene Reproduzierbarkeit) ist sichergestellt, dass Fehler in der Testumgebung erkannt werden und nicht zu &quot;false positives&quot; führen.</p><h3 id="vorteile-der-automatisierung"><a href="#vorteile-der-automatisierung" aria-hidden="true" class="header-anchor">#</a> Vorteile der Automatisierung</h3><p>Durch die hohe Automatisierung von Continuous Delivery Prozessen werden die am Release beteiligten Personen entlastet und können sich auf ihre eigentliche Aufgabe konzentrieren, beispielsweise das Beheben von Fehlern. Die mögliche hohe Frequenz an Veröffentlichungen und damit einhergehend die hohe Zahl an getesteten Versionen macht es möglich, problematische Änderungen schnell zu identifizieren.</p><h3 id="automatisierte-softwaretests"><a href="#automatisierte-softwaretests" aria-hidden="true" class="header-anchor">#</a> Automatisierte Softwaretests</h3><p>Soweit möglich, werden die bei der Auslieferung nötigen Tests der Software automatisiert. Dadurch können Tests ohne erhöhten Aufwand mehrfach durchgeführt werden. Test können beispielsweise nach jeder Änderung am Quellcode automatisiert ausgeführt werden und somit zeitnah erkannt und behoben werden. Wenn Tests häufiger ausgeführt werden, bekommen Eintwickler/Entwicklerteams zeitnah Feedback zu durchgeführten Änderungen.</p><h3 id="risikominimierung"><a href="#risikominimierung" aria-hidden="true" class="header-anchor">#</a> Risikominimierung</h3><p>Menschen machen Fehler. Und so unwahrscheinlich es auch klingt, auch Software-Entwickler machen Fehler. Repititive Aufgaben können die Wahrscheinlichkeit von Fehlern erhöhen. Deshalb automatisiert Continuous Delivery solche Aufgaben, um die Wahrscheinlichkeit von Fehlern zu minimieren.
Die bei Continuous Delivery angestrebte hohe Frequenz minimiert zudem das Risiko jedes einzelnen Release, da jedes Release weniger potentiell fehleranfällige Änderungen enthält.</p><h3 id="continuous-delivery-pipeline"><a href="#continuous-delivery-pipeline" aria-hidden="true" class="header-anchor">#</a> Continuous Delivery Pipeline</h3><p><img src="/book/assets/img/cdp.52b8ad43.png" alt="Continuous Delivery Pipeline" title="Continuous Delivery Pipeline"></p><p>Abbildung 1 - Continuous Delivery Pipeline (Quelle: <a><a href="#ref_wolf14">[WOLF14]</a></a>)</p><p>Abbildung 1 zeigt die Continuous Delivery Pipeline. Die Phasen werden sequentiell durchlaufen, wenn also beispielsweise die Akzeptanztests fehlschlagen, werden die Kapazitätstest gar nicht erst ausgeführt. Die Pipeline wird abgebrochen, und sobald der Fehler, welcher zum Abbruch geführt hat, behoben wurde, wird die Pipeline vom Anfang erneut durchlaufen.</p><h4 id="commit"><a href="#commit" aria-hidden="true" class="header-anchor">#</a> Commit</h4><p>Diese Phase deckt alles ab, was typischerweise Continuous Integration macht: Build, Unit-Test und statische Analysen.</p><h4 id="akzeptanztests"><a href="#akzeptanztests" aria-hidden="true" class="header-anchor">#</a> Akzeptanztests</h4><p>In dieser Phase werden, soweit möglich, automatisiert die Anforderungen des Kunden an die Anwendung getestet. Zusätzlich können die Anforderungen mithilfe automatisierter GUI-Tests getestet werden.</p><h4 id="kapazitatstests"><a href="#kapazitatstests" aria-hidden="true" class="header-anchor">#</a> Kapazitätstests</h4><p>Kapazitätstest testen das Verhalten der Anwendung unter erwartbaren Lastbedingungen. Dabei geht es nicht unbedingt um die Leistungsfähigkeit einer Anwendung, sondern um Skalierbarkeit. Dadurch können auch in einer Umgebung, die nicht der Produktionsumgebung entspricht, Rückschlüsse auf das Verhalten der Anwendung geschlossen werden.
Auch nichtfunktionale Anforderungen können von den Kapazitätstests abgedeckt werden.</p><h4 id="explorativer-test"><a href="#explorativer-test" aria-hidden="true" class="header-anchor">#</a> Explorativer Test</h4><p>Beim explorativen Test wird die Anwendung mit Fokus auf neue Features und unvorhergesehenes Verhalten getestet. Diese Tests müssen nicht automatisiert erfolgen. Dadurch, dass viele der sonstigen Tests aber automatisiert sind, bleibt für diesen Testschritt mehr Zeit.</p><h4 id="produktion"><a href="#produktion" aria-hidden="true" class="header-anchor">#</a> Produktion</h4><p>Bei der Einführung in die Produktion geht es darum, die Anwendung in einer neuen Umgebung zu installieren. Durch die hohe Zahl an vorher ausgeführten Tests, die teilweise in einer der Produktionsumgebung ähnlichen Umgebung erfolgt sind, ist dieser Schritt häufig recht risikoarm.</p><h2 id="agile-softwareentwicklung"><a href="#agile-softwareentwicklung" aria-hidden="true" class="header-anchor">#</a> Agile Softwareentwicklung</h2><p>Agile Softwareentwicklungsprozesse haben zum Ziel, den Prozess der Softwareentwicklung zu beschleunigen und die Zeit bis zum Einsatz beim Benutzer zu verkürzen.</p><h3 id="fruhe-phase-mit-scrum"><a href="#fruhe-phase-mit-scrum" aria-hidden="true" class="header-anchor">#</a> Frühe Phase mit Scrum</h3><p>Scrum ist eine agile Softwareentwicklungmethode für kleinere Softwareentwicklungsteams. Scrum beschreibt den Softwareentwicklungsprozess, nicht aber den Prozess der Auslieferung an den Nutzer.</p><h3 id="devops"><a href="#devops" aria-hidden="true" class="header-anchor">#</a> DevOps</h3><h5 id="definition-2"><a href="#definition-2" aria-hidden="true" class="header-anchor">#</a> Definition</h5><p>Anders als  z.b. Scrum beschreibt DevOps nicht den Prozess der Softwareentwicklung, sondern den Prozess der Auslieferung an den Nutzer.</p><h5 id="entwicklung-it-operations"><a href="#entwicklung-it-operations" aria-hidden="true" class="header-anchor">#</a> Entwicklung/IT-Operations</h5><p>Der Begriff DevOps setzt sich zusammen aus den Begriffen Development (Entwicklung) und Operations. Der Bereich Entwicklung ist für die Softwareentwicklung zuständig, der Bereich Operations für die notwendige IT-Infrastruktur (z.b. Bereitstellung notwendiger Tools). Wenn zusätzlich der Bereich Sicherheit involviert ist, spricht man auch von DevSecOps. Ziel ist es, dass diese Bereiche enger zusammenarbeiten.</p><h5 id="devops-als-agiler-prozess"><a href="#devops-als-agiler-prozess" aria-hidden="true" class="header-anchor">#</a> DevOps als agiler Prozess</h5><h5 id="automatisierung"><a href="#automatisierung" aria-hidden="true" class="header-anchor">#</a> Automatisierung</h5><p>Ein Ziel von DevOps ist die größtmögliche Automatisierung des Auslieferungsprozesses durch den Einsatz geeigneter Tools. Einfache, repititive Aufgaben werden automatisiert.</p><h5 id="schneller-releases-deployment-cycle"><a href="#schneller-releases-deployment-cycle" aria-hidden="true" class="header-anchor">#</a> Schneller Releases/Deployment Cycle</h5><h5 id="feedback-bugtracker"><a href="#feedback-bugtracker" aria-hidden="true" class="header-anchor">#</a> Feedback (Bugtracker)</h5><p>Um Feedback möglichst schnell zum Entwickler zu bekommen, wird bei DevOps ein Bugtracker verwendet. Der Bugtracker dient dazu, Feedback von Testern zu sammeln, sodass der Entwickler die Möglichkeit hat, zeitnah auf Feedback einzugehen und eventuell gefundene Probleme zu beheben.</p><h5 id="microservices"><a href="#microservices" aria-hidden="true" class="header-anchor">#</a> Microservices</h5><h5 id="automatisiertes-testen"><a href="#automatisiertes-testen" aria-hidden="true" class="header-anchor">#</a> Automatisiertes Testen</h5><p>Soweit möglich, wird bei DevOps automatisiert, bspw. mithilfe von Unit-Tsts, getestet. Jedesmal wenn aus dem Quellccode ein neuer Build erstellt wird, werden automatisierten Tests ausgeführt und deren Ergebnisse an den Entwickler weitergeleitet.</p><h2 id="workflows"><a href="#workflows" aria-hidden="true" class="header-anchor">#</a> Workflows</h2><pre><code>Continuous Delivery
	Continuous Integration
	schnellerer Release
	Deployment-Pipeline
	jede Version (auch intern) muss lauffähig sein
	automatisierte und manuelle Tests
Continuous Improvment
	kontinuirliche Verbesserung
	Möglichkeiten zur Verbesserung werden identifiziert und umgesetzt
Continuous Integration
	Continuous Delivery als Weiterentwicklung

Definition und Abgrenzung
</code></pre><h2 id="tools"><a href="#tools" aria-hidden="true" class="header-anchor">#</a> Tools</h2><h3 id="docker"><a href="#docker" aria-hidden="true" class="header-anchor">#</a> Docker</h3><h4 id="definition-3"><a href="#definition-3" aria-hidden="true" class="header-anchor">#</a> Definition</h4><p>Docker ist ein Tool zur Containerisierung von Software. Dabei wird die Software mit allen ihren Abhängigkeiten (z.b. Bibliotheken) in ein Image gepackt. Dieses Image kann dann von einem standardisierten Container ausgeführt werden.</p><p>Die Docker-Laufzeitumgebung ist an Linux angelehnt. Es stehen dem Entwickler somit alle die Funktionen von Linux zur Verfügung. Docker selbst ist ebenfalls Linux-Software und damit standardmäßig nur unter Linux lauffähig. Soll Docker unter Windows oder Mac OS ausgeführt werden, muss ein Linux-System in einer virtuellen Maschine genutzt werden. Docker selbst ist keine Virtualisierunganwendung.</p><h4 id="begriffe"><a href="#begriffe" aria-hidden="true" class="header-anchor">#</a> Begriffe</h4><h5 id="image"><a href="#image" aria-hidden="true" class="header-anchor">#</a> Image</h5><p>Ein Image ist ein Abbild der Software mit ihren Abhängigkeiten.</p><h5 id="layer"><a href="#layer" aria-hidden="true" class="header-anchor">#</a> Layer</h5><p>Ein Layer ist ein Set von Änderungen innerhalb eines Image. Für jede Änderung wird im Image ein neues Layer angelegt.</p><h5 id="container"><a href="#container" aria-hidden="true" class="header-anchor">#</a> Container</h5><p>Ein Container ist die laufende Instanz eines Images. Container bieten eine standardisierte Laufzeitumgebung für Images.</p><h4 id="containerisierung-vs-virtualisierung"><a href="#containerisierung-vs-virtualisierung" aria-hidden="true" class="header-anchor">#</a> Containerisierung vs. Virtualisierung</h4><p>Ähnlich wie bei der Virtualisierung wird auch bei der Containerisierung eine Gast-Betriebssystem innerhalb des Host-Systems emuliert, Containerisierung hat gegenüber der Virtualisierung aber den Unterschied, dass das Container-System sich Ressourcen mit dem Host-System teilt. Dies soll bei der Virtualisierung vermieden werden.</p><p>Im Falle der Containerisierung hat das zum Vorteil, das Ressourcen besser genutzt werden und der &quot;Overhead&quot; einer containerisierten Anwendung sehr viel geringer ist als der einer virtualisierten Anweundung. Dies erlaubt dem Entwickler, problems mehrere containerisierte Anwendungen gleichzeitig laufen zu lassen, was bei der Virtualisierung oft nicht ohne weiteres möglich ist. Docker ist kein System zur Virtualisierung, sondern zur Containerisierung.</p><h4 id="tools-fur-docker"><a href="#tools-fur-docker" aria-hidden="true" class="header-anchor">#</a> Tools für Docker</h4><h5 id="docker-hub"><a href="#docker-hub" aria-hidden="true" class="header-anchor">#</a> Docker-Hub</h5><p>Docker-Hub ist ein zentrales Repository für vorkonfigurierte Docker-Container.</p><h4 id="versionsverwaltung"><a href="#versionsverwaltung" aria-hidden="true" class="header-anchor">#</a> Versionsverwaltung</h4><p>Docker hat eine integrierte Versionsverwaltung. Änderungen an einem Image werden innerhalb des Image in Form von Layern gespeichert. Mithilfe der Layer lässt sich die komplette Versionshistorie eines Image nachvollziehen.</p><h4 id="sicherheit"><a href="#sicherheit" aria-hidden="true" class="header-anchor">#</a> Sicherheit</h4><p>Die Docker-Laufzeitumgebung läuft mit <em>root</em>-Rechten, um Zugriff auf sämtliche Betriebssystem-Funktionen zu haben. Die Ressourcen der Anwendung im Container werden allerdings vom Betriebssystem getrennt, und Docker schränkt den Zugriff auf wichtige Systemdateien ein.</p><h3 id="jira"><a href="#jira" aria-hidden="true" class="header-anchor">#</a> JIRA</h3><h3 id="jenkins"><a href="#jenkins" aria-hidden="true" class="header-anchor">#</a> Jenkins</h3><p>#Quellen</p><p>[VERO16]</p><p><a name="ref_wolf14">[WOLF14]</a></p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/book/hyperledger/" class="prev">
          Hyperledger
        </a></span><span class="next"><a href="/book/microservices/">
          Microservices
        </a> →
      </span></p></div></div></div></div>
    <script src="/book/assets/js/17.f69c1a07.js" defer></script><script src="/book/assets/js/app.2202b242.js" defer></script>
  </body>
</html>
