<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SGSE 18 | Continuous Software Engineering</title>
    <meta name="description" content="Kursmaterial für das Fach &quot;Spezielle Gebiete zum Software Engineering&quot;">
    <link rel="icon" href="/book/logo.png">
    
    <link rel="preload" href="/book/assets/css/32.styles.bfc63ef0.css" as="style"><link rel="preload" href="/book/assets/js/app.e7a37edc.js" as="script"><link rel="preload" href="/book/assets/js/16.8a87588a.js" as="script"><link rel="prefetch" href="/book/assets/js/0.0bfd6889.js"><link rel="prefetch" href="/book/assets/js/1.58a11527.js"><link rel="prefetch" href="/book/assets/js/2.36db9e58.js"><link rel="prefetch" href="/book/assets/js/3.a74d42ce.js"><link rel="prefetch" href="/book/assets/js/4.03d86521.js"><link rel="prefetch" href="/book/assets/js/5.ea4d954a.js"><link rel="prefetch" href="/book/assets/js/6.6f299d2b.js"><link rel="prefetch" href="/book/assets/js/7.6715fd81.js"><link rel="prefetch" href="/book/assets/js/8.a9eddd59.js"><link rel="prefetch" href="/book/assets/js/9.4eb95535.js"><link rel="prefetch" href="/book/assets/js/10.3914063a.js"><link rel="prefetch" href="/book/assets/js/11.75481656.js"><link rel="prefetch" href="/book/assets/js/12.94b5fef1.js"><link rel="prefetch" href="/book/assets/js/13.4ce12df5.js"><link rel="prefetch" href="/book/assets/js/14.b7615536.js"><link rel="prefetch" href="/book/assets/js/15.4823c653.js"><link rel="prefetch" href="/book/assets/js/17.ca31e030.js"><link rel="prefetch" href="/book/assets/js/18.b7dcb8e2.js"><link rel="prefetch" href="/book/assets/js/19.b115c029.js"><link rel="prefetch" href="/book/assets/js/20.4aafb0a7.js"><link rel="prefetch" href="/book/assets/js/21.6766db67.js"><link rel="prefetch" href="/book/assets/js/22.e3caa81d.js"><link rel="prefetch" href="/book/assets/js/23.d1746e7b.js"><link rel="prefetch" href="/book/assets/js/24.3c396986.js"><link rel="prefetch" href="/book/assets/js/25.fba7393c.js"><link rel="prefetch" href="/book/assets/js/26.af575038.js"><link rel="prefetch" href="/book/assets/js/27.cb14e09e.js"><link rel="prefetch" href="/book/assets/js/28.2115fb75.js"><link rel="prefetch" href="/book/assets/js/29.725c4968.js"><link rel="prefetch" href="/book/assets/js/30.c718fd88.js"><link rel="prefetch" href="/book/assets/js/31.303029b6.js">
    <link rel="stylesheet" href="/book/assets/css/32.styles.bfc63ef0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/book/" class="home-link router-link-active"><!----><span class="site-name">
      SGSE 18
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/book/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Grundlagen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Distributed Ledger</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Continuous Software Engineering</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/book/continuous-software-engineering/" class="active sidebar-link">Continuous Software Engineering</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#definition" class="sidebar-link">Definition</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-integration" class="sidebar-link">Continuous Integration</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#was-gehort-zu-einem-build" class="sidebar-link">Was gehört zu einem Build?</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#build-tools" class="sidebar-link">Build-Tools</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-delivery" class="sidebar-link">Continuous Delivery</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#warum" class="sidebar-link">Warum?</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#vorteile-der-automatisierung" class="sidebar-link">Vorteile der Automatisierung</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#automatisierte-softwaretests" class="sidebar-link">Automatisierte Softwaretests</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#risikominimierung" class="sidebar-link">Risikominimierung</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-delivery-pipeline" class="sidebar-link">Continuous Delivery Pipeline</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-testing" class="sidebar-link">Continuous Testing</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#continuous-deployment" class="sidebar-link">Continuous Deployment</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#devops" class="sidebar-link">DevOps</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#workflows" class="sidebar-link">Workflows</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#tools" class="sidebar-link">Tools</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#container" class="sidebar-link">Container</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#docker" class="sidebar-link">Docker</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#jira" class="sidebar-link">JIRA</a></li><li class="sidebar-sub-header"><a href="/book/continuous-software-engineering/#jenkins" class="sidebar-link">Jenkins</a></li></ul></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Architekturen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Fullstack Development</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>AI - machine learning</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Embedded</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Blockchain</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="continuous-software-engineering"><a href="#continuous-software-engineering" aria-hidden="true" class="header-anchor">#</a> Continuous Software Engineering</h1><p>Autor: Nils Dralle</p><h2 id="definition"><a href="#definition" aria-hidden="true" class="header-anchor">#</a> Definition</h2><p>&quot;Continuous Software Engineering&quot; beschreibt eine Möglichkeit der iterativen Softwareentwicklung und fokussiert sich auf den Prozess der Auslieferung an den Benutzer. Dabei wird der agile Softwareentwicklungsprozess unterstützt. Continuous Software Engineering ist interdisziplinär und bezieht im Gegensatz zu reinen agilen Softwareentwicklungsmodellen mehr als die reine Softwareentwicklung mit ein.
Continuous Software Engineering lässt sich grob in folgende Teilbereiche einteilen:</p><ul><li>Continuous Integration</li><li>Continuous Delivery</li><li>Continuous Testing</li><li>Continuous Deployment</li></ul><p>Diese Teilbereiche sind unscharf, d.h. sie können sich überschneiden oder zusammengefasst werden.</p><h2 id="continuous-integration"><a href="#continuous-integration" aria-hidden="true" class="header-anchor">#</a> Continuous Integration</h2><p>&quot;Continuous Integration&quot; beschreibt den automatisierten Prozess, mit dem automatisiert von einer Software ein lauffähiger Build erzeugt werden kann. Einfache Tests, wie beispielsweise Unit-Tests, gehören ebenfalls zur &quot;Continuous Integration&quot;.
&quot;Continuous Integration&quot; ist Grundlage und erster Schritt von &quot;Continuous Delivery&quot;.</p><h3 id="was-gehort-zu-einem-build"><a href="#was-gehort-zu-einem-build" aria-hidden="true" class="header-anchor">#</a> Was gehört zu einem Build?</h3><p>Aufgabe von Continuous Integration ist die Automatisierung des Build-Prozesses. Welche Schritte dabei ausgeführt werden, hängt natürlich stark von verwendeter Programmiersprache und angestrebter Zielumgebung ab. Im folgenden wird der Build-Prozess in einige typische Schritte zerlegt.</p><h4 id="kompilieren"><a href="#kompilieren" aria-hidden="true" class="header-anchor">#</a> Kompilieren</h4><p>Beim kompilieren wird der Sourcecode einer Anwendung in ein Format übersetzt, welches effizient vom Computer ausgeführt werden kann. Das Zielformat ist typischerweise nicht &quot;menschenlesbar&quot;.</p><h4 id="unit-tests"><a href="#unit-tests" aria-hidden="true" class="header-anchor">#</a> Unit-Tests</h4><p>Zu einem Build gehört auch das Ausführen und Auswerten von Unit-Tests. Unit-Tests testen einzelne in sich geschlossene Einheiten des Software-Systems, beispielsweise einzelne Klassen oder Dateien. Einfache Fehler können somit sehr schnell erkannt werden.</p><h4 id="ressourcen"><a href="#ressourcen" aria-hidden="true" class="header-anchor">#</a> Ressourcen</h4><p>Wenn die Software externe Ressourcen, beispielsweise Dateien, verwendet, müssen diese möglicherweise in ein Format umgewandelt werden, welches der Anwendung ermöglicht, diese Ressourcen effizienter zu verwenden.</p><h4 id="artefakte"><a href="#artefakte" aria-hidden="true" class="header-anchor">#</a> Artefakte</h4><p>Am Ende des Build-Prozesses muss die Anwendung in wiederverwendbare Artefakte, beispielsweise executables oder Container, verpackt werden.</p><h3 id="build-tools"><a href="#build-tools" aria-hidden="true" class="header-anchor">#</a> Build-Tools</h3><p>Viele der Aufgaben in einem Build werden dem Software-Entwickler von der verwendeten Entwicklungsumgebung abgenommen. Um den Build jedoch von der Entwicklungsumgebung unabhängig zu machen, wird ein Build-Tool verwendet.
In der einfachsten Form ist ein Build-Tool ein einfaches Script, welches die oben genannten zu einem Build gehörigen Aufgaben nacheinander ausführt. Viele Build-Tools nehmen dem Entwickler allerdings einen Großteil der Konfiguration ab.
Viele Build-Tools sind Programmiersprachen-spezifisch. Für Java gibt es unter anderem folgende Build-Tools:</p><ul><li>Ant</li></ul><p>Bei Ant muss sich der Entwickler selbst um alle Aspekte des Builds kümmern und beispielsweise Ablageorte für kompilierten Sourcecode selbst festlegen. Dadurch kann Ant aber auch auf fast jede Build-Umgebung angepasst werden.
Ant orientiert sich stark an dem Unix-Build-Tool make.</p><ul><li>Maven</li></ul><p>Maven verfolgt einen anderen Ansatz und definiert 'Konventionen' für beispielsweise den Ablageort von Sourcecode und die Phasen eines Builds. Wenn Projekt und Build-Prozess diesen Konventionen folgen, wird der Build-Prozess sehr einfach und erfordert nur sehr wenig Konfiguration durch den Entwickler. Dadurch muss aber im Zweifelsfall sehr viel an der Build-Umgebung an das verwendete Tool angepasst werden.</p><ul><li>Gradle</li></ul><p>Gradle versucht, einen Mittelweg zu finden. Ähnlich wie bei Maven wird vieles über Konventionen abgebildet. Weicht das Projekt von den Konventionen ab, müssen die Abweichungen mit einer Gradle-spezifischen Skriptsprache definiert werden.</p><h2 id="continuous-delivery"><a href="#continuous-delivery" aria-hidden="true" class="header-anchor">#</a> Continuous Delivery</h2><p>&quot;Continuous Delivery&quot; beschreibt ein Vorgehen aus dem Umfeld der agilen Softwareentwicklung, welches es ermöglicht, Software schneller und vor allem zuverlässiger in Produktion zu bringen. Grundlage dafür ist die sogenannte &quot;Continuous Delivery Pipeline&quot;, die viele der nötigen Prozesse automatisiert und den Gesamtprozess der Auslieferung somit reproduzierbar macht.</p><h3 id="warum"><a href="#warum" aria-hidden="true" class="header-anchor">#</a> Warum?</h3><p>Dadurch, dass Continuous Delivery vieles automatisiert und reproduzierbar macht, kann jede neue Version der Software daraufhin getestet werden, ob sie problemlos veröffentlicht werden kann. Somit werden Fehler schneller erkannt und können entsprechend behoben werden, bevor sie möglicherweise Monate später bei der Auslieferung der Software an den Kunden zu Problemen und Verzögerungen führen. Zudem kann die Software öfter als &quot;Gesamtes&quot; getestet werden, und durch den hohen Grad an Automatisierung (und die bereits angesprochene Reproduzierbarkeit) ist sichergestellt, dass Fehler in der Testumgebung erkannt werden und nicht zu &quot;false positives&quot; führen.</p><h3 id="vorteile-der-automatisierung"><a href="#vorteile-der-automatisierung" aria-hidden="true" class="header-anchor">#</a> Vorteile der Automatisierung</h3><p>Durch die hohe Automatisierung von Continuous Delivery Prozessen werden die am Release beteiligten Personen entlastet und können sich auf ihre eigentliche Aufgabe konzentrieren, beispielsweise das Beheben von Fehlern. Die mögliche hohe Frequenz an Veröffentlichungen und damit einhergehend die hohe Zahl an getesteten Versionen macht es möglich, problematische Änderungen schnell zu identifizieren.</p><h3 id="automatisierte-softwaretests"><a href="#automatisierte-softwaretests" aria-hidden="true" class="header-anchor">#</a> Automatisierte Softwaretests</h3><p>Soweit möglich, werden die bei der Auslieferung nötigen Tests der Software automatisiert. Dadurch können Tests ohne erhöhten Aufwand mehrfach durchgeführt werden. Test können beispielsweise nach jeder Änderung am Quellcode automatisiert ausgeführt werden und somit zeitnah erkannt und behoben werden. Wenn Tests häufiger ausgeführt werden, bekommen Eintwickler/Entwicklerteams zeitnah Feedback zu durchgeführten Änderungen.</p><h3 id="risikominimierung"><a href="#risikominimierung" aria-hidden="true" class="header-anchor">#</a> Risikominimierung</h3><p>Menschen machen Fehler. Und so unwahrscheinlich es auch klingt, auch Software-Entwickler machen Fehler. Repetitive Aufgaben können die Wahrscheinlichkeit von Fehlern erhöhen. Deshalb automatisiert Continuous Delivery solche Aufgaben, um die Wahrscheinlichkeit von Fehlern zu minimieren.
Die bei Continuous Delivery angestrebte hohe Frequenz minimiert zudem das Risiko jedes einzelnen Release, da jedes Release weniger potentiell fehleranfällige Änderungen enthält.</p><h3 id="continuous-delivery-pipeline"><a href="#continuous-delivery-pipeline" aria-hidden="true" class="header-anchor">#</a> Continuous Delivery Pipeline</h3><p><img src="/book/assets/img/cdp.418a8480.png" alt="Continuous Delivery Pipeline" title="Continuous Delivery Pipeline"></p><p>Abbildung 1 - Continuous Delivery Pipeline (Quelle: <a><a href="#ref_wolf14">[WOLF14]</a></a>)</p><p>Abbildung 1 zeigt die Continuous Delivery Pipeline. Die Phasen werden sequentiell durchlaufen, wenn also beispielsweise die Akzeptanztests fehlschlagen, werden die Kapazitätstest gar nicht erst ausgeführt. Die Pipeline wird abgebrochen, und sobald der Fehler, welcher zum Abbruch geführt hat, behoben wurde, wird die Pipeline vom Anfang erneut durchlaufen.</p><h4 id="commit"><a href="#commit" aria-hidden="true" class="header-anchor">#</a> Commit</h4><p>Diese Phase deckt alles ab, was typischerweise Continuous Integration macht: Build, Unit-Test und statische Analysen.</p><h4 id="akzeptanztests"><a href="#akzeptanztests" aria-hidden="true" class="header-anchor">#</a> Akzeptanztests</h4><p>In dieser Phase werden, soweit möglich, automatisiert die Anforderungen des Kunden an die Anwendung getestet. Zusätzlich können die Anforderungen mithilfe automatisierter GUI-Tests getestet werden.</p><h4 id="kapazitatstests"><a href="#kapazitatstests" aria-hidden="true" class="header-anchor">#</a> Kapazitätstests</h4><p>Kapazitätstest testen das Verhalten der Anwendung unter erwartbaren Lastbedingungen. Dabei geht es nicht unbedingt um die Leistungsfähigkeit einer Anwendung, sondern um Skalierbarkeit. Dadurch können auch in einer Umgebung, die nicht der Produktionsumgebung entspricht, Rückschlüsse auf das Verhalten der Anwendung geschlossen werden.
Auch nicht funktionale Anforderungen können von den Kapazitätstests abgedeckt werden.</p><h4 id="explorativer-test"><a href="#explorativer-test" aria-hidden="true" class="header-anchor">#</a> Explorativer Test</h4><p>Beim explorativen Test wird die Anwendung mit Fokus auf neue Features und unvorhergesehenes Verhalten getestet. Diese Tests müssen nicht automatisiert erfolgen. Dadurch, dass viele der sonstigen Tests aber automatisiert sind, bleibt für diesen Testschritt mehr Zeit.</p><h4 id="produktion"><a href="#produktion" aria-hidden="true" class="header-anchor">#</a> Produktion</h4><p>Bei der Einführung in die Produktion geht es darum, die Anwendung in einer neuen Umgebung zu installieren. Durch die hohe Zahl an vorher ausgeführten Tests, die teilweise in einer der Produktionsumgebung ähnlichen Umgebung erfolgt sind, ist dieser Schritt häufig recht risikoarm.</p><h2 id="continuous-testing"><a href="#continuous-testing" aria-hidden="true" class="header-anchor">#</a> Continuous Testing</h2><p>Continuous Testing baut auf der Continuous Delivery auf und wird häufig als deren Teil betrachtet. Teil vom Continuous Testing sind manuelle Tests, wie beispielsweise explorative Tests und manuelle Akzeptanztests, aber auch all anderen Test, die entweder nicht automatisiert werden können oder effizienter von einem dedizierten Testteam durchgeführt werden können.
Beim Continuous Testing testet das Testteam kontinuierlich den neuesten lauffähigen Stand der Software und gibt gefundene Fehler und sonstiges Feedback zeitnah an das Entwicklungsteam weiter. Anders als bei traditionellen manuellen Testmethoden wird davon ausgegangen, dass die getestete Software sich mit der Zeit verändert.</p><h2 id="continuous-deployment"><a href="#continuous-deployment" aria-hidden="true" class="header-anchor">#</a> Continuous Deployment</h2><p>Continuous Deployment ist eine Alternative zur Continuous Delivery, die zwar schneller, aber auch risikoreicher sein kann. Beim Continuous Deployment wird die Continuous Delivery Pipeline nicht sequentiell durchlaufen, sondern die Software nach minimalen Tests beim Endkunden deployt.
Bei diesem Vorgehen bekommt der Kunde sehr schnell die neueste Version und der Entwickler bekommt sehr schnell Feedback zur neuen Version vom Kunden, aber das Risiko, dass Fehler in der Produktion landen, ist sehr hoch.</p><h3 id="devops"><a href="#devops" aria-hidden="true" class="header-anchor">#</a> DevOps</h3><p><img src="/book/assets/img/circle_of_life.8ae5ee4d.jpg" alt="DevOps" title="DevOps"></p><p>Abbildung 2 - DevOps Cycle (Quelle: <a><a href="#ref_pien18">[PIEN18]</a></a>)</p><h5 id="definition-2"><a href="#definition-2" aria-hidden="true" class="header-anchor">#</a> Definition</h5><p>DevOps ist ein Ansatz zur Prozessverbesserung in Unternehmen. Das heißt, Prozesse, insbesondere diejenigen, die IT  und IT-Operations betreffen, sollen schneller und effizienter werden. Als Teil von DevOps kann Continuous Software Engineering verwendet werden, dies ist jedoch nicht zwingend. Es geht darum, die am besten funktionierenden Prozesse für das Unternehmen zu finden. Anders als Continuous Software Engineering konzentriert sich DevOps dabei eher auf dies Buisness Architektur des Unternehmens.
DevOps ist Unternehmenskultur, keine Werkzeug zum lösen eines konkreten Problems.</p><h5 id="entwicklung-it-operations"><a href="#entwicklung-it-operations" aria-hidden="true" class="header-anchor">#</a> Entwicklung/IT-Operations</h5><p><img src="/book/assets/img/fancy_devops.742d2b79.png" alt="DevOps Fancy" title="DevOps Fancy"></p><p>Abbildung 3 - DevOps als Folge von IT und IT-Operations betreffenden Prozessen (Quelle: <a><a href="#ref_rood16">[ROOD16]</a></a>)</p><p>Der Begriff DevOps setzt sich zusammen aus den Begriffen Development (Entwicklung) und Operations. Der Bereich Entwicklung ist für die Softwareentwicklung zuständig, der Bereich Operations für die notwendige IT-Infrastruktur (z.b. Bereitstellung notwendiger Tools). Wenn zusätzlich der Bereich Sicherheit involviert ist, spricht man auch von DevSecOps. Ziel ist es, dass diese Bereiche enger zusammenarbeiten und gemeinsam effizienter sind.</p><h4 id="devsecops"><a href="#devsecops" aria-hidden="true" class="header-anchor">#</a> DevSecOps</h4><p>Der Bereich Sicherheit, insbesondere die IT-Sicherheit, spielt bei DevOps eine große Rolle. Viele Softwarelösungen werden heutzutage in der Cloud verwendet, stehen also im Internet. Sicherheitslücken müssen dann schnell erkannt und behoben werden. Dev(Sec-)Ops-Prozesse können dabei helfen.</p><h5 id="devops-als-agiler-prozess"><a href="#devops-als-agiler-prozess" aria-hidden="true" class="header-anchor">#</a> DevOps als agiler Prozess</h5><p>2001 wurde das &quot;Agile Mainfest&quot; geschrieben. In einem Ausschnitt heißt es</p><p>&quot;Individuals and interactions over processes and tools</p><p>Working software over comprehensive documentation</p><p>Customer collaboration over contract negotiation</p><p>Responding to change over following a plan</p><p>That is, while there is value in the items on the right, we value the items on the left
more.&quot;</p><p>Der erste Punkt, &quot;Individuals and interactions over processes and tools&quot;, also frei übersetzt &quot;Der individuelle Mitarbeiter ist wichtiger als Prozesse und Werkzeuge&quot;, wird von DevOps sehr ernst genommen. Interaktionen zwischen Mitarbeitern sind wichtiger als die verwendeten Werkzeuge. Die verwendeten Werkzeuge sollen Interaktionen unterstützen, nicht bestimmen, wie diese ablaufen.
Trotzdem ist die Verwendung geeigneter Werkzeuge bei DevOps wichtig, mit Betonung auf geeignet. Wenn ein Werkzeug für Unruhe oder Streit innerhalb eines Teams führt, ist es eventuell nicht geeignet.</p><h4 id="lean"><a href="#lean" aria-hidden="true" class="header-anchor">#</a> Lean</h4><p>Ein Grundgedanke bei Continuous Delivery ist &quot;Lean&quot;. Jede Änderung, für die der Kunde nicht zahlt, entspricht verschwendeten Entwicklerressourcen. Eine Änderung, die der Kunde nicht hat, wird vom Kunden nicht bezahlt. Continuous Delivery hilft dabei, Änderungen möglichst schnell an den Kunden auszuliefern.</p><h5 id="automatisierung"><a href="#automatisierung" aria-hidden="true" class="header-anchor">#</a> Automatisierung</h5><p>Bestandteil von DevOps ist die größtmögliche Automatisierung des (Software-)Auslieferungsprozesses durch den Einsatz geeigneter Tools und Continuous Delivery. Einfache, repetitive Aufgaben werden automatisiert, und mehr Wert auf menschliche Interaktionen gelegt. Am Ende muss aber immer ein Mehrwert für das Unternehmen entstehen.</p><h5 id="time-to-market"><a href="#time-to-market" aria-hidden="true" class="header-anchor">#</a> Time to Market</h5><p>DevOps hat zum Ziel, die &quot;Time to market&quot;, also die Zeit, die es braucht, um ein (Software-)produkt auf den Markt zu bringen, zu veröffentlichen und im besten Fall damit Geld zu verdienen, zu verkürzen. Dabei ist es auch wichtig, zu messen, ob Prozessänderungen wirklich die erwartet Verbesserung bringen. Die Nutzung von mehr Technologie zur Automatisierung ist oft vorteilhaft, wenn dies allerdings am Ende durch mehr Administrationsaufwand zu keiner Verbesserung oder sogar einer Verschlechterung führt, ist auch keinem geholfen.</p><h5 id="feedback"><a href="#feedback" aria-hidden="true" class="header-anchor">#</a> Feedback</h5><p>Um Feedback möglichst schnell zum Entwickler zu bekommen, wird bei DevOps ein Bugtracker verwendet. Der Bugtracker dient dazu, Feedback von Testern zu sammeln, sodass der Entwickler die Möglichkeit hat, zeitnah auf Feedback einzugehen und eventuell gefundene Probleme zu beheben.
DevOps ist interdisziplinär, das heißt, am DevOps-Prozess sind mehre Teams beteiligt, und möglicherweise nutzt jedes Team einen Bugtracker. Warum nicht ein und derselbe Bugtracker für alle am Prozess beteiligten Teams? Das ist oft effizienter und führt zu weniger Reibereien zwischen den Teams.</p><h5 id="automatisiertes-testen"><a href="#automatisiertes-testen" aria-hidden="true" class="header-anchor">#</a> Automatisiertes Testen</h5><p>Soweit möglich, wird bei DevOps automatisiert, bspw. mithilfe von Unit-Tests, getestet. Jedesmal wenn aus dem Quellcode ein neuer Build erstellt wird, werden automatisierten Tests ausgeführt und deren Ergebnisse an den Entwickler weitergeleitet. Nicht alle Test können tzeautomatisiert ausgeführt werden. Hier helfen dann Ansätze wie Continuous Testing.</p><h5 id="itil"><a href="#itil" aria-hidden="true" class="header-anchor">#</a> ITIL</h5><p>ITIL (Information Technology Infrastructure Library) ist ein umfangreiches Framework, welches von vielen großen Unternehmen erfolgreich eingesetzt wird. ITIL bietet viele Werkzeuge, die den Softwareentwicklungsprozess (und dessen Supportprozesse) abbilden können. Besonders bei großen, monolithischen Systemen ist ein Prozess wie ITIL zum managen aller Komponenten und Prozesse sehr nützlich.
ITIL ist nicht das selbe wie DevOps, allerdings gibt es für viele Prozesse in ITIL direkte Entsprechungen in DevOps. ITIL ist kein typisches agiles Framework, sondern dient eher zur Organisation von Prozessen in einem Unternehmen und hat damit einen ähnlichen Grundgedanken wie DevOps.</p><h2 id="workflows"><a href="#workflows" aria-hidden="true" class="header-anchor">#</a> Workflows</h2><pre><code>Continuous Improvment
	kontinuirliche Verbesserung
	Möglichkeiten zur Verbesserung werden identifiziert und umgesetzt
Continuous Integration
	Continuous Delivery als Weiterentwicklung

Definition und Abgrenzung
</code></pre><h2 id="tools"><a href="#tools" aria-hidden="true" class="header-anchor">#</a> Tools</h2><h3 id="container"><a href="#container" aria-hidden="true" class="header-anchor">#</a> Container</h3><p>Ein bei DevOps sehr häufig genutztes Tool sind Container. (Software-)Container kann man sich vorstellen als ein Image einer Laufzeitumgebung (wie z.b. eines Betriebssystems), welches speziell auf die Software zugeschnitten ist. Für Container kann Virtualisierung eingesetzt werden. Virtualisierung ist allerdings recht ressourcenintensiv, deshalb werden häufig Tools wie der containerd von Linux verwendet, um die vom Container genutzten Ressourcen und die vom Host-Betriebssystem genutzten auf Kernel-Ebene zu trennen. Ein Beispiel für ein solches Tool ist Docker von der Firma Docker Inc.
Ein großer Vorteil von Container- (und teilweise auch Virtualisierungs-)umgebungen ist, sie ohne oder ohne größere Änderungen von z.b. einer Testumgebung in eine Produktionsumgebung Umzuziehen. Dies reduziert den Administrationsaufwand erheblich und macht es sehr einfach, die Software zu deployen.
Damit alle Plattformen, die Container unterstützen, kompatibel sind und ein Container ohne Anpassungen auf allen Plattformen lauffähig ist, wird Containerisierung von der Cloud Native Computing Foundation unter der Linux Foundation standardisiert. An der Cloud Native Computing Foundation sind viele große IT-Firmen beteiligt, beispielsweise Amazon, Microsoft und Google. Diese Firmen bieten mit AWS, Azure und Google Cloud ähnliche Cloud-Produkte, und über den Standard ist garantiert, dass Container, die bei einem Anbieter lauffähig sind, auch bei einem anderen Anbieter funktionieren.</p><h3 id="docker"><a href="#docker" aria-hidden="true" class="header-anchor">#</a> Docker</h3><h4 id="definition-3"><a href="#definition-3" aria-hidden="true" class="header-anchor">#</a> Definition</h4><p>Docker ist ein Tool zur Containerisierung von Software. Dabei wird die Software mit allen ihren Abhängigkeiten (z.b. Bibliotheken) in ein Image gepackt. Dieses Image kann dann von einem standardisierten Container ausgeführt werden.</p><p>Auch wenn Docker derzeit das bekannteste Containerisierungs-Werkzeug ist, es ist nicht das erste: Die Anfänge der Containerisierung gehen auf das in den 70ern und 80ern entwickelte chroot zurück. Anders als Docker hat chroot die betroffenen Prozesse aber nur auf Benutzerebene voneinander isoliert, während bei Docker einzelne Prozesse in unterschiedlichen Kernel-Namespaces laufen, um größtmögliche Isolation ohne Virtualisierung zu erreichen.
Docker ist auch nicht das einzige solche Werkzeug. Es existiert eine Vielzahl anderer proprietärer und open-source Lösungen, von denen einige nach ähnlichen Prinzipien aufgebaut sind wie Docker. Docker selbst basierte lange Zeit auf LXC, einer weiteren populären Lösung zur Containerisierung unter Linux.</p><p>Die Docker-Laufzeitumgebung ist an Linux angelehnt. Es stehen dem Entwickler somit alle die Funktionen von Linux zur Verfügung. Docker selbst ist ebenfalls Linux-Software und damit standardmäßig nur unter Linux lauffähig. Soll Docker unter Windows oder Mac OS ausgeführt werden, muss ein Linux-System in einer virtuellen Maschine genutzt werden. Dazu stehen von Docker erweiternde Werkzeuge zur Verfügung. Docker selbst nutzt jedoch keine Virtualisierung, sondern das Linux-Tool containerd zur Trennung von Betriebssystem- und Containerressourcen auf Kernel-Ebene. Das hat den Vorteil, dass im Gegensatz zur Virtualisierung wesentlich weniger Ressourcen reserviert werden müssen und vom Container genutzt werden.</p><h4 id="begriffe"><a href="#begriffe" aria-hidden="true" class="header-anchor">#</a> Begriffe</h4><h5 id="image"><a href="#image" aria-hidden="true" class="header-anchor">#</a> Image</h5><p>Ein Image ist ein Abbild der Software mit ihren Abhängigkeiten.</p><h5 id="layer"><a href="#layer" aria-hidden="true" class="header-anchor">#</a> Layer</h5><p>Ein Layer ist ein Set von Änderungen innerhalb eines Image. Für jede Änderung wird im Image ein neues Layer angelegt.</p><h5 id="container-2"><a href="#container-2" aria-hidden="true" class="header-anchor">#</a> Container</h5><p>Ein Container ist die laufende Instanz eines Images. Container bieten eine standardisierte Laufzeitumgebung für Images. Standardmäßig wird das neueste Layer in einem Image zur Instanziierung verwendet, theoretisch kann aber jedes Layer verwendet werden.</p><h4 id="containerisierung-vs-virtualisierung"><a href="#containerisierung-vs-virtualisierung" aria-hidden="true" class="header-anchor">#</a> Containerisierung vs. Virtualisierung</h4><p><img src="/book/assets/img/vm_vs_container.2fa38101.png" alt="Containerisierung vs. Virtualisierung" title="Containerisierung vs. Virtualisierung"></p><p>Abbildung 4 - Containerisierung vs. Virtualisierung (Quelle: <a><a href="#ref_rood16">[ROOD16]</a></a>)</p><p>Ähnlich wie bei der Virtualisierung wird auch bei der Containerisierung eine Gast-Betriebssystem innerhalb des Host-Systems emuliert, Containerisierung hat gegenüber der Virtualisierung aber den Unterschied, dass das Container-System sich Ressourcen mit dem Host-System teilt. Dies soll bei der Virtualisierung vermieden werden. Die obige Grafik soll den Unterschied verdeutlichen: Auf der linken Seite laufen mehrere vollständig voneinander getrennte Betriebssysteme zeitgleich auf einem System, auf der rechten läuft nur ein Betriebssystem und die Anwendung läuft mit ihren Abhängigkeiten in einem Container, der sich Betriebssystemressourcen mit anderen Containern teilt.</p><p>Im Falle der Containerisierung hat das zum Vorteil, das Ressourcen besser genutzt werden und der &quot;Overhead&quot; einer containerisierten Anwendung sehr viel geringer ist als der einer virtualisierten Anwendung. Dies erlaubt dem Entwickler, problemlos mehrere containerisierte Anwendungen gleichzeitig laufen zu lassen, was bei der Virtualisierung oft nicht ohne weiteres möglich ist. Docker ist kein System zur Virtualisierung, sondern zur Containerisierung.</p><h4 id="betriebssystem-container-und-anwendungscontainer"><a href="#betriebssystem-container-und-anwendungscontainer" aria-hidden="true" class="header-anchor">#</a> Betriebssystem-Container und Anwendungscontainer</h4><p>Es gibt zwei Arten von Container. Betriebssystem-Container sind Container, in denen wie in einer VM ein vollwertiges Betriebssystem läuft. Jeder Betriebssystem-Container hat ein eigenes Dateisystem, und in jedem Betriebssystem-Container können mehrere Anwendungen laufen. Ein solcher Ansatz wird beispielsweise von LXC verfolgt.
Anwendungscontainer funktionieren anders. Anwendungscontainer haben kein eigenes Dateisystem, alle Daten werden außerhalb des Containers gespeichert. Jeder Container ist darauf ausgelegt, eine einzelne Anwendung auszuführen, und die ausgeführte Anwendung kann den Container selber nicht verändern. Dieser Ansatz ist schlanker als der der Betriebssystem-Container, allerdings kann die Isolierung vom Host-System auch nicht in gleichem Maße garantiert werden. Docker stellt Anwendungscontainer zur Verfügung.</p><h4 id="tools-fur-docker"><a href="#tools-fur-docker" aria-hidden="true" class="header-anchor">#</a> Tools für Docker</h4><h5 id="docker-hub"><a href="#docker-hub" aria-hidden="true" class="header-anchor">#</a> Docker-Hub</h5><p>Docker-Hub ist ein zentrales Repository, welches vorkonfigurierte Dockercontainer bereitstellt und durch die Integration in Docker das Management und die Verteilung von Docker-Images vereinfacht. Docker-Hub ermöglicht es dem Nutzer, jeden Layer des Images, also jeden Versionsstand, als vollwertiges Image zu verwenden. Das macht es sehr einfach, zwischen Versionen zu wechseln beziehungsweise auf dem neuesten Stand zu bleiben.</p><h5 id="kubernetes"><a href="#kubernetes" aria-hidden="true" class="header-anchor">#</a> Kubernetes</h5><p>Kubernetes ist eine Plattform, die die Verteilung von Docker-Images und deren Betrieb über Netzwerke hinweg unterstützt. Kubernetes, ursprünglich von Google entwickelt, wird inzwischen unter dem Dach der Cloud Native Computing Foundation entwickelt.
Kubernetes definiert sogenannte Pods oder Deployment Units. Jedes Pod kann ins oder mehrere Docker-Images gruppieren und ausliefern. Jedes Pod stellt einen Service bereit.
Diese Architektur ist auch als Microservice bekannt, deswegen soll hier nicht weiter darauf eingegangen werden.</p><h4 id="versionsverwaltung"><a href="#versionsverwaltung" aria-hidden="true" class="header-anchor">#</a> Versionsverwaltung</h4><p>Docker hat eine integrierte Versionsverwaltung. Änderungen an einem Image werden innerhalb des Image in Form von Layern gespeichert. Mithilfe der Layer lässt sich die komplette Versionshistorie eines Image nachvollziehen.</p><h4 id="sicherheit"><a href="#sicherheit" aria-hidden="true" class="header-anchor">#</a> Sicherheit</h4><p>Die Docker-Laufzeitumgebung läuft mit <em>root</em>-Rechten, um Zugriff auf sämtliche Betriebssystem-Funktionen zu haben. Die Ressourcen der Anwendung im Container werden mithilfe von containerd allerdings vom Betriebssystem getrennt, und Docker schränkt den Zugriff auf wichtige Systemdateien ein. Anders als bei Virtualisierung kann eine vollständige Trennung vom Betriebssystem nicht garantiert werden.</p><h3 id="jira"><a href="#jira" aria-hidden="true" class="header-anchor">#</a> JIRA</h3><p>JIRA ist eine webbasierte  Plattform für Projektmanagement in Softwareteams. Vor allem agile Workflows werden unterstützt, aber eine Anpassung an andere Workflows ist möglich.
JIRA als Plattform ist recht umfangreich. Zu den Schritten, die von JIRA unterstützt werden, gehören das Anforderungsmanagement, das Statusmanagement und das Fehlermanagement.
Im Anforderungsmanagement werden die Anforderungen an das Softwareprojekt in das System übertragen. Im Statusmanagement wird der aktuelle Fortschritt des Projekts mithilfe der Plattform im Team kommuniziert. JIRA unterstützt agile Workflows wie beispielsweise Scrum, und viele der in Scrum verwendeten Organisations- und Dokumentationsformen werden dabei unterstützt.
Schließlich gibt es noch ein Fehlermanagement. Dies ist eigentlich ein klassischer Bugtracker, bei dem Tester gefundene Fehler (Bugs) in Form von Tickets eintragen können. Die Tickets können von weiteren Testern, und auch von den Entwicklern, um Informationen erweitert werden, sodass irgendwann ausreichend Informationen zur Verfügung stehen, um den Fehler zu beheben.
Alle Informationen werden in JIRA in Tickets organisiert, die jeder am Projekt beteiligte kommentieren kann.</p><h3 id="jenkins"><a href="#jenkins" aria-hidden="true" class="header-anchor">#</a> Jenkins</h3><p>Jenkins ist ein serverbasiertes CI (Continuous Integration) und Continuous Delivery System. Jenkins ist open-source und ist darauf ausgelegt, möglichst viel zu automatisieren. Die Jenkins-Software basiert auf Java, es kann aber Quellcode in jeder beliebigen Programmiersprache gebaut un d getestet werde. Der Build- und Testprozess wird über Skripte gesteuert. Wo der zu bauende/testende Quellcode liegt, ist bei Jenkins (fast) egal: Mehrere VCS-Systeme wie Git und SVN werden unterstützt.
Mit der Erweiterung Blue Ocean kann Jenkins auch Continuous Delivery. Nach dem CI-Prozess können automatisiert beliebige Tests und Skripte ausgeführt werden. Blue Ocean unterstützt nicht nur sequentielle Pipelines, sondern kann Prozesse auch parallel ausführen. Das heißt, wenn ein Test auf mehreren Plattformen ausgeführt wird, werden die Tests auf allen Plattformen parallel ausgeführt. Wenn ein Test auf einer Plattform fehlschlägt, werden die Tests auf anderen Plattformen nicht beeinflusst.
Blue Ocean kann mit populären Plattformen wie Github integriert werden. Das heißt, der Quellcode, der als Basis für den CI und Continuous Delivery Prozess dient, wird von Github geholt und das Ergebnis dieser Prozesse wird an Github zurückgemeldet und dort im Projekt angezeigt.</p><h1 id="quellen"><a href="#quellen" aria-hidden="true" class="header-anchor">#</a> Quellen</h1><p><a name="ref_pien18">[PIEN18]</a>: &quot;Wie DevOps die IT beschleunigen&quot;, 2018, Frank Pientka, https://www.computerwoche.de/a/wie-devops-die-it-beschleunigen,3071433 (abgerufen am 26.06.2018)</p><p><a name="ref_ravi16">[RAVI16]</a>: &quot;Practical DevOps&quot;, 2016, A. Ravichandran et. al.</p><p><a name="ref_rood16">[ROOD16]</a>: &quot;Docker, Microservices And Kubernetes&quot;, 2016, Resa Roodsari</p><p><a name="ref_vero16">[VERO16]</a>: &quot;Practical DevOps&quot;, 2016, Joakim Verona</p><p><a name="ref_wolf14">[WOLF14]</a>: &quot;Continuous Delivery : Der pragmatische Einstieg&quot;, 2014, Eberhard Wolff</p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/book/hyperledger/" class="prev">
          Hyperledger Fabric Extension
        </a></span><span class="next"><a href="/book/microservices/">
          Microservices
        </a> →
      </span></p></div></div></div></div>
    <script src="/book/assets/js/16.8a87588a.js" defer></script><script src="/book/assets/js/app.e7a37edc.js" defer></script>
  </body>
</html>
