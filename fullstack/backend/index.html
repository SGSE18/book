<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SGSE 18 | Backend</title>
    <meta name="description" content="Kursmaterial für das Fach &quot;Spezielle Gebiete zum Software Engineering&quot;">
    <link rel="icon" href="/book/logo.png">
    
    <link rel="preload" href="/book/assets/css/33.styles.e6fa9992.css" as="style"><link rel="preload" href="/book/assets/js/app.958102a5.js" as="script"><link rel="preload" href="/book/assets/js/10.8bfb988c.js" as="script"><link rel="prefetch" href="/book/assets/js/0.7dbc1163.js"><link rel="prefetch" href="/book/assets/js/1.40f277cb.js"><link rel="prefetch" href="/book/assets/js/2.285d1c38.js"><link rel="prefetch" href="/book/assets/js/3.88d2a985.js"><link rel="prefetch" href="/book/assets/js/4.c38f4093.js"><link rel="prefetch" href="/book/assets/js/5.5cc732ce.js"><link rel="prefetch" href="/book/assets/js/6.021b868c.js"><link rel="prefetch" href="/book/assets/js/7.691c97c1.js"><link rel="prefetch" href="/book/assets/js/8.798630b5.js"><link rel="prefetch" href="/book/assets/js/9.3e1422b5.js"><link rel="prefetch" href="/book/assets/js/11.fb048222.js"><link rel="prefetch" href="/book/assets/js/12.8879f166.js"><link rel="prefetch" href="/book/assets/js/13.b1643b22.js"><link rel="prefetch" href="/book/assets/js/14.acc76071.js"><link rel="prefetch" href="/book/assets/js/15.89471185.js"><link rel="prefetch" href="/book/assets/js/16.4a940de1.js"><link rel="prefetch" href="/book/assets/js/17.23221b74.js"><link rel="prefetch" href="/book/assets/js/18.efe61ee1.js"><link rel="prefetch" href="/book/assets/js/19.52c638d9.js"><link rel="prefetch" href="/book/assets/js/20.28bbf558.js"><link rel="prefetch" href="/book/assets/js/21.1bb1590f.js"><link rel="prefetch" href="/book/assets/js/22.75f2210b.js"><link rel="prefetch" href="/book/assets/js/23.2ac075a4.js"><link rel="prefetch" href="/book/assets/js/24.de9a7704.js"><link rel="prefetch" href="/book/assets/js/25.c0ec3cbc.js"><link rel="prefetch" href="/book/assets/js/26.0bb0be72.js"><link rel="prefetch" href="/book/assets/js/27.000a2b21.js"><link rel="prefetch" href="/book/assets/js/28.3ea3ba4e.js"><link rel="prefetch" href="/book/assets/js/29.f8721d68.js"><link rel="prefetch" href="/book/assets/js/30.27ec2b0f.js"><link rel="prefetch" href="/book/assets/js/31.e1164066.js"><link rel="prefetch" href="/book/assets/js/32.98d569e5.js">
    <link rel="stylesheet" href="/book/assets/css/33.styles.e6fa9992.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/book/" class="home-link router-link-active"><!----><span class="site-name">
      SGSE 18
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Grundlagen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Distributed Ledger</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Continuous Software Engineering</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Architekturen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Fullstack Development</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/book/fullstack/frontend/" class="sidebar-link">Frontend</a></li><li><a href="/book/reactive-programming/" class="sidebar-link">Functional Reactive Programming</a></li><li><a href="/book/fullstack/backend/" class="active sidebar-link">Backend</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/fullstack/backend/#node-js" class="sidebar-link">Node.js</a></li><li class="sidebar-sub-header"><a href="/book/fullstack/backend/#kommunikation" class="sidebar-link">Kommunikation</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/fullstack/backend/#grpc" class="sidebar-link">gRPC</a></li><li class="sidebar-sub-header"><a href="/book/fullstack/backend/#rest" class="sidebar-link">REST</a></li><li class="sidebar-sub-header"><a href="/book/fullstack/backend/#graphql" class="sidebar-link">GraphQL</a></li><li class="sidebar-sub-header"><a href="/book/fullstack/backend/#vergleich-der-technologien" class="sidebar-link">Vergleich der Technologien</a></li></ul></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>AI - machine learning</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Embedded</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Blockchain</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="backend"><a href="#backend" aria-hidden="true" class="header-anchor">#</a> Backend</h1><h2 id="node-js"><a href="#node-js" aria-hidden="true" class="header-anchor">#</a> Node.js</h2><h2 id="kommunikation"><a href="#kommunikation" aria-hidden="true" class="header-anchor">#</a> Kommunikation</h2><h3 id="grpc"><a href="#grpc" aria-hidden="true" class="header-anchor">#</a> gRPC</h3><h4 id="allgemein"><a href="#allgemein" aria-hidden="true" class="header-anchor">#</a> Allgemein</h4><p>gRPC ist ein von Google entwickeltes modernes, performantes Open Source RPC Framework, welches innerhalb vieler verschiedener Umgebungen laufen kann.
Mithilfe von gRPC kann eine Client-Anwendung direkt Methoden einer Server-Anwendung aufrufen, als wäre es ein lokales Objekt. Besonders hervorstechende Merkmale von gRPC sind die Nutzung von HTTP/2 und Protocol Buffers.</p><p>Quellen:
https://grpc.io/about/
https://grpc.io/docs/guides/
https://jaxenter.de/grpc-mobile-http-2-google-framework-65937</p><h5 id="http-2"><a href="#http-2" aria-hidden="true" class="header-anchor">#</a> HTTP/2</h5><p>HTTP/2 ist der Nachfolger von HTTP/1.1 und wurde 2015 veröffentlicht.
Durch das neue Protokoll wird die Latenz bei der Kommunikation zwischen Browser und Webserver verringert, welches zu einem schnelleren Aufbau von Webseiten führt.
Die größten Veränderungen gegenüber des Vorgängers können in vier Punkte aufgeteilt werden:</p><ul><li>Kommunikation auf einem Kanal</li><li>Stream Dependency</li><li>Kompression der Kopfzeilen</li><li>Server Push</li></ul><p>Quellen:
https://ieeexplore.ieee.org/document/8264830/
https://www.cyon.ch/support/a/was-ist-http-2</p><h5 id="protocol-buffers"><a href="#protocol-buffers" aria-hidden="true" class="header-anchor">#</a> Protocol Buffers</h5><p>Quellen:
https://developers.google.com/protocol-buffers/
https://grpc.io/docs/guides/</p><h4 id="vorteile"><a href="#vorteile" aria-hidden="true" class="header-anchor">#</a> Vorteile</h4><h5 id="performance"><a href="#performance" aria-hidden="true" class="header-anchor">#</a> Performance</h5><h5 id="geringe-datengrosse"><a href="#geringe-datengrosse" aria-hidden="true" class="header-anchor">#</a> Geringe Datengröße</h5><h4 id="nachteile"><a href="#nachteile" aria-hidden="true" class="header-anchor">#</a> Nachteile</h4><h5 id="fehlender-leitfaden"><a href="#fehlender-leitfaden" aria-hidden="true" class="header-anchor">#</a> Fehlender Leitfaden</h5><h4 id="anwendungsbeispiel"><a href="#anwendungsbeispiel" aria-hidden="true" class="header-anchor">#</a> Anwendungsbeispiel</h4><h3 id="rest"><a href="#rest" aria-hidden="true" class="header-anchor">#</a> REST</h3><h4 id="allgemein-2"><a href="#allgemein-2" aria-hidden="true" class="header-anchor">#</a> Allgemein</h4><p>Representational State Transfer (REST) ist das am meist verbreiteste und genutzte Mittel, um Netzwerk-APIs zu realisieren. Vorgestellt wurde die Technologie im Jahr 2000 von Roy Thomas Fielding im Rahmen seiner Dissertation und hat sich seitdem durchgesetzt.  https://www.theseus.fi/bitstream/handle/10024/141989/GraphQL-%20The%20API%20Design%20Revolution.pdf?sequence=1&amp;isAllowed=y
Bei REST handelt es sich um einen Architektur-Style, welches einen Leitfaden bilden soll, der vorgibt wie eine zustandslose Kommunikation zwischen Client und Server ablaufen sollte.</p><h5 id="nutzung"><a href="#nutzung" aria-hidden="true" class="header-anchor">#</a> Nutzung</h5><h5 id="prinzipien"><a href="#prinzipien" aria-hidden="true" class="header-anchor">#</a> Prinzipien</h5><p>Um ein effiziente Architektur zu erreichen, definiert REST die folgenden sechs Grundprinzipien, die F. Doglio in [] beschreibt. https://books.google.de/books?hl=de&amp;lr=&amp;id=kjUwCgAAQBAJ&amp;oi=fnd&amp;pg=PR7&amp;dq=5.+Pro+REST+API+Development+with+Node.js&amp;ots=f149Pu5Rua&amp;sig=5C39PrLsUvNHatLVGiogA8Shtvk#v=onepage&amp;q=5.%20Pro%20REST%20API%20Development%20with%20Node.js&amp;f=true</p><h6 id="client-server"><a href="#client-server" aria-hidden="true" class="header-anchor">#</a> Client-Server</h6><p>Das erste Grundprinzip behandelt die Netzwerk-Architektur Client-Server und damit auch die Seperierung der Zuständigkeiten. Der Server stellt ein bestimmtes Set von Services bzw. Funktionalitäten zur Verfügung, welche vom Client aufgerufen werden können. Der Server stellt Daten bereit, sowie speichert diese, und der Client kann die abgerufenen Daten darstellen und aufbereiten. Mithilfe dieser Aufteilung können Client und Server unabhängig voneinander entwickelt werden und ermöglicht dadurch gleichzeitig, dass verschiedene Client-Applikationen für dieselben Server-Services genutzt werden können.</p><h6 id="stateless"><a href="#stateless" aria-hidden="true" class="header-anchor">#</a> Stateless</h6><p>Stateless bezeichnet die Eigenschaft dass der Server keinen Status der Clients hält, sondern dass der Client bei jeder Anfrage alle zur Verständnis benötigten Daten an den Server senden muss.</p><p>Durch diese Eigenschaft verbessern sich einige Punkte an der Architektur:</p><ul><li>Die <strong>Überwachung</strong> des Systems fällt leichter, wenn alle benötigten Informationen in der jeweiligen Anfrage enthalten sind.</li><li>Das System <strong>skaliert</strong> besser, da Ressourcen nach jeder Anfrage direkt wieder freigegeben werden.</li><li>Das System ist <strong>verlässlichler</strong>, da bei einem Systemabsturz keine Zustände wiederhergestellt werden müssen, sondern nur das System selbst.</li><li>Das System ist <strong>leichter zu implementieren</strong>, da keine Sessions extra gemanaged werden müssen.</li></ul><h6 id="cache"><a href="#cache" aria-hidden="true" class="header-anchor">#</a> Cache</h6><p>Eine REST-API sollte die Möglichkeit von Cacheing bieten und Services dementsprechend markieren. Indem Antworten auf Anfragen gecachet werden, kann sich sowohl der Server einige Rechenoperationen sparen, als auch der Client die Daten schneller bereitstellen. Der Cache kann gleichzeitig Client- und Serverseitig genutzt werden, oder auch nur auf einer Seite des Systems. Ein Nachteil durch Cacheing kann auftreten, wenn die Cacheing-Regeln nicht optimal gesetzt sind, was zur Verarbeitung von veralteten Daten führen kann.</p><h6 id="uniform-interface"><a href="#uniform-interface" aria-hidden="true" class="header-anchor">#</a> Uniform-Interface</h6><p>Die API sollte so gestaltet sein, dass es einen eindeutigen Identifier für die Services in Form einer URI, wie beispielsweise einer URL, gibt. Der Zugriff auf die Services geschieht durch die HTTP-Anfragemethoden (GET, POST, PUT, DELETE, etc.) und liefert repräsentative Daten mit standardisierten Content-Typen, wie beispielsweise XML, JSON oder HTML, zurück.
Um durch die verschiedenen Services &quot;navigiert&quot; zu werden, stellt der Server dem Client nach Aufrufen eines Services Hyperlinks zu ähnlichen vorhandenen Services zur Verfügung. Diese Navigationshilfe nennt sich &quot;Hypermedia As The Engine Of Application State (HATEOAS)&quot;.</p><p>Das so geschaffene Interface kann universell von verschiedenen Geräten genutzt werden.
Dies hat zwar den Vorteil, dass man nur eine Schnittstelle pflegen muss, doch kann man als Nachteil anmerken, dass es teilweise performanter sein kann maßgeschneiderte Lösungen für die einzelnen Arten von Endgeräten zu haben.</p><h6 id="layered-system"><a href="#layered-system" aria-hidden="true" class="header-anchor">#</a> Layered System</h6><p>Eine typische REST-API nutzt mehrere System-Layer, um die Logik verschiedener Bausteine voneinander zu entkoppeln. So besteht eine API meist aus einer &quot;Business Logic Layer&quot;, einer &quot;Session Information Layer&quot; und einer &quot;Storage Layer&quot;. Die Layers nutzen nur die jeweils untere Layer und kommunizieren die Ausgabe an die obere Layer. Hierdurch kann das Gesamtsystem simplifiziert werden und eine Weiterentwicklung vereinfachen.</p><p>Der größte Nachteil an einem solchen System ist, dass es für kleine Systeme eventuell unnötige Komplexität hinzufügt und die Performance mindert.</p><h6 id="code-on-demand"><a href="#code-on-demand" aria-hidden="true" class="header-anchor">#</a> Code-On-Demand</h6><p>Code-On-Demand ist das einzige optionale Prinzip von REST. Hierbei geht es um das Prinzip, dass der Server Code bereitstellt, den der Client herunterladen und lokal ausführen kann. Hierbei handelt es sich meist um Java Applets oder JavaScript.</p><h4 id="vorteile-2"><a href="#vorteile-2" aria-hidden="true" class="header-anchor">#</a> Vorteile</h4><h5 id="bewahrte-losung"><a href="#bewahrte-losung" aria-hidden="true" class="header-anchor">#</a> Bewährte Lösung</h5><p>Durch seine große Popularität und mittlerweile jahrelange Nutzung ist REST eine bewährte Lösung für die Netzwork-Kommunikation. Es lassen sich leicht Frameworks und Tools finden, die die Implementierung einer REST-API so simpel wie möglich gestalten und frei von Anfangsschwierigkeiten sind, wie sie viele neuere Technologien noch haben.</p><h5 id="methoden-leitfaden"><a href="#methoden-leitfaden" aria-hidden="true" class="header-anchor">#</a> Methoden-Leitfaden</h5><p>Durch HATEOAS bietet REST einen leicht zu folgenden Leitfaden für Clients an. Eine ausgereifte Umsetzung ermöglicht eine sich selbst dokumentierende API, bei der der Client auf keine externe Hilfe angewiesen ist.</p><h4 id="nachteile-2"><a href="#nachteile-2" aria-hidden="true" class="header-anchor">#</a> Nachteile</h4><h5 id="fehlerhafte-rest-implementierungen"><a href="#fehlerhafte-rest-implementierungen" aria-hidden="true" class="header-anchor">#</a> Fehlerhafte REST-Implementierungen</h5><p>Viele Leute haben ein falsches Verständnis davon was REST bedeutet und kennen die Kernprinzipien nicht. Aufgrunddessen geben viele Entwickler ihren APIs den Namen &quot;REST-API&quot;, obwohl sie nicht den Prinzipien von REST folgen. So werden beispielsweise oft Cookies benutzt, um States zu halten, was gegen das &quot;Stateless&quot;-Prinzip verstößt. Fielding selbst äußerte sich einige Jahre nach seiner Dissertation dazu, dass er von dem Trend API's RESTful zu nennen, obwohl sie lediglich normale RPC API's sind, frustiert sei. http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</p><h5 id="overhead-durch-die-prinzipien"><a href="#overhead-durch-die-prinzipien" aria-hidden="true" class="header-anchor">#</a> Overhead durch die Prinzipien</h5><p>Die Stateless-Eigenschaft einer REST-API sorgt dafür, dass alle benötigten Daten mit jedem Aufruf neu mitgesendet werden müssen. Aufgrund der fehlenden States ist es nicht möglich auf sessionübergreifende Daten zurückzugreifen, was zu einem Overhead bei den Netzwerk-Aufrufen führt, der mit States eingespart werden könnte.</p><p>Zusätzlich sorgt die &quot;Layered System&quot;-Eigenschaft dazu, dass System teilweise komplexer werden, als sie müssten. Dies führt zu einem Performance- und Speicher-Overhead für kleinere Systeme.</p><h3 id="graphql"><a href="#graphql" aria-hidden="true" class="header-anchor">#</a> GraphQL</h3><h4 id="allgemein-3"><a href="#allgemein-3" aria-hidden="true" class="header-anchor">#</a> Allgemein</h4><p>GraphQL ist eine von Facebook entwickelte Query-Sprache und Runtime, die 2015 veröffentlicht wurde. Mithilfe von GraphQL können Clients präzise definieren welche Daten sie von der API anfordern. Durch diese Methode lässt sich die Anzahl der Abfragen einschränken und gleichzeitig der Daten-Overhead minimieren, da der Client immer nur genau die Daten erhält, die angefordert wurden. https://graphql.org/</p><p>Um GraphQL einzusetzen, wird ein Client, sowie ein Backend benötigt, welche beide mit der Query-Sprache umgehen können. Implementierungen der Technologie stehen auf beiden Seiten in vielen verschiedenen Programmier- und Skriptsprachen zur Verfügung.</p><p>GraphQL stellt zwischen Client und Server eine zusätzliche Schicht dar, welche die Aufgabe der Kommunikation übernimmt. Es geschieht schnell, dass man die Technologie mit einer Datenbank-Technologie verwechselt. Tatsächlich handelt es sich aber um eine Query-Sprache für APIs, nicht für Datenbanken. https://www.theseus.fi/bitstream/handle/10024/141989/GraphQL-%20The%20API%20Design%20Revolution.pdf?sequence=1&amp;isAllowed=y
GraphQL kann hierbei auf Backend-Logik aufgesetzt werden und so Query-Operationen auf den vom Backend gelieferten Daten, bereitstellen.</p><h4 id="vorteile-3"><a href="#vorteile-3" aria-hidden="true" class="header-anchor">#</a> Vorteile</h4><h5 id="effiziente-datenabfrage"><a href="#effiziente-datenabfrage" aria-hidden="true" class="header-anchor">#</a> Effiziente Datenabfrage</h5><p>Der Grund, warum Facebook GraphQL entwickelt hat, war dass durch die große und stark steigende Nutzeranzahl der Datenverkehr über das Netzwerk immer größer wurde und aktuelle Lösungen die Anfragen nur ineffizient abarbeiten konnte.
https://www.howtographql.com/basics/0-introduction/</p><p>Somit wurde eine Technologie entwickelt, die die zu übermittelnden Daten auf ein Minimum beschränkt und gleichzeitig die Anzahl der Anfragen so klein wie möglich hält.</p><p>Die zu übermittelnde Datenmenge kann von GraphQL optimiert werden, indem sogenanntes &quot;Over-Fetching&quot; und &quot;Under-Fetching&quot; verhindert wird. &quot;Over-Fetching&quot; bezeichnet das Abrufen von zu viel Informationen, während &quot;Under-Fetching&quot; das Abrufen von zu wenig Informationen beschreibt, was in den meisten Fällen zu einer zusätzlichen Netzwerk-Anfrage führt. Beide Praktiken sorgen für eine stärkere Netzwerk-Auslastung und führen somit zu Performanceproblemen.</p><p>Um diese Probleme zu verhindern, erlaubt es GraphQL dem Client seine benötigten Daten selbst zu definieren.</p><p>Wenn man diese Möglichkeit auf einen Use-Case für Facebook anwenden möchte, bietet sich als Beispiel eine Benutzersuche an. Ein normales Benutzerprofil umfasst viele verschiedene Daten. Ein Datensatzausschnitt hieraus könnte wie folgt aussehen:</p><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;John Doe&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;location&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Minden&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;birthday&quot;</span><span class="token operator">:</span> <span class="token string">&quot;24.02.1997&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;image&quot;</span><span class="token operator">:</span> <span class="token string">&quot;picture.jpg&quot;</span><span class="token punctuation">,</span>
      ...
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Ein Client, der anhand des Datensatzes eine Benutzersuche implementieren möchte, möchte allerdings nur das Profilbild, den Namen, sowie den Wohnort verwenden, um Vorschläge in der Auto-Vervollständigung anzuzeigen, also sieht seine Anfrage und das entsprechende Ergebnis wie folgt aus:</p><p><strong>Query:</strong></p><pre class="language-json"><code><span class="token punctuation">{</span>
  users<span class="token punctuation">{</span>
    name
    location
    image
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Ergebnis:</strong></p><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;data&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token property">&quot;users&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
      <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;John Doe&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;location&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Minden&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;image&quot;</span><span class="token operator">:</span> <span class="token string">&quot;picture.jpg&quot;</span>
    <span class="token punctuation">}</span>
    ...<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Dem Client ist es somit freigestellt selber festzulegen, welche Daten er benötigt. Bei einer Live-Benutzersuche, die performant bleiben muss, ist es hilfreich nur mit kleinen Objekten arbeiten zu müssen, während eine erweiterte Benutzersuche mit weiteren Filtermöglichkeiten Zugriff auf zusätzliche Eigenschaften benötigt. Beide Anwendungsfälle können mit GraphQL mit derselben Schnittstelle abgedeckt werden, ohne dass ein Mehraufwand für das Backend entsteht.</p><p>Auch die Anzahl der Anfragen kann mit GraphQL klein gehalten werden, indem der Client die Möglichkeit hat mehrere Anfragen zu kombinieren und somit effektiv nur eine Anfrage über das Netzwerk an den Server senden muss.</p><p>Als Beispiels-Anwendungsfall kann hier das Vergleichen zweier Profile gesehen werden. Um das Profil eines bestimmten Benutzers zu suchen, wird als Parameter der Name mitgegeben. Damit dieselbe Query zweimal genutzt werden kann, muss vor dem Methodennamen noch ein Alias geschrieben werden, damit die zwei Resultate voneinander zu unterscheiden sind.</p><p><strong>Query:</strong></p><pre class="language-json"><code><span class="token punctuation">{</span>
  firstUser<span class="token operator">:</span> user(name<span class="token operator">:</span> <span class="token string">&quot;John Doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    name
    location
    birthday
    image
    ...
  <span class="token punctuation">}</span>
  secondUser<span class="token operator">:</span> user(name<span class="token operator">:</span> <span class="token string">&quot;Jane Doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    name
    location
    birthday
    image
    ...
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Diese zusammengefasste Query kann innerhalb einer einzigen Netzwerk-Anfrage von der API abgehandelt werden, ohne dass die API eine entsprechende Funktion explizit bereitstellen muss. Mithilfe dieser Funktionalität kann GraphQL den Traffic zum API-Server gering halten.</p><h5 id="viele-unterstutzte-plattformen"><a href="#viele-unterstutzte-plattformen" aria-hidden="true" class="header-anchor">#</a> Viele unterstützte Plattformen</h5><p>Wie bereits zu Beginn des Kapitels erwähnt, wird GraphQL in vielen verschiedenen Programmiersprachen durch entsprechende Bibliotheken unterstützt.
:</p><table><thead><tr><th><strong>Clientseitig</strong></th><th><strong>Serverseitig</strong></th></tr></thead><tbody><tr><td><ul><li>C# / .NET</li><li>Go</li><li>Java / Android</li><li>JavaScript</li><li>Swift / Objective-C iOS</li><li>Python</li></ul></td><td><ul><li>C# / .NET</li><li>Clojure</li><li>Elixir</li><li>Erlang</li><li>Erlang</li><li>Go</li><li>Groovy</li><li>Java</li><li>JavaScript</li><li>PHP</li><li>Python</li><li>Scala</li><li>Ruby</li></ul></td></tr></tbody></table><p>[Quelle]</p><p>Durch die Kompatibilität der GraphQL-Schnittstellen ist es irrelevant welche Sprache für Server oder Client ausgewählt wurde. Unabhängig von der Wahl können Client und Server ohne zusätzliche Konfigurationen miteinander kommunizieren.
Die Auswahl der Technologie liegt dementsprechend ganz bei dem Entwickler des Clients beziehungsweise des Servers.</p><p>Zur Einarbeitung in GraphQL auf Basis einer bestimmten Technologie stellt die Webseite https://howtographql.com einen guten Einstiegspunkt dar.</p><p>Eine simple Implementierung zur serverseitigen Umsetzung von GraphQL mit NodeJS stellt GraphQL-Express zur Verfügung.</p><p>...
Eine beliebte clientseitige Umsetzung von GraphQL besteht aus einer Kombination von Apollo und React.<br>
...</p><h5 id="schnelle-funktionalitats-erweiterung"><a href="#schnelle-funktionalitats-erweiterung" aria-hidden="true" class="header-anchor">#</a> Schnelle Funktionalitäts-Erweiterung</h5><p>Die so durch GraphQL geschaffene Schnittstelle ist dementsprechend leicht anzupassen. Der Server kann an der Schnittstelle zusätzliche Informationen bereitstellen, ohne dass der Client dazu gezwungen ist seine Anfrage an die zusätzlichen Informationen anzupassen, da er sie einfach ignorieren kann. Ebenso kann der Client sich dazu entscheiden zuvor ungenutzte Daten mit abzurufen und somit neue Funktionalitäten implementieren ohne eine Schnittstellen-Änderung am Server anzufordern. Die Entwicklung von Client und Server ist somit voneinander entkoppelt, was für eine individuellere und schnellere Entwicklung sorgt, die durch kleine Anpassungen in den Queries geregelt werden kann.</p><h5 id="datenbank-agnostik"><a href="#datenbank-agnostik" aria-hidden="true" class="header-anchor">#</a> Datenbank-Agnostik</h5><p>GraphQL setzt, wie standardmäßig auch eine REST-API, nicht direkt an der Datenbank an. Daher ist es für die GraphQL-Technologie nicht relevant von welcher Quelle der bereitgestellte Datensatz entstammt.</p><p>Durch diese Vorgehensweise ist dem Entwickler die Freiheit gegeben zu wählen, welche Art der Datenspeicherung er nutzen möchte. Dies können relationalle Datenbanken, als auch NoSQL-Datenbanken sein.</p><p>Da die Syntax und Herangehensweise von GraphQL jedoch sehr nah an der von gängigen SQL-Datenbanken liegt, existieren auch zahlreiche Bibliotheken, die die Verbindung zwischen der Datenbank und GraphQL erleichtern, wie beispielsweise GraphQL-Sequelize oder PostGraphile.
https://github.com/mickhansen/graphql-sequelize
https://github.com/graphile/postgraphile</p><h4 id="nachteile-3"><a href="#nachteile-3" aria-hidden="true" class="header-anchor">#</a> Nachteile</h4><h5 id="caching"><a href="#caching" aria-hidden="true" class="header-anchor">#</a> Caching</h5><p>Da GraphQL an einem einzigen POST-Endpunkt arbeitet, ist es schwer Netzwerk-Caching zu betreiben. Caching kann in diesem Fall clientseitig von Bibliotheken wie Apollo oder Relay bereitgestellt werden. Die Problematik hierbei ist jedoch, dass der Client nicht immer wissen kann, wann die Daten aktualisiert wurden und arbeitet somit eventuell mit veralteten Daten. https://www.theseus.fi/bitstream/handle/10024/141989/GraphQL-%20The%20API%20Design%20Revolution.pdf?sequence=1&amp;isAllowed=y</p><h5 id="datei-upload"><a href="#datei-upload" aria-hidden="true" class="header-anchor">#</a> Datei-Upload</h5><p>Die GraphQL-Spezifikation beinhaltet aktuell standardmäßig leider keine Möglichkeit um Dateien hochzuladen, da nur mit serialisierbaren Daten gearbeitet werden kann. Als Lösung können Dateien Base64-Decodiert und als String übermittelt werden, was allerdings mehr Speicher und Rechenleistung benötigt oder es muss auf eine Erweiterung in Form einer zusätzlichen REST-API oder GraphQL-Bibliothek, wie beispielsweise https://github.com/jaydenseric/graphql-multipart-request-spec, gesetzt werden.</p><h4 id="weitere-codebeispiele"><a href="#weitere-codebeispiele" aria-hidden="true" class="header-anchor">#</a> Weitere Codebeispiele</h4><p>Queries
Mutationen
Fragmente</p><p>Quellen:
https://www.theseus.fi/bitstream/handle/10024/141989/GraphQL-%20The%20API%20Design%20Revolution.pdf?sequence=1&amp;isAllowed=y</p><h3 id="vergleich-der-technologien"><a href="#vergleich-der-technologien" aria-hidden="true" class="header-anchor">#</a> Vergleich der Technologien</h3></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/book/reactive-programming/" class="prev">
          Functional Reactive Programming
        </a></span><span class="next"><a href="/book/ai-ml/ai/">
          Künstliche Intelligenz
        </a> →
      </span></p></div></div></div></div>
    <script src="/book/assets/js/10.8bfb988c.js" defer></script><script src="/book/assets/js/app.958102a5.js" defer></script>
  </body>
</html>
