<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SGSE 18 | Microservices</title>
    <meta name="description" content="Kursmaterial für das Fach &quot;Spezielle Gebiete zum Software Engineering&quot;">
    <link rel="icon" href="/book/logo.png">
    
    <link rel="preload" href="/book/assets/css/32.styles.bfc63ef0.css" as="style"><link rel="preload" href="/book/assets/js/app.61b0eea4.js" as="script"><link rel="preload" href="/book/assets/js/5.9ccd745b.js" as="script"><link rel="prefetch" href="/book/assets/js/0.ffac3b5e.js"><link rel="prefetch" href="/book/assets/js/1.27ab599d.js"><link rel="prefetch" href="/book/assets/js/2.d921bfba.js"><link rel="prefetch" href="/book/assets/js/3.c76dc4bd.js"><link rel="prefetch" href="/book/assets/js/4.edbf4648.js"><link rel="prefetch" href="/book/assets/js/6.a7567d1d.js"><link rel="prefetch" href="/book/assets/js/7.8f411df4.js"><link rel="prefetch" href="/book/assets/js/8.4e36107a.js"><link rel="prefetch" href="/book/assets/js/9.c17f15e7.js"><link rel="prefetch" href="/book/assets/js/10.b8e89859.js"><link rel="prefetch" href="/book/assets/js/11.9d9d13a7.js"><link rel="prefetch" href="/book/assets/js/12.7beecde8.js"><link rel="prefetch" href="/book/assets/js/13.bea437fa.js"><link rel="prefetch" href="/book/assets/js/14.ba1a754d.js"><link rel="prefetch" href="/book/assets/js/15.842dcb0f.js"><link rel="prefetch" href="/book/assets/js/16.26086763.js"><link rel="prefetch" href="/book/assets/js/17.a2265125.js"><link rel="prefetch" href="/book/assets/js/18.b4756d92.js"><link rel="prefetch" href="/book/assets/js/19.128bdf03.js"><link rel="prefetch" href="/book/assets/js/20.928b207d.js"><link rel="prefetch" href="/book/assets/js/21.5e71017b.js"><link rel="prefetch" href="/book/assets/js/22.8f14da83.js"><link rel="prefetch" href="/book/assets/js/23.8b420a0a.js"><link rel="prefetch" href="/book/assets/js/24.0e1b2310.js"><link rel="prefetch" href="/book/assets/js/25.32fa1e3b.js"><link rel="prefetch" href="/book/assets/js/26.ffcb15b9.js"><link rel="prefetch" href="/book/assets/js/27.fa64e301.js"><link rel="prefetch" href="/book/assets/js/28.3714341f.js"><link rel="prefetch" href="/book/assets/js/29.c62477cb.js"><link rel="prefetch" href="/book/assets/js/30.dd93c7ce.js"><link rel="prefetch" href="/book/assets/js/31.442a0f4a.js">
    <link rel="stylesheet" href="/book/assets/css/32.styles.bfc63ef0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/book/" class="home-link router-link-active"><!----><span class="site-name">
      SGSE 18
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Grundlagen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Continuous Software Engineering</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Architekturen</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/book/microservices/" class="active sidebar-link">Microservices</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/microservices/#einfuhrung" class="sidebar-link">Einführung</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#charakteristiken-einer-microservice-architektur" class="sidebar-link">Charakteristiken einer Microservice-Architektur</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/microservices/#komponentisierung-via-services" class="sidebar-link">Komponentisierung via Services</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#aufbau-um-business-capabilities" class="sidebar-link">Aufbau um Business Capabilities</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#service-als-produkt" class="sidebar-link">Service als Produkt</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#smart-endpoints-and-dumb-pipes" class="sidebar-link">Smart endpoints and dumb pipes</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#dezentralisierte-fuhrung" class="sidebar-link">Dezentralisierte Führung</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#dezentralisiertes-datenmanagement" class="sidebar-link">Dezentralisiertes Datenmanagement</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#infrastructure-automation" class="sidebar-link">Infrastructure Automation</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#design-for-failure" class="sidebar-link">Design for failure</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#evolutionares-design" class="sidebar-link">Evolutionäres Design</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#client-kommunikation-mit-microservices" class="sidebar-link">Client-Kommunikation mit Microservices</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#humane-registries" class="sidebar-link">Humane Registries</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#serverless" class="sidebar-link">Serverless</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/microservices/#unterschiede-zu-monolithischen-anwendungen" class="sidebar-link">Unterschiede zu monolithischen Anwendungen</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/microservices/#vorteile" class="sidebar-link">Vorteile</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#nachteile" class="sidebar-link">Nachteile</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/microservices/#abgrenzung-zu-self-contained-systems" class="sidebar-link">Abgrenzung zu Self-Contained Systems</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#microservices-als-front-ends" class="sidebar-link">Microservices als Front-Ends</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#einsatz-von-microservices" class="sidebar-link">Einsatz von Microservices</a></li><li class="sidebar-sub-header"><a href="/book/microservices/#quellen" class="sidebar-link">Quellen</a></li></ul></li><li><a href="/book/streaming-architectures/" class="sidebar-link">Streaming Architectures</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Fullstack Development</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>AI - machine learning</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Embedded</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Blockchain</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="microservices"><a href="#microservices" aria-hidden="true" class="header-anchor">#</a> Microservices</h1><ul><li><a href="#einf%C3%BChrung">Einführung</a></li><li><a href="#charakteristiken-einer-microservice-architektur">Charakteristiken einer Microservice-Architektur</a><ul><li><a href="#komponentisierung-via-services">Komponentisierung via Services</a></li><li><a href="#aufbau-um-business-capabilities">Aufbau um Business Capabilities</a></li><li><a href="#service-als-produkt">Service als Produkt</a></li><li><a href="#smart-endpoints-and-dumb-pipes">Smart endpoints and dumb pipes</a></li><li><a href="#dezentralisierte-f%C3%BChrung">Dezentralisierte Führung</a></li><li><a href="#dezentralisiertes-datenmanagement">Dezentralisiertes Datenmanagement</a></li><li><a href="#infrastructure-automation">Infrastructure Automation</a></li><li><a href="#design-for-failure">Design for failure</a></li><li><a href="#evolution%C3%A4res-design">Evolutionäres Design</a></li><li><a href="#client-kommunikation-mit-microservices">Client-Kommunikation mit Microservices</a></li><li><a href="#humane-registries">Humane Registries</a></li><li><a href="#serverless">Serverless</a></li></ul></li><li><a href="#unterschiede-zu-monolithischen-anwendungen">Unterschiede zu monolithischen Anwendungen</a><ul><li><a href="#vorteile">Vorteile</a></li><li><a href="#nachteile">Nachteile</a></li></ul></li><li><a href="#abgrenzung-zu-self-contained-systems-und-containern">Abgrenzung zu Self-Contained Systems und Containern</a></li><li><a href="#microservices-als-front-ends">Microservices als Front-Ends</a></li><li><a href="#einsatz-von-microservices">Einsatz von Microservices</a></li><li><a href="#quellen">Quellen</a></li></ul><h2 id="einfuhrung"><a href="#einfuhrung" aria-hidden="true" class="header-anchor">#</a> Einführung</h2><p>Diese Mindmap soll einen Überblick darüber erschaffen, welche Themen in der Ausarbeitung angesprochen werden und wie sie anzuordnen sind.
<img src="/book/assets/img/overview.b366f0c4.png" alt="Übersicht"></p><p>Ein Microservice ist ein leichtgewichtiger autonomer Dienst, der eine einzige Aufgabe erfüllt und mit anderen ähnlichen Diensten über eine gut definierte Schnittstelle kollaboriert. Eine der Hauptaufgaben von Microservices ist eine Minimierung von Einflüssen im Falle einer möglichen Schnittstellenänderung. <a><a href="#ref_Nami14">[NAMI14]</a></a></p><p>Monolithischen Anwendungen werden als ein Ganzes entwickelt. Die sogenannte Drei-Schichten-Architektur beinhaltet:</p><ul><li>Clientseitige Applikation</li><li>Serverseitige Applikation</li><li>Datenbank</li></ul><p>Eine serverseitige Applikation ist ein solches Monolith, weil sie für HTTP-Anfragen zuständig ist, Zugriffe auf die Datenbank steuert und mit dem Browser interagiert. Eine Änderung im System führt zu einer neuen Version der ganzen Software. Die ganze Logik konzentriert sich in einer ausführbaren Datei. Es ist ein natürlich Weg zu entwickeln. Optimierung kan mithilfe eines Load Balancer erfolgen, damit mehrere Instanzen der Applikation nebenbei laufen können.
Allerdings kann schwierig werden eine solche Anwendung auf Dauer zu entwickeln. Es erfordert viel Aufwand ständige Änderungen und Korrekturen zu implementieren, denn bei einem Monolith muss jedes Mal das ganze System neu erstellt werden. Desweiteren ist es aufwändig die Modularität der Software aufrecht zu erhalten, ohne das intern ungewollte Abhängigkeiten zwischen den Modulen entstehen. Auch eine Skalierung des ganzen Systems erfordert viel mehr Ressourcen, als eines einzelnen Moduls. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p>Ein Vergleich einer monolithischen Anwendung in Microservices kann in der nächsten Abbildung betrachtet werden.</p><p><img src="/book/assets/img/microservices_vs_monolith.6f6eea59.png" alt="Microservices vs Monolith"></p><p><em>Microservices vs Monolith</em>, Abbildung entnommen aus <a><a href="#ref_Tatv16">[TATV16]</a></a></p><p>Um die Nachteile von monolithischen Anwendungen zu umgehen, werden diese aufgeteilt in einzelne Dienste oder Services. Eine der weit verbreitenden Illustration der verschiedenen Ansätze der Partitionierung von Monolithen ist der Skalierungswürfel. Auf der horizontalen Ebene geht es um Skalierbarkeiteines Systems durch mehrere Instanzen einer Applikation. Diese können unter anderem hinter einem Load-Balancer laufen. Auf diese Weise wird versucht die Last umzuverteilen und konstante Antwortzeiten zu erzielen. Die Z-Achse der Skalierung würden mehrere Server eine identische Kopie an Code unterhalten. Hier unterhält jeder Server nur eine Untermenge der Daten. Auftretende Probleme wären Datenkonsistenz, Datenverteilung und Datenverfügbarkeit. Die X-Achse und die Z-Achse verbessern die Skalierbarkeit und Verfügbarkeit, jedoch auch die Komplexität des Systems. Um die Komplexität zu verringern wird auf der Y-Achse skaliert. Die Skalierung nach der Y-Achse setzt voraus, dass ein System logisch und physisch in funktionale Bereich zerlegt werden kann. Dies kann zum höheren Kommunikationsaufwand führen, bringt aber mehr Flexibilität mit sich. <a><a href="#ref_Pien16">[PIEN16]</a></a>, <a><a href="#ref_Nami14">[NAMI14]</a></a></p><p><img src="/book/assets/img/scale_cube.d729d2eb.png" alt="Skalierungswürfel"></p><p><em>Skalierungswürfel</em>, Abbildung entnommen aus <a><a href="#ref_Pien16">[PIEN16]</a></a></p><p>Es gibt viele Entwurfsmuster, die zu Microservices verwandt sind. Die abgebildete monolithische Architektur ist als eine  Alternative zu Microservices zu verstehen. Bei einer wachsenden Größe der Microservices, können diese schnell wieder sich zu kleineren Monolithen zusammensetzen. Die Muster werden nach folgenden Bereichen aufgeteilt:</p><ul><li>Kommunikation</li><li>Datenhaltung</li><li>Kern</li><li>Stil</li><li>Einsatzarten</li><li>Sicherheit</li></ul><p>Wobei es noch einige mehr sind. Im Laufe der Entwicklung werden Probleme auftauchen für welche diese Muster hilfreich sein werden.<br>
Die Dienste werden nach Front-End und Back-End Services unterschieden. Je nach Client ergeben sich unterschiedliche Anforderungen an Granularität und Formate eines Service. Aus diesem Grund anstatt einer universellen Schnittstelle, sollten speziell entwickelte Lösungen für Nutzer angeboten werden. Ein API-Gateway ist eine Vermittlungskomponente welche benötigt wird, damit Services sich nicht direkt aufrufen können. Direkte Aufrufe können bei vielen Diensten die Kommunikationsstruktur schnell unübersichtlich und die Fehlersuche aufwändig machen. Außerdem erlauben lose Koppelungen zwischen den Microservices unabhängige Entwicklung, Einsatz und Skalierung. Das Gateway kann sich um Format- und Protokollumwandlung, Authentifizierung oder Überwachung kümmern. Um die angefordeten, am besten passenden Services zu finden stehen zwei Möglichkeiten zur Verfügung: clientseitig und serverseitig. Beide setzen voraus, dass die Dienste sich bei der Service-Registry an- und abmelden, auch in Fehlerfällen.</p><ol><li><em>Client-side discovery</em>: Hier wird eine zentrale Service-Registry benötigt, für die Verwaltung von Diensten und deren Orten. Der Client braucht nur den entsprechenden Service aufzufordern und bekommt die nötigen Aufrufinformationen zurück. Die Dynamik, welche mit Microservices verbunden ist, macht die Automatisierung von diesem Prozess notwendig. Die Orte (Host, Port) der Microservices werden zur Laufzeit ermittelt und ändern sich nach Verfügabarkeit.</li><li><em>Server-side discovery</em>: Im Gegensatz zur vorherigen Lösung wird die Anfrage an einen Load-Balancer gestellt. Dieser fungiert als ein Router für den Service und kommuniziert mit einer Service-Registry. Der Code ist einfacher strukturiert verglichen mit den clientseitigem Fall, allerdings muss der Load Balancer ausfallsicher und skalierbar sein. Es kann eine cloudbasierte Lösung sein oder es wird eine Clusterlösung auf jeden Service-Host verwendet als lokalen Proxy. <a><a href="#ref_Rich17">[RICH17]</a></a>, <a><a href="#ref_Pien16">[PIEN16]</a></a></li></ol><p>Auf alle Entwurfsmuster einzugehen würde den zeitlichen Rahmen um vielfaches sprengen, weswegen nur diese drei Muster beschrieben wurden.</p><p><img src="/book/assets/img/patterns.8404b841.png" alt="Entwürfe"></p><p><em>Verwandte Entwurfsmuster</em>, Abbildung entnommen aus <a><a href="#ref_Rich17">[RICH17]</a></a></p><p>Um einen gemeinsamen Datenbestand für alle Services und damit einen Engpass zu vermeiden, sollte &quot;Database-per-service&quot;-Muster zum Einsatz kommen - jeder Service verwaltet seine eigenen Daten. Es wird bewusst eine Datenredundanz in Kauf genommen. Dies erlaubt jedem Dienst eine eigene, für ihn geeignete Technologie zu wählen. <a><a href="#ref_Pien16">[PIEN16]</a></a>
Die Abbildung <em>Microservices Architektur</em> zeigt einen möglichen Aufbau von Microservices. Jedem Dienst entspricht eine Funktionalität. Einige Dienste haben eigene Datenbanken, andere greifen auf eine gemeinsame Datenbank zu.</p><p><img src="/book/assets/img/architecture.e31458fd.png" alt="Architektur"></p><p><em>Microservices Architektur</em>, Abbildung entnommen aus <a><a href="#ref_Miri17">[MIRI17]</a></a></p><h2 id="charakteristiken-einer-microservice-architektur"><a href="#charakteristiken-einer-microservice-architektur" aria-hidden="true" class="header-anchor">#</a> Charakteristiken einer Microservice-Architektur</h2><p>Es gibt keine formale Definition dieses Architekturstils. Allerdings gibt es gemeinsame Charakteristiken, welche von vielen Microservices geteilt werden. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="komponentisierung-via-services"><a href="#komponentisierung-via-services" aria-hidden="true" class="header-anchor">#</a> Komponentisierung via Services</h3><p>Normalerweise wird unter einem Komponenten der Teil einer Software verstanden, welches unabhängig von anderen veränderbar ist. Microservices bezeichnen einzelne Services, aber auch Bibliotheken, als Komponenten. Eine Bibliothek ist eine eingebundene Komponente und wird durch Funktionsaufrufe aus dem Speicher aufgerufen. Ein Service hingegen wird durch Remote Calls bzw. Web Requests aufgerufen.
Der Vorteil eines Service gegenüber einer Bibliothek liegt in der Unabhängigkeit des Ersten. Ein einziger Prozess kann aus mehreren Bibliotheken bestehen und wäre eine davon verändert, müsste die gesamte Applikation neu aufgesetzt werden. Eine Aufteilung in Services wirkt dem entgegen, weil meistens nur der jeweilige Service geändert werden muss. Desweiteren bringt eine solche Aufsplittung sauber definierte Komponentenschnittstellen mit sich. Das bedeutet, dass einzelne Softwarekomponenten besser voneinander getrennt sind. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="aufbau-um-business-capabilities"><a href="#aufbau-um-business-capabilities" aria-hidden="true" class="header-anchor">#</a> Aufbau um Business Capabilities</h3><p>Microservices sollten rund um die Business Capabilities der Organization aufgebaut werden. Business Capabilities definieren die wichtigsten Businessfunktionen. Sie beschreiben &quot;was&quot; ein Unternehmen macht. Denn das Gesetz von Conway besagt: Jede Organisation die ein System entwirft bekommt am Ende ein Entwurf welches die Kommunikationsstruktur der umzusetzenden Organisation nachbildet. Der Technologiestack deckt ein breites Feld von Software ab, wie GUI, Datenbanken, Schnittstellen. Das wiederum bedeutet, dass es cross-functional Entwicklerteam sein muss, um all die Bedingungen zu erfüllen. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p>Die nächste Abbildung stellt dar, wie Microservices sich den Business Capabilities einer Organisation anpassen.</p><p><img src="/book/assets/img/cross_functional_teams.56ac5075.png" alt="Cross-functional"></p><p><em>Microservices und Business Capabilities</em>, Abbildung entnommen aus <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="service-als-produkt"><a href="#service-als-produkt" aria-hidden="true" class="header-anchor">#</a> Service als Produkt</h3><p>Software sollte nicht als ein Projekt, sonder vielmals als ein Produkt gesehen werden. Das bedeutet, dass ein Entwicklungsteam während des gesamten Lebenszyklus sich darum kümmert. Auf diese Weise hat dieses Team das Feedback für das Verhalten der Software in realen Arbeitsbedingungen und einen engeren Kontakt zu den Nutzern. Das kreiert eine engere Bindung an das eigene Produkt. Diese Mentalität geht Hand in Hand mit dem Einsatz von Business Capabilities. Eine Software wird nicht mehr als ein Bündel von Funktionalitäten zu betrachten, die fertiggestellt werden müssen, sondern es wird zu der Software eine andauernde Beziehung aufgebaut, um die Business Capability zu verbessern. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p><img src="/book/assets/img/entwicklung_produkt.95dc9914.png" alt="Entwicklung des Produkts"></p><p><em>Betreuung während des Lebenslaufs</em>, eigene Abbildung</p><h3 id="smart-endpoints-and-dumb-pipes"><a href="#smart-endpoints-and-dumb-pipes" aria-hidden="true" class="header-anchor">#</a> Smart endpoints and dumb pipes</h3><p>Die Applikationen der Microservices sollten abgekoppelt und zusammenhängend wie möglich sein: Empfangen einer Anfrage, Bearbeitung und senden einer Antwort. Die Protokolle sollten hingegen unkompliziert sein. Einer der meistgenutzten Protokolle ist HTTP. Das erlaubt die Infrastruktur des Webs zu nutzen, um Ressourcen zu sparen.
Eine andere populäre Möglichkeit ist es den Lightweight Message Bus zu nutzen, wo die Infrastruktur nur als Router von Nachrichten fungiert (dumb pipes). <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="dezentralisierte-fuhrung"><a href="#dezentralisierte-fuhrung" aria-hidden="true" class="header-anchor">#</a> Dezentralisierte Führung</h3><p>Dezentralisierte Führung ist ein Konzept welches aus mehreren Ansätzen besteht. Eines davon erlaubt den einzelnen Entwicklerteams ihre Stärken in verschiedenen Technologien anzuwenden und zusammen ein leistungsfähiges Produkt zu entwickeln, anstatt ihnen einen technologischen Standard aufzuzwingen. Das heißt, dass unter anderem jeder einzelner Service in der dafür am besten passenden Programmiersprache geschrieben werden kann, aber nicht unbedingt muss. Diese Eigenschaft heißt <strong>Polyglot Programming</strong>. Die Entscheidung liegt auf der Ebene der Entwickler, was nicht bedeutet, dass es überhaupt keine Richtlinien gibt.
Einen weiterer Ansatz der dezentralisierten Führung bringt die Amazons Herangehensweise zur Geltung: &quot;You build it, you run it!&quot;. Damit ist gemeint, dass ein Entwicklungsteam nicht nur die eigentliche Entwicklung übernimmt, sondern auch die Installation, die Überwachung und die Steuerung dieses Produktes im Einsatz. Das geht weg von dem üblichen Konzept &quot;Entwickeln und vergessen&quot;, wo nach der Entwicklung andere Bereiche sich um das Produkt kümmern. <a><a href="#ref_Lewi14">[LEWI14]</a></a>, <a><a href="#ref_Peck17">[PECK17]</a></a></p><h3 id="dezentralisiertes-datenmanagement"><a href="#dezentralisiertes-datenmanagement" aria-hidden="true" class="header-anchor">#</a> Dezentralisiertes Datenmanagement</h3><p>Domain-driven Design (DDD) modelliert komplexe Systeme basierend auf Domänen; eine Domäne ist wiederum ein Einsatzbereich einer Software. Bounded Context ist ein Entwurfsmuster aus dem DDD. Es beschreibt eine Abgrenzung in der ein bestimmtes Modell definiert und verwendet wird. Es teilt komplexe Domänen in mehrere Kontextgrenzen und beschreibt die Beziehungen zwischen ihnen. Je nach Kontext variieren sich die Sichtweisen auf bestimmte Modelle: Modell <em>Customer</em> kann im Kontext von <em>Sales</em> vorkommen, aber nicht unbedingt bei <em>Support</em>. Das ist sowohl für Monolithen, als auch für Microservices nutzbar, wobei die letzteren eine natürliche Korrelation zu Bounded Context besitzen. Bounded Context verdeutlicht und verstärkt eine Trennung in verschiedene Kontextbereiche. <a><a href="#ref_Evan15">[EVAN15]</a></a>, <a><a href="#ref_FOWL14">[FOWL14]</a></a>, <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p>Hier sind klar erkennbare Grenzen der Bereiche Sales und Support mit Berührungspunkten bei Customer und Product definiert.</p><p><img src="/book/assets/img/bounded_context.9b03f9f5.png" alt="Bounded Context"></p><p><em>Bounded Context</em>, Abbildung entnommen aus <a><a href="#ref_FOWL14">[FOWL14]</a></a></p><p>Die Dezentralisierung bei Microservices betrifft auch die Datenbanken. Es wird bevorzugt pro Service eine Datenbank zu haben, seien es nur unterschiedliche Datenbank-Instanzen oder komplett unterschiedliche Datenbanktechnologien. Eine der Probleme von dezentralisiertem Datenmanagement ist Update Management. Wenn im monolithischen Systemen Transaktionen für Updates genutzt werden, um Datenkonsistenz zu garantieren, kann es bei Microservices aufgrund von temporären Kupplung problematisch. Verteilte Transaktion sind sehr schwer umzusetzen, weswegen Microservices transaktionslose Koordination zwischen den Services einsetzen. Mögliche Probleme werden von kompensierenden Operationen abgefangen. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p>Die nächste Abbildung vergleicht ein monolithisches System mit Microservices in Bezug auf die Datenbanken.</p><p><img src="/book/assets/img/decentralised_data.206bd341.png" alt="Dezentralisierte Datenbanken"></p><p><em>Dezentralisierte Datenbanken</em>, Abbildung entnommen aus <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="infrastructure-automation"><a href="#infrastructure-automation" aria-hidden="true" class="header-anchor">#</a> Infrastructure Automation</h3><p>Testautomatisierung und Ansätze wie Continuous Integration und Continuous Delivery helfen bei der Entwicklung von stabiler und hochwertiger Software. Das illustriert das nächste Bild. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p><img src="/book/assets/img/basic_pipeline.d882ff52.png" alt="Basic Pipeline"></p><p><em>Basic Pipeline</em>, Abbildung entnommen aus <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="design-for-failure"><a href="#design-for-failure" aria-hidden="true" class="header-anchor">#</a> Design for failure</h3><p>Ein Service ist nicht gegen Ausfälle und Fehler geschützt, deshalb sollte er immer gegen mögliche Fehlerfälle ausgiebig getestet werden. Verglichen mit einem monolithischen Design, fällt das bei Microservices komplexer aus, wodurch die Entwickler ständig beachten müssen wie es auf die Benutzbarkeit beim Nutzer auswirkt. Da allerdings nicht alle möglichen Probleme abgedeckt und vorhergesehen werden können, kommt Echtzeit-Monitoring zum Einsatz. So kann bei einem Ausfall direkt eingegriffen und ein Service wieder zum laufen gebracht werden. Relevanten Metriken und weitere wichtige Informationen über den Softwarestatus erlauben es rechtzeitig Fehler zu erkennen. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><h3 id="evolutionares-design"><a href="#evolutionares-design" aria-hidden="true" class="header-anchor">#</a> Evolutionäres Design</h3><p>Eine Software sollte so entworfen werden, dass statt es bei größeren Änderungen zu verwerfen, diese weiterentwickelt werden kann. Die wichtigsten Eigenschaften eines Komponenten sind Austauschbarkeit und Erweiterungsfähigkeit - wie kann eine Komponente überarbeitet werden, ohne dass andere Komponenten davon betroffen sind. Oftmals wird ein Service verworfen anstatt auf lange Sicht überarbeitet zu werden. Manchmal macht es Sinn mehrere Dienste zu gruppieren, falls diese immer wieder Abhängigkeiten während Änderungen zeigen. <a><a href="#ref_Lewi14">[LEWI14]</a></a></p><p>In dieser Liste sind die Vorraussetzungen für Microservices zusammengefasst: <a><a href="#ref_Nami14">[NAMI14]</a></a></p><ol><li>Request/Response calls mit willkürlich strukturierten Daten</li><li>Asynchrone Events in Echtzeit</li><li>Bidirektionale Requests und Responses</li><li>Requests und Responses können willkürlich geschachtelt sein</li><li>Nachrichtenformat: wie JSON, XML</li></ol><h3 id="client-kommunikation-mit-microservices"><a href="#client-kommunikation-mit-microservices" aria-hidden="true" class="header-anchor">#</a> Client-Kommunikation mit Microservices</h3><p><strong>Direct Client-to-Microservice Communication</strong></p><p>Jeder Microservice hat einen öffentliches Endpunkt. Um Information zu bekommen schickt ein Client Anfragen an jedes einzelne Service. Nachteile sind die vielen Anfragen, welche ein Client ausführen muss. Bei hunderten Diensten wäre es zu ineffizient die Anfragen über das öffentliche Internet zu verschicken. Mit einigen Protokollen ist es nicht performant über das Internet zu kommunizieren und außerhalb der Firewall sollte HTTP zum Einsatz kommen. Direct Calls machen es schwer die Microservices im Nachhinein zu restrukturieren, denn es kann vorkommen, dass zwei Dienste zusammengeführt werden sollen, aber der Client sie beide einzeln anspricht. Diese Ansatz wird aus diesen Gründen eher selten verwendet. <a><a href="#ref_Rich15">[RICH15]</a></a></p><p><img src="data:image/png;base64,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" alt="Direct Call"></p><p><em>Direct Call</em>, Abbildung angepasst aus <a><a href="#ref_Nami14">[NAMI14]</a></a></p><p><strong>API Gateway</strong></p><p>Ein API Gateway ist ein Server mit einem Endpunkt für alle Anfragen des Clients. Je nach Client werden verschiedene APIs zur Verfügung gestellt. Zu den Aufgaben zählen unter anderem:</p><ul><li>Authentifizierung</li><li>Monitoring</li><li>Load Balancing</li><li>Caching</li><li>Anfragen-Management</li><li>Protokoll-Umwandlung</li><li>Anfragen-Routing</li></ul><p>Ein API-Gateway leitet alle Anfragen zu den Microservices; es kann mehrere Dienste aufrufen und deren Ergebnisse sammeln; es führt Umwandlungen durch zwischen Webprotokollen und internen Dienst-Protokollen. <a><a href="#ref_Rich15">[RICH15]</a></a></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZEAAADTCAYAAABAxi6EAAAWs0lEQVR4nO3dv27qSBvHcfeELkIRdXpfwp5y0wbqdbddqigiJJH2vQFi5FxBihS5gUO5ex0EQYUQSgfpn7cAE9v4H8EztofvR0I6JyS2Gcbzw/NMYksAwHDz+Vzu7+/l+vpaGo2GWJbFI+fj7OxMOp2O9Pt9WSwWe21rlfB+AoA2g8FA2u22eJ4n0+lUvr6+yj6kWlmv1zKZTMTzPLm4uJDhcBh6nhABYKzX11fp9/tlH4ZR7u7u5O3tbfd/QgSAkQaDAQGiSK/X212RECIAjDOfz6Xdbpd9GEZrtVqyXC4JEQDm6fV64nle2YdhNNd15fHxkRABYJ7r62uZTqdlH4bRxuOxdLtdQgSAeRqNBquwFFutVtJsNgkRAOaxLIY2HSzLIkQAmIcQ0YMQAWAkQkQPQgSAkQgRPQgRAEYiRPQgRAAYiRDRgxABYCRCRA9CBICRCBE9CBEARiJE9CBEABiJENGDEAFgJEJED0IEgJGKDJGRE7llrDMqbNsxexPHssWdKdyFzMS1LSniZcSGCPciVncvYgB6FBUiIycaGpsBWG2QqLQ9fktRiHAv4uNk3YsYgB7FhEjCVcHIEcty5HsM/h6YLcsSy3ZlFnrOFtd1ts/b8ndnP4S+wyqyz5krdux2s/a7b+ba2+9zxFFxJcK9iIsXvRcxAD2KCZE8Vx2b77EDSTNz7cCAvt1GcIDfC6GROLsrg2CIBL8e3U/WfmOO1HW3+1QwncW9iNUJ3osYgB7F1UQ2A3nip/29QBAJD9L7g304HKLbCIRI7Lbz7jdNwSHCvYjV8+9FDEAPNauzAoGyHYF3U0Qxj01wxA/YwVpLuO7yHSJpVxbZ+01TcIhwL2L1/HsRA9BD6RLfmSt2joF++83xA/buSiJyVXJIiGTUQFJeQLEhwr2I1fPvRQxAvV+/fhUTIonTSYGBP23KSUSSB+ztNlxX7L36yE+ns/IqOES4F7F6/r2IAaj1v//9T/75559iC+uRT/ybqSR/AE8qnPvF8eQBezclFXoyqbC+/f7d92btN/t1FRYi/GanHrQzoNZ///0nf/zxh4go/mXDrKW2oYE8ZcDeLt8NP5eyxDehkB6/3zSESC3RzoBawXOM800PQkQj2hlQ59evX/Lvv//u/s/5pgchohHtDKjh10GCON/0IEQ0op2B4gXrIEGcb3oQIhrRzkDxks4rzjc9CBGNaGegWNE6SBDnmx6EiEa0M1CcuDpIEOebHoSIRrQzUIykOkgQ55sehIhGtDNQjDznEuebHoSIRrQzcLy0OkgQ55selQ0R/2/K1PYOlDGq2M5AnWTVQYI43/SoaIhs/uiYbR/zp46rp3rtDNRHnjpIEOebHtUMEf9PHAf+Zn/gyc0fJxsl/VGyrOfLU7l2Bmrk0POH802PSobIyAnfESzutpLBYAj/Weas58tTtXYG6iJvHSSI802P6oVI5OpjPwCidwGLfi3r+fJUqp2BmjikDhJ0dnYm6/W6+APCjn+fpEqFyP4tH5NvHRn4qcAVS9bz5alSOwN1cGgdJKjT6chkMin2gBDi37G1QiHiT0XFPHbBUu8Q+fj4KPUYgDo5Zmzq9/vieV6BR4Mo13Xl6empQiGSdM/g0C0f6z2ddXl5Kb9//y73QIAa+EkdJGixWMjFxUVxB4Q95+fn8vn5WZ0QGTnRew37olca4cL5yIleqaQ9Xx6/na+urviEBKT4aR0kynVdubu7O/6AsOf29lZeXl5ERCoSIrHLeYNP+wX27VWF4yTc7zjr+fIE2/nm5kZubm5KPBqgmo6pg8R5e3uTXq9X2PawCZD39/fd/6sRIrllTU1VY+oqTrSdPc+Tq6urko4GqCYV49FwOJRWqyXPz88yHo9ltVoVvg+TrVYrGY/H4rqunJ+f765AfISIJnHt/Pv3b7m8vCzhaIDqObYOkma5XMrDw4N0u11/WSqPnI9msyndbleenp7k8/Nzr20JEU2S2vnj44OVWzh5RdVBoF/NQqS+stqZlVs4VUXXQaAXIaJJnnZm5RZOEWNQvREimuRtZ1Zu4ZSorINAD0JEk0PamZVbOAXUQcxAiGhyaDuzcgsmow5iDkJEk5+0Myu3YCrGHXMQIpoc086s3IJJqIOYhRDR5Nh2ZuUWTEAdxDyEiCZFtDMrt1Bn1EHMRIhoUlQ7s3ILdcVYYyZCRJMi25mVW6gb6iDmsrgXsXr+vYiLxMot1AV1ELNZ3ItYPf9exCqwcgtVRh3EfBb3IlbPvxexKqzcQlUxXW4+i3sRq+ffi1glVm6haqiDnAZLhHsRqxS8F7FqrNxCVVAHOR27a03uRVy86L2IdWDlFspGHeS0hCYsuRfxcbLuRawLK7dQJuogp2Xv3eZexOruRawbK7egG3WQ08NHBsOxcgu6UAc5TYTICWDlFlSjDnK6CJETwcotqEQd5HTxzp8QVm5BBeogp40QOTGs3EKRqIOAEDlRrNzCsaiDQIQQOWms3MIxqINAhBA5eazcwk9QB4GPEAErt3AQ6iAIIkQgItVZuTWfz+X+/l6ur6+l0WiU/lcI6vQ4OzuTTqcj/X5fFouFkvenrnUQ+pW6fkWIYKfslVuDwUDa7bZ4nifT6VS+vr5KOY66Wq/XMplMxPM8ubi4kOFwWPg+LKt+Qwb96jhZ/ap+PQLKlbFy6/X1Vfr9vtZ9mu7u7k7e3t4K214d6yD0q+JF+xUhglg6V24NBgNOdEV6vV4hVyR1rIPQr9QJ9itCBIl0rNyaz+fSbreV7uPUtVotWS6XP/75OtZB6Ffq+f2KEEEq1Su3er0ev6uimOu68vj4+OOfr2MdhH6lnt+v6tc7oJ3KlVvX19cynU6VbBsb4/FYut3uj362jnUQEfqVDn6/IkSQi6qVW41Gg9Uyiq1WK2k2mwf/XB3rID76lXp+vyJEcJCiV27Vcaqkjg5t5zrWQYLoV3pYlkWI4HBFrtziZNfj0Hau+/tS9+OvC0IEP1bUyi1Odj0Oaee61kGC6Fd6ECI4iud58ueffx61DU52PfK2c53rIEH0Kz0IERxtNBodtXKLk12PPO1c9zpIEP1KD0IEhThm5RYnux552tmk98Kk11JlhAgK9ZOVW5zsemS1swl1kCD6lR6ECAp36MotTnY90trZlDpIEP1KD0IEShyycouTXY+kdjapDhJEv9KDEIEyeVducbLrkdTOpra/qa+raggRKJVn5VbVT/bZbFb2IRQirp1Nq4MEVb1fmYIQgXJZK7dUnewjJ3qbT1vc2SFbmIlrW2If9kOVFW1nE+sgQUX2q72+5IwK23bM3sQ5uK8esu3ga3Hk2FdCiECbpJVbxYfI9kSJnugjRyzLkvznv7khYmodJKiofjVyon1p0y/UBokKm/Mi2J9nrn10kBAi0Cpu5VbRIbJ/0n+bubZYtiuz7y+IbYU/ZW5+dDtQ7H3yjHx9t63N17+/bbNd//+h/SbuM/7YZ65dyIAVbOdTmOop5jUmXBWMnMjgm9Qv/OdscV1nd0X8d2f/ff5+7yP7DPaX0Haz9pt1zCmv7wCECLSLrtwqdkA75KTYfDILnsubaQv/RIteiexfmQTDITTYjxyxbXv3vSPH/7mMfSYMTkV86PXb2eQ6SFAx/SrPVUd6v9htIzjA773PwX4R7MPBrx/WH/O9PFdsQgR1FFy5VWiIzFyxj7k8D53ckZM09pNcYJAfOaFAcRxnO/hkBEFou5GQOfb1BFiWZXwdJKi4fhWpI0QH6ax+ETstGnmf9/rAdmCP3Xbe/WYpZlqOEEFp/JVbykNkb/oo+skrqdgYPvk388fRYv3m8X2VsfnZkWOLO3LFtl2ZBb6evc/wlFZRU1kim5Pd9DpIkJopu8D7FnyPUvtF/MAefJ/D05jfIZJ2ZZG93zTF1XUIEZTm4+ND/vrrL73TWaHL9+8BIf5qIyZEUqcKtnPfs5m4tiMjPzxmfpjk2acEgrC4qSwRSRxwTH4oE+hH+fpFzPu4e9+jU5wHhMghU1ehYy9uwQghAu1Go5FcXV3J5eWleJ5X+MmeVlgPhUhg+inwwwdOZ0U3b4vj+qHxXVANbSNzOmQ76LjFTWWJcCXyI4nveWDgz+wXSR8GttvYe5+Pmc7K83qKXT5MiEAbz/Pk8vJS/vzzz9BS3+I/MW4/7UcH6920VsIJGn0+oZC5XyANnJTbZcTfBXVbbDtp7jtun/6X7dCUSRGoifxEzHsu0aWxWf0i+Yoy/n1OKqxHpzdz9Mfwzo4uoschRKDUx8eH3NzciGVZcnNzE/sLh6qmHeLmjGPnpUN1iZiTNnSSR5ZUJtRXwj8f/rSYtc/tD4aWCBeB1Vk/t/fLhllLbUP9ImVaMvZ9Tlnim1BIT+6PwV0l11CO6WeECJSITlmlUTp3XVcFrsryBdv5FNr8FF5jFcSGyHw+l/v7e7m+vpZGo1F6caxOj7OzM+l0OtLv92WxWJTxnpYqacoqDSf7vplrF/6b8sF25jfWUZS9EBkMBtJut8XzPJlOp/L19VXWsdXSer2WyWQinufJxcWFDIfDsg9JuTxTVmk42QP8qYufrLrJEG1n0+sj9Cs9QiHy+voq/X6/zOMxzt3dnby9vZV9GEocMmWVhpNdj7h2Nrk+Qr/SYxcig8GAAFGk1+sZdUXykymrNJzseiS1s6ntb+rrqhrLssSaz+fSbrfLPhajtVotWS6XZR/Gjx07ZZWGk12PpHY2tT5Cv9LDsiyxer3eUdMRyOa6rjw+PpZ9GAcrasoqDSe7HmntbGJ9hH6lh2VZYl1fX8t0Oi37WIw2Ho+l2+2WfRi5FT1llYaTXY+sdjatPkK/0sOyLLEajQarsBRbrVbSbDbLPoxUKqes0nCy65GnnU16L0x6LVW2/fUGGluHqrbz79+/lU9Zpalqu5gmTzubVB+hX+lBiGhUtXb2p6yurq6UT1mlqVq7mCpvO5tSH6Ff6UGIaFSFdi5ryipNFdrlFBzSzibUR+hXehAiGpXZzmVPWaWh/+lxaDvX/X2p+/HXBSGiURntXJUpqzT0Pz0Obee610foV3oQIhrpaucqTlmlOTs7k/V6XfZhGO2nqwPrXB+hX6nn9ytCRBPV7VzlKas0nU5HJpNJ2YdhtGN+T6mu9RH6lXp+vyJENFHVznWYskrT7/drFXp15LquPD09/fjn6zhG0K/U8/sVIaJJke1ctymrNIvFQi4uLso+DKOdn5/L5+fnj3++jvUR+pV6fr8iRDQpop3rOmWVxXVdubu7K/swjHR7eysvLy9Hb6eO9RH6lTrBfkWIaHJMO9d9yiqPt7c36fV6ZR+GUW5vb+X9/b2w7dWxPkK/Kl60X1UyRPybyh9zA/mqObSdTZqyyms4HEqr1ZLn52cZj8eyWq3KPqRaWa1WMh6PxXVdOT8/L+QKJKqK40UW+tVxsvpVBUNkJI5liW3bSm4TWpa87WzqlFVey+VSHh4epNvt+ssHeeR8NJtN6Xa78vT0dFQNJE0d6yMi9CuV/cqyrIqFyMgRy3JkNHPFtmxxZ6EnxbFscUfbe1Fb1uZ7cz9fnqx2PoUpK5ihjvURqFO5EBk5ltjuTERm4tr+v3fPihMJhs3Ul///rOfLE9fOpzhlBTPUsT4CNaoVIpGrj/0A2IREuFYS/FrW8+UJtvOpT1nBDJUaO1CaSoXIzI3WQaIBsJ2umoV+KnDFkvV8eSzLYsoKRqlrfQTFqlCI+FNRMY9dsNQ7RJiygmmoj6A6IeIX1GO/7geDGdNZgEmoj5y2yoTIyLHEih3po1ca4cL5yIleqaQ9X56qtDOgAv37dFUjRGKX8waf9gvs26sKx4mZ6hKRzOfLU4l2BhShPnK6qhEiuWVNTVVj6ipOvdoZOBz1kdNEiGhSr3YGfob6yOkhRDSpVzsDP0dfPy01C5H6op1xKqiPnBZCRBPaGaeE+sjpIEQ0oZ1xaqiPnAZCRBPaGaeIfm8+QkQT2hmniPqI+QgRTWhnnCrqI2YjRDShnXHKqI+YixDRhHbGqeMcMBMhogntjFNHfcRMhIgmtDNAfcREhIgmtDOwQX3ELNbZ2Zms1+uyj8Noq9VKms1m2YcBVAYfqsxhdTodmUwmZR+H0cbjsXS73bIPA6gM6iPmsPr9vnieV/ZxGM11XXl6eir7MIBKoT5iBmuxWMjFxUXZx2G08/Nz+fz8LPswgMqhPlJ/lsjmk/Ld3V3Zx2Kk29tbeXl5KfswgMqiPlJvu3fv7e1Ner1emcdinNvbW3l/fy/7MIBKoz5Sb6GPAMPhUFqtljw/P8t4PJbValXWcdXSarWS8XgsruvK+fk5VyBATtRH6mvvOnK5XMrDw4N0u11pNptiWRaPnI9msyndbleenp6ogQAHUlkfmc/ncn9/L9fX19JoNEofK+r0ODs7k06nI/1+XxaLxV7bMhkJoDIsq/ghaTAYSLvdFs/zZDqdytfXV+H7MNl6vZbJZCKe58nFxYUMh8PQ84QIgMoouj7y+voq/X6/sO1B5O7uTt7e3nb/J0QAVEpR9ZHBYECAKNLr9XZXJIQIgMo5tj4yn8+l3W4Xd0DY02q1ZLlcEiIAqumY+kiv1+MvcSjmuq48Pj4SIgCq6Zj6yPX1tUyn02IPCCH+3wQkRABU1k/rI41Gg1VYivl/nZwQAVBpP6mPqFgqjH2WZREiAKrv0FAgRPQgRADUwqH1EUJED0IEQG0cUh8hRPQgRADUSt76CCGiByECoHbyBAQhogchAqB28tRHCBE9CBEAtZRVHyFE9CBEANRWWn2EENGDEAFQa0lhQYjoQYgAqLWk+gghogchAqD24uojRYbIyIncMtYZFbbtmL2JY9nizlRseyauXezrIEQAGCFaHykqREZOdLDdDsRKg0SN8GvZvA77yLQiRAAYIxgcxYRIwlXByBHLcuQ7RiKf8G1XZqHnbHFdZ/u8LX939kPoe4CP7HPmih273az9RsxcsSOvZeba6T+TAyECwBjB+kgxIZLnqmP/E314cN5uIzhY74XQSBzLks1ugiES/Hp0P1n7zffauBIBgAC/PlJcTWQzkCd+2t8LBBF/gI4f/L+3ucum0DYCIRK77bz7TRK4ejnyKkSEEAFgoF+/filanRUIlO1IPXPtcNE98NgER/zAHqxPhGsV3yGSdmWRvd88LyclpHIiRAAYSekS30B9IXsKKeHqYDeAR65KDgmRo68k8ly5pCNEABipkBBJ/KQeGPgzP80nDdTbbbiu2Hv1kZ9OZx36WqIBdjhCBICRCi2sRz7xb6aS/AE5qXDuF8eTP+3vpqRCTyYV1rffH1mim7zf+NcS3pXD6iwAiKP0lw2zltqGBvKUKaPt8t3wcylLfBMK6fH7jXPAkuCcCBEARuLPnuhBiAAwEiGiByECwEiEiB6ECAAjESJ6ECIAjESI6EGIADASIaIHIQLASISIHoQIACMRInoQIgCMRIjoQYgAMBIhogchAsBIhIgehAgAIxEiehAiAIxEiOhBiAAwEiGiByECwEhnZ2eyXq/LPgyjrVYraTabhAgA83Q6HZlMJmUfhtHG47F0u11CBIB5+v2+eJ5X9mEYzXVdeXp6IkQAmGexWMjFxUXZh2G08/Nz+fz8JEQAmMl1Xbm7uyv7MIx0e3srLy8vIiKECABzvb29Sa/XK/swjHJ7eyvv7++7/xMiAIw2HA6l1WrJ8/OzjMdjWa1WZR9SraxWKxmPx+K6rpyfn++uQHyECADjLZdLeXh4kG63u1mWalk8cj6azaZ0u115enqSz8/Pvbb9P12kYBOUoLbGAAAAAElFTkSuQmCC" alt="API Gateway"></p><p><em>API Gateway</em>, Abbildung angepasst aus <a><a href="#ref_Nami14">[NAMI14]</a></a></p><h3 id="humane-registries"><a href="#humane-registries" aria-hidden="true" class="header-anchor">#</a> Humane Registries</h3><p>Humane Registry ist eine automatisierte Dokumentation für Microservices, designt um Informationen automatisch in menschlich lesbaren Form zu schreiben und zu aktualisieren. Die wichtigesten Merkmale so einer Dokumentation sind:</p><ul><li><em>Verständlichkeit</em>: der Format sollte für alle lesbar und verständlich sein</li><li><em>Automation</em>: Entwickler haben selten Zeit eine Dokumentation zu pflegen</li><li><em>Einfachheit</em>: eine Erweiterung der Informationen sollte unkompliziert sein</li></ul><p>Solch ein Dokumentationswerkzeug durchsucht den Quellcode des Systems und stellt detaillierte Informationen darüber bereit, welcher entwickler wann und wieviel zum Microservices beigetragen hat. So können Mitarbeiter sehen an wem sie sich in bestimmten Fällen wenden können. Mithilfe von Daten aus verschiedensten Systemen, wie Continuous-Integration-Servern, von Versionsverwaltungsprogrammen und Issue-Tracking-Systemen, wird eine übergreifende Dokumentation erschaffen. <a><a href="#ref_Fowl08">[FOWL08]</a></a></p><h3 id="serverless"><a href="#serverless" aria-hidden="true" class="header-anchor">#</a> Serverless</h3><p>Serverless steht für Serverless computing und wird in zwei Bereichen eingesetzt:</p><ol><li>Es wird komplett auf die serverseitige Logik verzichtet und stattdessen werden Cloud-Services von Drittanbietern integriert. Übliche Anwender sind sogenannte &quot;Rich Clients&quot; - Single-Page-Webanwendungen und mobile Apps. Zu solchen Cloud-Services zählen Datenbanken, Authentifizierungsmechanismen und so weiter. Weshalb dieser Typ von Microservices auch &quot;Backend as a Service&quot; genannt wird.</li><li>Ein anderer Bereich von Serverless ist &quot;Function as a Service&quot; (FaaS). In diesem Szenario wird serverseitige Logik immer noch vom Entwickler geschrieben, jedoch verpackt in Container und von einer Cloud gemanagt. Diese Container sind zustandslos, ereignisgesteuert und kurzlebig. Der bekannteste Beispiel ist AWS Lambda von Amazon.</li></ol><p>Die folgende Abbildung zeigt die Unterschiede zwischen der üblichen Architektur und Serverless. Die Authentifizierung erfolgt über den Cloud-Service. Der Client hat Zugriff auf die Produkt-Datenbank, welche von Drittanbietern gehostet wird. Ein Teil der früheren Serverlogik der alten Architektur kann in den Client implementiert werden, siehe Single-Page-Webanwendung. Mit HTTP-Anfragen kann über die API eine Suche in der Datenbank getriggert werden - es ist nicht nötig, dass ständig ein Server am laufen sein muss. Es ist möglich Teile von eigenem Quellcode in Plattformen wie AWS Lambda zu verwenden, falls die Programmiersprache unterstützt wird. Die Funktionalität &quot;Kaufen&quot; kann ebenfalls durch &quot;Function as a Service&quot; ersetzt werden. Zum einen, um den Client leichtgewichtiger zu halten, zum anderen aus Sicherheit. <a><a href="#ref_Robe18">[ROBE18]</a></a></p><p><img src="/book/assets/img/serverless.de5808ac.png" alt="Serverless"></p><p><em>Serverless</em>, Abbildung angepasst aus <a><a href="#ref_Robe18">[ROBE18]</a></a></p><p>Vereinfacht ausgedrückt - FaaS ist eine Ausführung von Backend-Quellcode ohne dabei einen eigenen Server oder dauerhaft arbeitende Serverprogramme laufen zu haben. FaaS ist darauf ausgelegt innerhalb kürzester Zeit (Millisekunden) je nach Anfrage benötigte Anwendungen zu starten und zu beenden. Die Vorteile sind eine Vereinfachung der Architektur durch den Wegfall einer Schicht und Übergabe der serverseitigen Logik an die Cloud-Services. Die Einsparung von Entwicklungs-, Installations- und Instandhaltungsaufwänden zählt ebenfalls zu den Vorteilen gegenüber der üblichen Drei-Schichten-Architektur. <a><a href="#ref_Robe18">[ROBE18]</a></a></p><h2 id="unterschiede-zu-monolithischen-anwendungen"><a href="#unterschiede-zu-monolithischen-anwendungen" aria-hidden="true" class="header-anchor">#</a> Unterschiede zu monolithischen Anwendungen</h2><p>Die folgenden Kapiteln gehen auf die Vor- und Nachteile von Microservices gegenüber einer monolithischen Architektur. Die Nachteile eines Monoliths wurden in der Einführung beschrieben.</p><h3 id="vorteile"><a href="#vorteile" aria-hidden="true" class="header-anchor">#</a> Vorteile</h3><p>Der offensichtlichste Vorteil welchen Microservices mit sich bringen ist eine bessere Übersicht von Quellcode. Jeder Service ist sauber logisch und technisch von anderen getrennt, was es viel einfacher macht neue Entwickler reinzubringen. Wenn ein Microservice modifiziert werden soll, muss nicht die gesamte Architektur deswegen verändert werden, weil es keine Abhängigkeiten zu anderen Microservices gibt. Dies favorisiert eine kontinuierliche Entwicklung, weil von vorne rein viel weniger Raum für Querabhängigkeiten im Quellcode entsteht. Daraus resultiert eine erhöhte Einsatzfähigkeit, kürzere Entwicklungszeiten und bessere Umsetzung von innovativen Lösungen - Continuous Integration und Continuous Delivery. Microservices haben eine höhere Resistenz gegenüber Fehlern, da aufgrund ihrer Größe der Quellcode übersichtlicher ist und die Kommunikation mit anderen Microservices über klar definierte Schnittstellen erfolgt. Daraus resultiert ein weiterer Vorteil: Unabhängigkeit in der Entwicklung. Jeder Dienst wird autonom von einem Team entwickelt. Laut Amazon sollte ein Teams maximal so groß sein, dass es von zwei Pizza satt wird, also nicht mehr als ein Dutzend Entwickler.Es gibt ebenfalls eine Regel der halben Pizza, wovon ein zwei Mann Team satt wird. Die optimale Größe von Microservice Entwicklerteams variiert also zwischen zwei bis zwölf Mitgliedern.<br>
Microservices vereinfach das schreiben von Tests aufgrund ihrer Granularität und Unabhängigkeit, was auch zur besseren Fehlereingrenzung führt. Jedes einzelnes Microservice kann in komplett anderer Programmiersprache geschrieben sein und sich technologisch komplett unterscheiden. So kann ein Service flexibel auf die kommenden Forderungen reagieren und sich mit der zeit anpassen, was zu einem langlebigen Programm führt. Allerdings hat es sich herausgestellt, dass Microservices eher verworfen und neu realisiert werden, anstatt sich auf lange Sicht darum zu kümmern. Im Gegensatz dazu kann eine monolithische Architektur zwar mehrere Dienste oder Komponenten enthalten - sie bilden aber trotzdem ein Ganzes und haben eine Programmiersprache. Bei einem Ausfall, können andere Microservices weiterarbeiten und ihren Beitrag zur Funktionalität der Applikation leisten. Ein immenser Vorteil eines Microservice ist die Möglichkeit in anderen Systemen wiederzuverwenden, solange die Schnittstelle richtig konfiguriert ist. <a><a href="#ref_Lewi14">[LEWI14]</a></a>, <a><a href="#ref_Nami14">[NAMI14]</a></a>, <a><a href="#ref_Rich17">[RICH17]</a></a></p><h3 id="nachteile"><a href="#nachteile" aria-hidden="true" class="header-anchor">#</a> Nachteile</h3><p>Die Kommunikation zwischen den Microservices und der Applikation geschieht nur über die Schnittstellen, was zu einer großen Menge an Remote Calls führt. Remote Calls verbrauchen mehr Ressourcen als In-Prozess Calls einer monolithischen Struktur. Ein weiterer großer Nachteil ist, dass Microservices zuerst partitioniert werden müssen. Am Anfang eines Systems ist nicht unbedingt offensichtlich wie es in Zukunft aussehen wird und der Aufwand einer Microservice-Architektur ist kann zu immens erscheinen. Jedes Service braucht einen klar definierten Anwendungsfall und muss frei von unnützen Funktionalitäten sein. Das kann wie im Falle von Amazon zu hunderten Microservices führen und dementsprechend dutzende  Teams. Kommunikation zwischen diesen Entwicklerteams ist von entscheidender Bedeutung, denn Anwendungsfälle können sich über mehrere Services spannen. Monolithische Systeme können ebenfalls in einzelne Dienste aufgebrochen werden. Je größer eine Applikation ist, desto komplizierter ist die Umstrukturierung, denn zuerst müssen alle internen Abhängigkeiten aufgelöst werden. Microservices beanspruchen mehr Ressourcen, weil die Menge an monolithische Instanzen N ersetzt wird durch die Menge an Microservice-Instanzen N x M. Beim Einsatz von JVM oder deren Äquivalenten für die Isolierung einzelner Microservices steigt der Overhead ins M-fache der eingesetzten JVM-Runtimes.<br>
Obwohl die kompakte Größe eines Miroservice das Schreiben von Testfällen erleichtert, wird durch die Komplexität der gesamten Architektur das Testen insofern schwieriger, dass die Zusammenarbeit mit anderen verteilten Diensten überprüft werden muss. Dezentralisierte Datenverteilung ist ein weiterer wichtiger Punkt. In dieser Architektur ist es üblich eine Datenbanklösung pro Service zu haben, wodurch Probleme mit der Datenkonsistenz auftretten können. Die Komplexität die verteilten Systeme zu managen und einzusetzen ist entsprechend höher als mit Monoliths, weil sie in komplett anderen Technologien und Sprachen umgesetzt sein können. <a><a href="#ref_Lewi14">[LEWI14]</a></a>, <a><a href="#ref_Nami14">[NAMI14]</a></a>, <a><a href="#ref_Rich17">[RICH17]</a></a></p><p>Die nächststehende Tabelle führt die Vor- und Nachteile kurz nochmal zusammen.</p><table><thead><tr><th><strong>Vorteile</strong></th><th><strong>Nachteile</strong></th></tr></thead><tbody><tr><td>Kompakter Quellcode</td><td>Größerer Ressourcenbedarf</td></tr><tr><td>Leichterer Einstieg ins Team</td><td>Use Cases nicht eindeutig</td></tr><tr><td>Erhöhte Einsatzfähigkeit</td><td>Sehr komplex</td></tr><tr><td>Kürzere Entwicklungszeiten</td><td>Überhang an Services möglich</td></tr><tr><td>Autonome Services</td><td>Testsfälle werden komplexer</td></tr><tr><td>Kleine dedizierte Teams</td><td>Abhängig von Schnittstellen</td></tr><tr><td>Resistent gegen Ausfall</td><td>Probleme mit Datenkonsistenz</td></tr><tr><td>Business Case abhängig</td><td>Aufwändig zu managen</td></tr><tr><td>Technologie unabhängig</td><td>Großer Kommunikationsaufwand pro Team</td></tr><tr><td>Wiederverwendbare Services</td><td></td></tr></tbody></table><p>Die Microservice-Architektur ist vorteilhaft, wenn die Rede um eine flexible und dennoch robuste Software geht.</p><h2 id="abgrenzung-zu-self-contained-systems"><a href="#abgrenzung-zu-self-contained-systems" aria-hidden="true" class="header-anchor">#</a> Abgrenzung zu Self-Contained Systems</h2><p>Self-contained Systems (SCS) ist ein Architekturmuster, der den Fokus auf Separation einer Funktionalität in mehrere unabhängige Systeme legt. Aus der Kollaboration dieser Systeme entsteht ein neues logisches System. So werden Probleme von großen monolithischen Systemen umgangen, da sie ständig wachsen und nicht mehr wartbar werden.<br>
Sie sind den Microservices sehr ähnlich und teilen mit ihnen viele Merkmale. Zu diesen Merkmalen gehören unabhängige Einheiten, Anpassung von organisatorischen und architektonischen Grenzen, Diversität in technologischen Auswahl und dezentralisierte Infrastruktur. Dennoch gibt es einige Unterschiede:</p><ul><li>Ein Microservice ist üblicherweise kleiner als ein SCS</li><li>Es gibt normalerweise weniger SCSs als Microservices, ein Shop kann 5-25 SCSs haben oder bis zu 100 Microservices</li><li>SCSs sollten nicht miteinander kommunizieren, was für Microservices bis zu einem gewissen Grad in Ordnung ist</li><li>SCSs besitzen eine UI, während Microservices die UI üblicherweise (nicht immer) in eigenes Service auslagern</li><li>Microservices werden normalerweise auf der Logikschicht integriert und SCSs auf der UI-Schicht</li></ul><p>Es ist möglich Self-contained Systems weiter in die Microservices aufzuteilen. SCS fokussiert sich auf großen Projekten und Aufteilungen in mehrere Teams. Bei Microservices sind eher kleine Teams oder einzelne Entwickler im Einsatz, was erlaubt Continuous Delivery einfacher anzuwenden, robustere Systeme zu entwerfen oder einzelne Services zu skalieren. Microservices sind vielseitiger, aber Self-contained Systems lösen Probleme mit der Architektur und Organisation großer Projekte.
<a><a href="#ref_Scsvsm">[SCSVSM]</a></a></p><h2 id="microservices-als-front-ends"><a href="#microservices-als-front-ends" aria-hidden="true" class="header-anchor">#</a> Microservices als Front-Ends</h2><p>Für Webanwendungen gewinnt Front-End immer mehr an Bedeutung, während Back-End weniger wichtig wird. Der Trend geht in Richtung einer 90 zu 10 Aufteilung zu Gunsten von Front-End. Der monolithische Design ist für Front-End zu schwerfällig, so dass eine Aufteilung in kleinere Module nötig ist. Der aktuelle Trend heißt &quot;Micro Front-Ends&quot; und Unternehmen, wie Spotify und Zalando sind schon umgestiegen. Das sind einige der Umsetzungsmöglichkeiten:</p><ol><li>Eine Kombination aus mehreren Frameworks auf einer Webseite ohne das die Webseite aktualisiert werden muss.</li><li>Mehrere Singe-Page-Applikationen, die über verschiedene URLs zugänglich sind. Diese Applikationen nutzen Paketverwaltung für geteilte Funktionalität.</li><li>Micro-Apps in IFrames verpacken und über APIs koordinieren.</li><li>Verschiedene Module können über einen gemeinsamen Event-Bus kommunizieren. Jedes Modul benutzt sein eigenes Framework und handelt nur eingehende und ausgehende Events.</li><li>Mithilfe von einem Web-Beschleuniger verschiedene Module zu integrieren.</li><li>Webkomponenten als eine Integrationsschicht zu verwenden. Sie erlauben wiederverwendbare Komponenten in Webanwendungen und Webdokumenten zu erstellen.</li><li>React-Komponenten in einer Blackbox zu isolieren. Hier wird der Zustand einer Applikation im Komponenten festgehalten und über die API werden nur die Eigenschaften zugänglich gemacht. <a><a href="#ref_S%C3%B6de17">[SÖDE17]</a></a></li></ol><table><thead><tr><th><strong>Vorteile</strong></th><th><strong>Nachteile</strong></th></tr></thead><tbody><tr><td>Unabhängig</td><td>Erhöhter Betriebsaufwand</td></tr><tr><td>Einfacher einzusetzen</td><td>Erhöhte Komplexität (z.B. Infrastruktur, Kommunikation)</td></tr><tr><td>Hohe Testbarkeit</td><td>Schlechtere Performance</td></tr><tr><td>Unabhängige Technologiestacks</td><td>Restrukturierung kann sehr komplex werden</td></tr><tr><td>Unabhängig im Fehlerfall</td><td></td></tr><tr><td>Parallele entwicklung möglich</td><td></td></tr></tbody></table><p>Tabelle angepasst aus <a><a href="#ref_Lech17">[LECH17]</a></a></p><p>Diese Abbildung stellt Front-Ends in verschiedenen Architekturen dar. In jeder bildet das Front-End ein ganzes System; entweder für sich alleine oder als ein Monolith mit Back-End und Datenbank.</p><p><img src="/book/assets/img/monolith_frontback_microservices.fa8eabe6.png" alt="Monolithische Front-End"></p><p><em>Monolithische Front-Ends</em>, Abbildung entnommen aus <a><a href="#ref_Geer17">[GEER17]</a></a></p><p>In dieser Abbildung ist eine mögliche Aufteilung eines monolithischen Front-End in Micro Front-Ends in vertikaler Ebene dargeboten. Wie auch im Microservices Back-End Bereich ist hier jedes Team für einen Dienst zuständig: Product, Checkout, etc. Links in der Abbildung sind die drei Schichten zu sehen:</p><ul><li>Front-End</li><li>Back-End</li><li>Datenbank</li></ul><p>Jedes Entwicklerteam behandelt alle drei Bereiche seines Services. Das korreliert auch mit &quot;klassischen&quot; Microservices in dem Sinne, dass <strong>Polyglot Persistence</strong> eingesetzt wird - eine Datenbank pro Service.</p><p><img src="/book/assets/img/micro_frontend.a1c97098.png" alt="Micro Front-Ends"></p><p><em>Micro Front-Ends</em>, Abbildung entnommen aus <a><a href="#ref_Geer17">[GEER17]</a></a></p><h2 id="einsatz-von-microservices"><a href="#einsatz-von-microservices" aria-hidden="true" class="header-anchor">#</a> Einsatz von Microservices</h2><p>Es ist schwierig zu entscheiden in welchen Fällen Microservices eingesetzt werden sollten, denn viele Probleme mit monolithischer Architektur tauchen erst mittelfristig auf und keiner möchte die zusätzliche Komplexität am Anfang eines Projekts auf sich nehmen. Die Entwicklung einer verteilten Architektur ist langwierig. Deswegen sind für Startups, die auf rapide Entwicklung und Versionierung aus sind, Microservices nicht unbedingt die erste Wahl. Allerdings können in späterer Entwicklung Probleme mit der Skalierung auftretten was zu einer funktionellen Dekomposition führt. Es könnte schwierig sein die internen verworrenen Abhängigkeiten aufzulösen.<br>
Genauso wichtig wie die Frage &quot;Wann&quot;, ist die Frage &quot;Wie&quot; - wie soll die Aufteilung von Microservices aussehen? Eine Möglichkeit ist die Dekomponierung nach Business Capabilities, die andere nach Domain-Driven Design. Die beiden Fälle wurden in vorherigen Kapiteln erklärt. Dekomponierung nach Anwendungsfällen definiert Services die für bestimmte Aktionen verantwortlich wären, wie z.B. Shipping Service. Partitionierung nach Nomen (Ressourcen) definiert Services für Operationen an Ressourcen oder Entitäten, wie z.B. Account Service. Ein Service sollte ein Set an Verantwortlichkeiten haben, wessen Klassen nach Single Responsibility Principle (SRP) entworfen werden. SRP besagt, dass jede Klasse eine einzige fest definierte Aufgabe im System erfüllen muss und diese Zweckerfüllung übernehmen lediglich dessen Methoden.<br>
Den Weg von Monolith zu Microservices gingen unter anderem Netflix, Amazon und EBay. Netflix generiert bis zu 30% des weltweiten Datenverkehrs und besitzt eine massive serviceorientierte Architektur, welche über eine Milliarde Zugriffe auf ihren Video-Hostingdienst von 800 verschiedenen Geräten aus verwaltet. Amazon benutzt von 100 bis 150 Microservices beim Einsatz dessen Webseite. <a><a href="#ref_Rich17">[RICH17]</a></a></p><h2 id="quellen"><a href="#quellen" aria-hidden="true" class="header-anchor">#</a> Quellen</h2><p><a name="ref_Evan15">[EVAN15]</a>: Evans, Eric: Domain­‐Driven Design Reference, Domain
Language Inc. pp vi-2, 2015, URL: http://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf (letzter Zugriff: 06.06.2018)</p><p><a name="ref_Fowl08">[FOWL08]</a>: Fowler, Martin: HumaneRegistry, 01.12.2008, URL: https://martinfowler.com/bliki/HumaneRegistry.html (letzter Zugriff: 27.05.2018)</p><p><a name="ref_Fowl14">[FOWL14]</a>: Fowler, Martin: BoundedContext, 15.01.2014, URL: https://martinfowler.com/bliki/BoundedContext.html (letzter Zugriff: 06.06.2018)</p><p><a name="ref_Geer17">[GEER17]</a>: Geers, Michael: What are Micro Frontends?, 2017, URL: https://micro-frontends.org/ (letzter Zugriff: 03.06.2018)</p><p><a name="ref_Miri17">[MIRI17]</a>: Miri, Ima: Microservices vs. SOA, 04.01.2017, URL: https://dzone.com/articles/microservices-vs-soa-2</p><p><a name="ref_Lech17">[LECH17]</a>: Lechner, Alexander: Micro-Frontends - Die bessere Art User Interfaces zu implementieren?, 15.11.2017, URL: https://www.it-economics.de/blog/2017-11/micro-frontends-die-bessere-art-user-interfaces-zu-implementieren (letzter Zugriff: 02.06.2018)</p><p><a name="ref_Lewi14">[LEWI14]</a>: Lewis James; Fowler, Martin: Microservices, a definition of this new architectural term, 25.03.2014, URL: https://martinfowler.com/articles/microservices.html (letzter Zugriff: 31.05.2018)</p><p><a name="ref_Nami14">[NAMI14]</a>: Namiot, Dmitry; Sneps-Sneppe, Manfred: On Micro-services Architecture, International Journal of Open Information Technologies ISSN: 2307-8162 vol. 2, no. 9, 2014,
URL: https://cyberleninka.ru/article/v/on-micro-services-architecture (letzter Zugriff: 26.04.2018)</p><p><a name="ref_Peck17">[PECK17]</a>: Peck, Nathan: Microservice Principles: Decentralized Governance, 05.09.2017, URL: https://medium.com/@nathankpeck/microservice-principles-decentralized-governance-4cdbde2ff6ca (letzter Zugriff: 24.05.2018)</p><p><a name="ref_Pien16">[PIEN16]</a>: Pientka, Frank: Wie lassen sich Microservice-Muster effizient umsetzen?, 09.02.2016, URL: https://www.informatik-aktuell.de/entwicklung/methoden/wie-lassen-sich-microservice-muster-effizient-umsetzen.html, (letzter Zugriff: 01.06.2018)</p><p><a name="ref_Rich15">[RICH15]</a>: Richardson, Chris: Pattern: Building Microservices: Using an API Gateway, 15.06.2015, URL: https://www.nginx.com/blog/building-microservices-using-an-api-gateway/ (letzter Zugriff: 9.06.2018)</p><p><a name="ref_Rich17">[RICH17]</a>: Richardson, Chris: Pattern: Microservice Architecture, 2017, URL: http://microservices.io/patterns/microservices.html (letzter Zugriff: 31.05.2018)</p><p><a name="ref_Robe18">[ROBE18]</a>: Roberts, Mike: Serverless Architectures, 22.05.2018, URL: https://martinfowler.com/articles/serverless.html (letzter Zugriff: 27.05.2018)</p><p><a name="ref_Scsvsm">[SCSVSM]</a>:SCS vs. Microservices, URL: http://scs-architecture.org/vs-ms.html (letzter Zugriff: 02.06.2018)</p><p><a name="ref_Söde17">[SÖDE17]</a>: Söderlund, Tom: Micro frontends—a microservice approach to front-end web development, 06.07.2017, URL: https://medium.com/@tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16 (letzter Zugriff: 31.05.2018)</p><p><a name="ref_Tatv16">[TATV16]</a>: TatvaSoft: The Difference between Web Services and Micro Services, 30.06.2016, URL: https://www.tatvasoft.com/blog/the-difference-between-micro-services-and-web-services/</p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/book/continuous-software-engineering/" class="prev">
          Continuous Software Engineering
        </a></span><span class="next"><a href="/book/streaming-architectures/">
          Streaming Architectures
        </a> →
      </span></p></div></div></div></div>
    <script src="/book/assets/js/5.9ccd745b.js" defer></script><script src="/book/assets/js/app.61b0eea4.js" defer></script>
  </body>
</html>
