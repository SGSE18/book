(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{78:function(e,n,t){e.exports=t.p+"assets/img/hyperledger_sawtooth_components.fc158827.png"},79:function(e,n,t){e.exports=t.p+"assets/img/peers.diagram.6.546b49d6.png"},80:function(e,n,t){e.exports=t.p+"assets/img/peers.diagram.9.b514cad8.png"},81:function(e,n,t){e.exports=t.p+"assets/img/fabric_arch.08fe07ce.png"},99:function(e,n,t){"use strict";t.r(n);var r=[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"populare-blockchain-plattformen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#populare-blockchain-plattformen","aria-hidden":"true"}},[e._v("#")]),e._v(" Populäre Blockchain Plattformen")]),r("h2",{attrs:{id:"bitcoin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bitcoin","aria-hidden":"true"}},[e._v("#")]),e._v(" Bitcoin")]),r("p",[e._v("Autor: Nils Dralle")]),r("p",[e._v("Bitcoin ist eine sogenannte Kryptowährung, die ohne eine zentrale Kontrollinstanz (wie z.b. eine Bank) auskommt. Stattdessen bilden alle, die am Zahlungsverkehr mit Bitcoin teilnehmen wollen, ein Netzwerk von Knoten, eine sogenannte Blockchain. Die Bitcoin-Blockchain fungiert als Kontrollinstanz. In ihr werden alle Transaktionen mit Bitcoins vermerkt, und alle Teilnehmer des Netzwerks sind gemeinsam dafür verantwortlich, dass die zugrunde liegende Blockchain aktuell und konsistent ist. Um eine Überweisung mit Bitcoins vornehmen zu können, müssen Sender und Empfänger eine aktuelle Kopie der Blockchain haben. Jede Transaktion im Bitcoin-Netzwerk wird kryptografisch abgesichert.")]),r("h3",{attrs:{id:"geschichte"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#geschichte","aria-hidden":"true"}},[e._v("#")]),e._v(" Geschichte")]),r("p",[e._v("Das Bitcoin-Netzwerk wurde im Jahr 2008 erstmals theoretisch beschrieben und 2009 praktisch umgesetzt. Das Konzept kryptografischer Währungen wurde bereits 1998 veröffentlicht.")]),r("h3",{attrs:{id:"bootstrapping"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping","aria-hidden":"true"}},[e._v("#")]),e._v(" Bootstrapping")]),r("p",[e._v('Um sich initial mit anderen Knoten zu verbinden, nutzt der Bitcoin einen sogenannten "Bootstrapping"-Prozess. Mehrere Knoten des Netzwerks fungieren als Startknoten, die die Addressen weiterer Knoten an neue Knoten verteilen. Die Addressen der Startknoten sind im Domain-Name-System eingetragen, welches der Bitcoin-Client nutzt, um die Addressen der Startknoten zu erhalten. Nachdem die initiale Verbindung erfolgt ist und die Addressen weiterer Knoten von den startknoten weitergegeben wurden, kommmt das Bitcoin-Netzwerk auch ohne die Startknoten aus.')]),r("h3",{attrs:{id:"transaktionen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transaktionen","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaktionen")]),r("p",[e._v("Jede Transaktion im Bitcoin-Netzwerk besteht aus der kryptografischen Signatur des Senders und dem mit dem Public-Key des Empfängers signierten Hash der vorherigen Transaktion. Auf diese Weise kann der Empfänger die Transaktion verifizieren. Transaktionen werden an alle Knoten im Netzwerk verteilt. [NAKA08] Jede Transaktion hat beim Bitcoin mehrere In- und Outputs, um die Transaktion in mehrere Teilbeträge zerlegen zu können.")]),r("h3",{attrs:{id:"zeitstempel"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zeitstempel","aria-hidden":"true"}},[e._v("#")]),e._v(" Zeitstempel")]),r("p",[e._v("Damit jeder Knoten die Transaktionen zeitlich einordnen kann, implementiert Bitcoin einen verteilten Zeitstempel-Server. [NAKA08] Der Zeitstempel besteht aus dem Hashwert der Daten, die einen Zeitstempel erhalten sollen, sowie dem Hashwert des vorherigen Zeitstempels.")]),r("h3",{attrs:{id:"proof-of-work"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proof-of-work","aria-hidden":"true"}},[e._v("#")]),e._v(" Proof-of-Work")]),r("p",[e._v("Der Bitcoin nutzt einen Proof-of-Work Algorithmus zu Entscheidungsfindung über neue Blöcke. Dabei wird innerhalb des neuen Blocks ein spezieller Wert, eine sogennante "),r("em",[e._v("Nonce")]),e._v(", angelegt. Dieser Wert wird solange erhöht, bis ein Hash für den Block gefunden wird, der mit einer bestimmten Anzahl Nullen beginnt. Über die benötigte Anzahl Nullen kann die Schwierigkeit des Proof-of-Work angepasst werden. Beim Bitcoin wird die Schwierigkeit automatisch so angepasst, dass ein neuer Block etwa alle 10 Minuten gefunden wird.")]),r("h3",{attrs:{id:"protokoll"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#protokoll","aria-hidden":"true"}},[e._v("#")]),e._v(" Protokoll")]),r("p",[e._v("Mining, UTXO etc.")]),r("h2",{attrs:{id:"hyperledger"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hyperledger","aria-hidden":"true"}},[e._v("#")]),e._v(" Hyperledger")]),r("p",[e._v("Autor: Cem Basoglu")]),r("p",[e._v("Das in 2016 gegründete Hyperledger Projekt fasst mehrere Frameworks und Tools\nzusammen, die den Einsatz von Distributed Ledger Technologien in Business\nApplikationen ermöglichen sollen "),r("a",[r("a",{attrs:{href:"#ref_cach16"}},[e._v("[CHAC16]")])]),e._v(".\nNeben den von IBM und Intel initial beigesteuerten Distributed Ledger Codebasen,\nFabric und Sawtooth, gehören mittlerweile drei weitere Frameworks und eine Vielzahl\nvon Tools zum Hyperledger Projekt.")]),r("p",[e._v("Im Gegensatz zu anderen populären Blockchain Plattformen, bei dem eine\nKryptowährung im Vordergrund steht, setzen die Frameworks in Hyperledger auf\neinen möglichst modularen Distributed Ledger und überlassen die Implementierung\neiner Währung und Zahlungsabwicklung, der auf dem Framework aufbauend\nApplikation "),r("a",[r("a",{attrs:{href:"#ref_owen17"}},[e._v("[OWEN17]")])]),e._v(".")]),r("h3",{attrs:{id:"frameworks"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#frameworks","aria-hidden":"true"}},[e._v("#")]),e._v(" Frameworks")]),r("p",[e._v("Jedes Framework im Hyperledger Projekt stellt eine eigene Blockchain Plattform\ndar, die sich sowohl konzeptionell als auch von der Codebasis unterscheiden.\nBevor die einzelnen Frameworks in den folgenden Abschnitten im Detail beschrieben\nwerden, bietet nachstehende Übersicht einen Vergleich der jeweiligen Distributed\nLedger Technologien.")]),r("table",[r("thead",[r("tr",[r("th",[e._v("Merkmal")]),r("th",[e._v("Fabric")]),r("th",[e._v("Sawtooth")]),r("th",[e._v("Iroha")]),r("th",[e._v("Indy")]),r("th",[e._v("Burrow")])])]),r("tbody",[r("tr",[r("td",[e._v("Projekt Status")]),r("td",[e._v("Aktiv")]),r("td",[e._v("Aktiv")]),r("td",[e._v("Aktiv")]),r("td",[e._v("Inkubation")]),r("td",[e._v("Inkubation")])]),r("tr",[r("td",[e._v("Berechtigung")]),r("td",[e._v("permissioned")]),r("td",[e._v("permissioned / permissionless")]),r("td",[e._v("permissioned")]),r("td",[e._v("permissioned")]),r("td",[e._v("permissioned")])]),r("tr",[r("td",[e._v("Konsensus")]),r("td",[e._v("SOLO, Kafka, SBFT")]),r("td",[e._v("PoET, RAFT")]),r("td",[e._v("YAC (BFT)")]),r("td",[e._v("RBFT "),r("a",[r("a",{attrs:{href:"#ref_aubl13"}},[e._v("[AUBL13]")])])]),r("td",[e._v("Tendermint")])]),r("tr",[r("td",[e._v("Smart Contract / Business Model")]),r("td",[e._v("ja")]),r("td",[e._v("ja")]),r("td",[e._v("nein")]),r("td",[e._v("nein")]),r("td",[e._v("ja")])]),r("tr",[r("td",[e._v("SDK")]),r("td",[e._v("Go, Node.JS, Java")]),r("td",[e._v("Python, Go, Javascript")]),r("td",[e._v("gRPC API")]),r("td",[e._v("-")]),r("td",[e._v("Solidity")])])])]),r("h4",{attrs:{id:"fabric"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fabric","aria-hidden":"true"}},[e._v("#")]),e._v(" Fabric")]),r("p",[e._v("Hyperledger Fabrik ist ein Distributed Ledger Framework für "),r("em",[e._v("permissioned")]),e._v("\nBlockchains, zum Ausführen von verteilten Applikationen unter der Verwendung\nvon Standard Sprachen wie Go, Java oder Javascript "),r("a",[r("a",{attrs:{href:"#ref_andr18"}},[e._v("[ANDR18]")])]),e._v(".")]),r("p",[e._v("Wie in Abbildung 8.4.2.1 dargestellt, wird das Framework in die Komponenten\nMembership Service Provider, Peer, Ordering Service und Chaincode unterteilt,\nwobei durch den modularen Aufbau die Komponenten beliebig ausgetauscht oder\ndurch eigene Implementierungen ersetzt werden können. Die Kommunikation zwischen\nden Komponenten erfolgt mittels gRPC.")]),r("p",[r("img",{attrs:{src:t(81),alt:"Fabric Architektur",title:"Fabric Architektur"}})]),r("p",[e._v("Abbildung 8.4.2.1 - Fabric Architektur (Quelle: "),r("a",[r("a",{attrs:{href:"#ref_andr18"}},[e._v("[ANDR18]")])]),e._v(")")]),r("h5",{attrs:{id:"membership-service-provider"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#membership-service-provider","aria-hidden":"true"}},[e._v("#")]),e._v(" Membership Service Provider")]),r("p",[e._v("Damit eine Entität, wie z.b. ein Peer oder Client, mit dem Distributed Ledger\ninteragieren kann, muss dieser im System bekannt sein. Dazu wird jeder Entität\nein Zertifikat nach dem X.509 Standard ausgestellt und der "),r("em",[e._v("Public Key")]),e._v(" beim\nMembership Service Provider registriert. Die Zertifikate dienen als Identität\nund werden sowohl für die Signierung von Transaktionen, als auch für die TLS\ngesicherte Kommunikation zwischen der Peers verwendet.")]),r("p",[e._v("Der MSP kann zentral oder, wenn es das Geschäftsmodell voraussetzt, durch\nmehrere Teilnehmer der Blockchain in einem Verbund betrieben werden. Ebenfalls\nlassen sich ein oder mehrere Organisationen und die dazugehörigen Root- bzw.\nIntermediate-Zertifkate beim MSP registrieren. Mittels der organisatorischen\nEinheiten können komplexere Anwendungsfälle konstruiert werden, bei dem z.B.\nmehrere Unternehmen miteinander agieren können, Transaktionen jedoch nur von\nden Unternehmen gelesen werden können, die von der Transaktion tangiert werden.")]),r("p",[r("img",{attrs:{src:t(80),alt:"Organisationen und Channels",title:"Organisationen und Channels"}})]),r("p",[e._v("Abbildung 8.4.2.2 - Organisationen und Channels (Quelle: "),r("a",[r("a",{attrs:{href:"#ref_fabr18"}},[e._v("[FABR18]")])]),e._v(")")]),r("p",[e._v("Darüber hinaus können sogenannte Channels verwendet werden, um das\nBlockhain-Netzwerk noch weiter zu unterteilen. Jedes dieser Sub-Netzwerke\nbesitzt sowohl einen eigenen Kommunikationskanal, als auch einen eigenen\nDistributed Ledger. Wie in Abbildung 8.4.2.2 dargestellt, können somit mehrere\nprivate Ledgers zwischen den Teilnehmern betrieben werden.")]),r("p",[e._v("Um eine für Bitcoin oder Ethereum typische Blockchain Topologie zu\nimplementieren, würde somit nur ein Channel benötigt werden. Alle Peers würden\ndiesen Channel nutzen, um über einen gemeinsamen Distributed Ledger im Konsens\nzu sein.")]),r("h5",{attrs:{id:"peer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#peer","aria-hidden":"true"}},[e._v("#")]),e._v(" Peer")]),r("p",[e._v("Ein Fabric Blockhain-Netzwerk besteht in der Regel aus mehreren Peers. Jeder\nPeer kann an einem oder mehreren Channels teilnehmen, für den jeweils ein\neigener, logisch getrennter Ledger verwaltet und mittels Smart Contracts\nzugegriffen wird. Dazu verbindet sich der Client mit einem Peer und nutzt die\nFunktionen der auf diesem Peer verfügbaren Smart Contracts, um Daten von dem\nLedger abzufragen bzw. zu ändern. Trotz eines gemeinsamen Ledgers je Channel,\nmüssen nicht alle Peers die selben Smart Contracts bereitstellen.")]),r("p",[e._v("Für die Persistierung des Ledgers wird standardmäßig LevelDB verwendet, um den\nZustand der Smart Contracts als Schlüsselwertepaar abzulegen. Alternativ kann\nauch CouchDB eingesetzt werden, um Datenstrukturen im JSON-Format zu\npersistieren und damit komplexere Abfragen aus dem Ledger zu ermöglichen.")]),r("h5",{attrs:{id:"ordering-service"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ordering-service","aria-hidden":"true"}},[e._v("#")]),e._v(" Ordering Service")]),r("p",[e._v("Während eine Abfrage vom Distributed Ledger von einem einzelnen Peer verarbeitet\nwerden kann, müssen bei Änderungen die Peers im Konsens sein. In diesem Prozess\nnimmt der Ordering Service eine essenzielle Rolle ein. Wie es der Name schon\nerahnen lässt, ist es die Hauptaufgabe des Ordering Service die Transaktionen in\neine Reihenfolge zu bringen, zu einem Block zu verpacken und an die Peers zu\nverteilen. Dadurch wird sichergestellt, dass genug Peers der Änderung zugestimmt\nhaben und alle Transaktionen in der selben Reihenfolge an den Ledger angehängt\nwerden.")]),r("p",[e._v("Neben dem hier beschrieben Konsens Algorithmus  genannt und ist Standardmäßig")]),r("h5",{attrs:{id:"client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client","aria-hidden":"true"}},[e._v("#")]),e._v(" Client")]),r("p",[e._v("Wie bei klassischen Client-Server-Architekturen stellt der Client, auch im\nHyperledger Fabric Kontext, die vom Nutzer lokal ausgeführte Applikation dar.\nFür diesen Zweck stellt das Hyperledger Fabric Framework, eine Client-Bibliothek\nbereit, mit dem die Applikation mit den Peers und Ordering Services interagieren\nkann.")]),r("h5",{attrs:{id:"chaincode"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#chaincode","aria-hidden":"true"}},[e._v("#")]),e._v(" Chaincode")]),r("p",[e._v("Ein zentrales Element im Fabric Framework bildet der Smart Contract, der auch\nChaincode genannt wird. Über diesen werden sämtliche Funktionalitäten der\nBlockchain abgebildet. Somit existieren nur zwei Arten von Transaktionen - das\nDeployen eines Smart Contracts und das Aufrufen einer Funktion im Smart\nContract. Über sogenannte System Smart Contracts, die jeder Peer besitzt, können\nebenfalls Konfigurationen am Blockhain Netzwerk vorgenommen werden.")]),r("p",[e._v("Smart Contracts können in Standard Programmiersprachen wie Go, Node.Js oder Java\ngeschrieben werden. Wie in Listing 8.4.2.1 dargestellt, implementiert\njeder Smart Contract das "),r("em",[e._v("ChaincodeInterface")]),e._v(" aus dem Hyperledger Fabric SDK.")]),r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{attrs:{class:"token keyword"}},[e._v("const")]),e._v(" shim "),r("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{attrs:{class:"token function"}},[e._v("require")]),r("span",{attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{attrs:{class:"token string"}},[e._v("'fabric-shim'")]),r("span",{attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),r("span",{attrs:{class:"token keyword"}},[e._v("var")]),e._v(" Chaincode "),r("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),r("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),r("span",{attrs:{class:"token keyword"}},[e._v("async")]),e._v(" "),r("span",{attrs:{class:"token function"}},[e._v("Init")]),r("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stub"),r("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),r("span",{attrs:{class:"token comment"}},[e._v("//initialize Chaincode State")]),e._v("\n  "),r("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),r("span",{attrs:{class:"token keyword"}},[e._v("async")]),e._v(" "),r("span",{attrs:{class:"token function"}},[e._v("Invoke")]),r("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stub"),r("span",{attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),r("span",{attrs:{class:"token comment"}},[e._v("//Chaincode invokation handler")]),e._v("\n  "),r("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),r("p",[e._v("Listing 8.4.2.1 - Smart Contract Beispiel")]),r("p",[e._v("Die Deploy-Transaktion stellt eine spezielle Form der Invoke-Transaktion dar,\nmit dem zunächst der Smart Contract auf dem jeweiligen Peer instanziiert und\nanschließend die "),r("em",[e._v("Init(...)")]),e._v("-Methode aufgerufen wird. In dieser Methode hat der\nSmart Contract die Gelegenheit die eigenen State-Variablen im Distributed Ledger\nzu initialisieren.\nJede Invoke-Transaktion eines Smart Contracts wird von der Methode "),r("em",[e._v("Invoke(...)")]),e._v("\nbehandelt. Über die Eigenschaften in dem Parameter "),r("em",[e._v("stub")]),e._v(" kann ermittelt werden,\nwelche Funktionen des Smart Contracts mit welche Argumenten aufgerufen wurde, um\ndie gewünschte Aktion vorzunehmen.")]),r("h5",{attrs:{id:"transaktion-workflow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transaktion-workflow","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaktion-Workflow")]),r("p",[e._v("Abfragen vom Distributed Ledger werden umgehend vom Peer beantwortet. Für\nAktualisierungen muss der Client eine bestimmte Anzahl von Bestätigungen\n("),r("em",[e._v("Endorsement")]),e._v(") von mehreren Peers einholen. Wie in Abbildung 8.4.2.3\ndargestellt, ruft die Applikation dazu zunächst die gewünschte Funktion im\nSmart Contract auf, wodurch ein Antrag ("),r("em",[e._v("Proposal")]),e._v(") zur Änderung des\nDistributed Ledgers initiiert wird. Die Peers führen dabei die Funktion im\nSmart Contract aus und erzeugen eine signierte Bestätigung des Antrags. Hierbei\nwird der Ledger jedoch noch nicht geändert und lediglich die Bestätigungen der\nPeers erzeugt und an den Client zurück geschickt.")]),r("p",[r("img",{attrs:{src:t(79),alt:"Chaincode Aufruf",title:"Chaincode Aufruf"}})]),r("p",[e._v("Abbildung 8.4.2.3 - Chaincode Aufruf (Quelle: "),r("a",[r("a",{attrs:{href:"#ref_fabr18"}},[e._v("[FABR18]")])]),e._v(")")]),r("p",[e._v("Der Client sammelt die Bestätigungen der einzelnen Peers und überträgt diese\nsamt Antrag an den Ordering Service. Erst mit der Übertragung des Antrags an den\nOrdering Service, wird der Änderungsprozess eingeleitet. Der Ordering Service\nsammelt die Anträge von allen Applikationen, verpackt diese in einen Block und\nüberträgt diese schliesslich an alle Peers. Die Peers hängen anschließend den\nBlock an den jeweils lokalen Ledger und aktualisieren den State. Wenn alle Peers\ndie Änderung übernommen haben, wird die Applikation über die Änderung des\nDistributed Ledgers benachrichtigt und die Transaktion damit abgeschlossen.")]),r("h4",{attrs:{id:"sawtooth"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sawtooth","aria-hidden":"true"}},[e._v("#")]),e._v(" Sawtooth")]),r("p",[e._v("Das Sawtooth Framework ist ebenfalls eine "),r("em",[e._v("permissioned")]),e._v(" Blockchain Plattform,\nfür die Entwicklung von Distributed Ledger Applikationen im Unternehmensumfeld.\nAuch wenn diese Blockchain Plattform ohne Berechtigungen betrieben werden kann,\nso sind die derzeit verfügbaren Konsens-Algorithmen nur für Netzwerke ausgelegt,\nin dem ein gewisses Vertrauen an die Teilnehmer vorausgesetzt wird.")]),r("p",[e._v("Wie in Abbildung 8.4.2.4 dargestellt, besteht das Netzwerk aus Peers\n("),r("em",[e._v("Validator")]),e._v("), einer optionalen REST-Schnittstelle für die Client-Applikationen\nund den optionalen Transaction-Processoren.")]),r("p",[r("img",{attrs:{src:t(78),alt:"Sawtooth Architektur",title:"Sawtooth Architektur"}})]),r("p",[e._v("Abbildung 8.4.2.4 - Sawtooth Architektur (Quelle: "),r("a",[r("a",{attrs:{href:"#ref_sawt18"}},[e._v("[SAWT18]")])]),e._v(")")]),r("h5",{attrs:{id:"validator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#validator","aria-hidden":"true"}},[e._v("#")]),e._v(" Validator")]),r("p",[e._v("Der Validator ist zuständig für das Ausführen, Validieren und Verteilen der\nTransaktionen an die restlichen Validatoren. Dazu werden zwei Netzwerk-Ebenen\nverwendet, um zum einen neue Transaktionen mit den benachbarten Peers\nauszutauschen und zum anderen mit den Transaction Processoren zu kommunizieren.\nFür die Kommunikation zwischen den Validatoren, wird das Open-Source Projekt 0MQ\nverwendet.")]),r("h5",{attrs:{id:"transaction-processor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transaction-processor","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaction Processor")]),r("p",[e._v("Für die Entwicklung einer Applikation auf Basis des Sawtooth Framworks, muss ein\nsogenannter Transaction Processor implementiert werden. Im Gegensatz zu Smart\nContracts, wird die implementierte Applikation nicht in das Blockchain-Netzwerk\nzur Ausführung auf den Peers ausgeliefert. Stattdessen wird der Transaction\nProcessor eigenständig ausgeführt und registriert sich bei den Peers zur\nVerarbeitung von Transaktionen eines bestimmten Typs ("),r("em",[e._v("Transaction Family")]),e._v(").\nDabei gibt die Client Applikation in der Transaktion an, um welche Typ von\nTransaktion es sich handelt und serialisiert die Applikationsdaten in den\nPayload der Transaktion.")]),r("p",[e._v("Daher kann das Netzwerk an Validatoren als Tunnel zwischen dem Client und dem\nTransaction Processor betrachtet werden, während der State der Applikation im\nDistributed Ledger persistiert wird.")]),r("h5",{attrs:{id:"rest-schnittstelle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rest-schnittstelle","aria-hidden":"true"}},[e._v("#")]),e._v(" REST-Schnittstelle")]),r("p",[e._v("Um den Zugriff auf das Blockchain-Netzwerk zu vereinfachen, kann die\nREST-Schnittstelle aus dem Framework verwendet werden. Der REST-Dienst verbindet\nsich mittels 0MQ, mit dem in der Konfiguration festgelegten Validator und stellt\ndie Validator Funktionen über REST-Ressourcen bereit.")]),r("h4",{attrs:{id:"iroha"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#iroha","aria-hidden":"true"}},[e._v("#")]),e._v(" Iroha")]),r("p",[e._v("https://github.com/hyperledger/iroha/issues/249")]),r("h4",{attrs:{id:"indy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#indy","aria-hidden":"true"}},[e._v("#")]),e._v(" Indy")]),r("h4",{attrs:{id:"burrow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#burrow","aria-hidden":"true"}},[e._v("#")]),e._v(" Burrow")]),r("h3",{attrs:{id:"tools"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tools","aria-hidden":"true"}},[e._v("#")]),e._v(" Tools")]),r("h4",{attrs:{id:"composer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#composer","aria-hidden":"true"}},[e._v("#")]),e._v(" Composer")]),r("h4",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#","aria-hidden":"true"}},[e._v("#")]),e._v(" ...")]),r("p",[e._v("weitere relevante Tools")]),r("h2",{attrs:{id:"ethereum"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ethereum","aria-hidden":"true"}},[e._v("#")]),e._v(" Ethereum")]),r("p",[e._v("Autor: Philipp Möller")]),r("p",[e._v("Testing, Verifikation, etc.")]),r("p",[e._v("Tools (Truffle, etc.)")]),r("h2",{attrs:{id:"literaturverzeichnis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#literaturverzeichnis","aria-hidden":"true"}},[e._v("#")]),e._v(" Literaturverzeichnis")]),r("p",[r("a",{attrs:{name:"ref_example04"}},[e._v("[EXAMPLE04]")]),e._v(": John, Doe: Dummy Titel. Main-Verlag, 2004, ISBN: XXXXX")]),r("p",[r("a",{attrs:{name:"ref_andr18"}},[e._v("[ANDR18]")]),e._v(": Androulaki, Elli, et al. Hyperledger fabric: a distributed operating system for permissioned blockchains. arXiv preprint arXiv:1801.10228, 2018")]),r("p",[r("a",{attrs:{name:"ref_aubl13"}},[e._v("[AUBL13]")]),e._v(": P. L. Aublin, et al.: RBFT: Redundant Byzantine Fault Tolerance. 2013 IEEE 33rd International Conference on Distributed Computing Systems, Philadelphia, 2013, URL: "),r("a",[r("a",{attrs:{href:"http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6681599&isnumber=6681559",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6681599&isnumber=6681559")])])]),r("p",[r("a",{attrs:{name:"ref_cach16"}},[e._v("[CHAC16]")]),e._v(": Cachin, Christian: Architecture of the Hyperledger Blockchain Fabric. Workshop on Distributed Cryptocurrencies and Consensus Ledgers, 2016")]),r("p",[r("a",{attrs:{name:"ref_fabr18"}},[e._v("[FABR18]")]),e._v(": Fabric Documentation. URL: "),r("a",[r("a",{attrs:{href:"http://hyperledger-fabric.readthedocs.io/en/release-1.1/peers/peers.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://hyperledger-fabric.readthedocs.io/en/release-1.1/peers/peers.html")])])]),r("p",[e._v("[NAKA08] Nakamoto, S., Bitcoin: A peer-to-peer electronic cash system., 2008")]),r("p",[r("a",{attrs:{name:"ref_owen17"}},[e._v("[OWEN17]")]),e._v(": Owens, Luke: Cryptoasset Framework on Intel's Hyperledger Sawtooth. URL: "),r("a",[r("a",{attrs:{href:"https://fullmetalhealth.com/cryptoasset-framework-intels-hyperledger-sawtooth-part-one/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://fullmetalhealth.com/cryptoasset-framework-intels-hyperledger-sawtooth-part-one/")])])]),r("p",[r("a",{attrs:{name:"ref_sawt18"}},[e._v("[SAWT18]")]),e._v(": Sawtooth Documentation. URL: "),r("a",[r("a",{attrs:{href:"https://sawtooth.hyperledger.org/docs/core/releases/latest/contents.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://sawtooth.hyperledger.org/docs/core/releases/latest/contents.html")])])])])}],i=t(0),a=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);n.default=a.exports}}]);