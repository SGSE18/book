(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{160:function(e,n,t){"use strict";t.r(n);var r=[function(){var e=this.$createElement,n=this._self._c||e;return n("h1",{attrs:{id:"functional-reactive-programming"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#functional-reactive-programming","aria-hidden":"true"}},[this._v("#")]),this._v(" Functional Reactive Programming")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"functional-programming-konzept"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#functional-programming-konzept","aria-hidden":"true"}},[this._v("#")]),this._v(" Functional Programming Konzept")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[this._v("Wartbarer Code")]),n("li",[this._v("Wiederverwertbarer Code")]),n("li",[this._v("Verständlicher Code")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('public class Arbeiter{\n    private String name;\n    private int gehalt;\n\n    public Arbeiter(String _name, int _gehalt){\n        this.name = _name;\n        this.gehalt = _gehalt;\n    }\n\n    public int gehaltsErhoehung(int zuschlag){\n        this.gehalt += zuschlag;\n        return this.gehalt;\n    }\n\n    public String toString(){\n        return this.name + " verdient " + this.gehalt;\n    }\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("for (angestelltenListe Angestellter: tempAngestellter){\n    tempAngestellter.gehaltsErhoehung(200);\n}\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('arbeiter = [\n  [ "Alice",  10000.0 ],\n  [ "Bob", 12500.0 ]\n]\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Ein weiterer Punkt der zum Aspekt der Reinheit einer Funktion gehört, ist das Auftreten von Seiteneffekten (Side effects).\nSeiteneffekte können vielfältig sein: Das Ändern einer globalen Variable im Funktionsaufruf, das Lesen aus einer Datei oder\ndas Werfen einer Exception. Beispielsweise kann das Lesen einer Datei in einer Funktion den Rückgabewert unabhängig"),n("br"),this._v("\nvon den übergebenen Parametern verändern, was nicht mehr der Definition einer Reinen Funktion entsprechen würde.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"vorteile"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vorteile","aria-hidden":"true"}},[this._v("#")]),this._v(" Vorteile")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"nachteile"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nachteile","aria-hidden":"true"}},[this._v("#")]),this._v(" Nachteile")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"reactive-programming"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactive-programming","aria-hidden":"true"}},[this._v("#")]),this._v(" Reactive Programming")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Beim reaktiven Programmieren geht es darum, die Veränderung eines Zustandes zu beobachten und gegebenfalls mit einer Veränderungen\ndes eigenen Zustandes zu reagieren. Eine Zustandsänderung könnte zum Beispiel das Drücken eines Knopfes auf einer Benutzeroberfläche oder\naber das Abholen von Daten über einen HTTP Aufruf. Bibliotheken wie RxJS, xStream oder Most.js erlauben es von fast jeder Variable oder Objekt\nein Observable zu erstellen. So kann unter RxJS beispielsweise mit dem "),n("code",[this._v("just()")]),this._v(" Operator ein Observable von der Zahl 1 erstellt werden:")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("var oneStream = Rx.Observable.just(1);\n\noneStream.subscribe(number =>{\n    console.log(number); \\\\prints 1\n});\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Ein Observable ist zu verstehen als ein Objekt, welche über einen bestimmten oder auch unbestimmten Zeitraum\nWerte ausgibt (emitted). Ein Observable ist somit zu stehen als ein Stream von Daten. Um an die emitteten Daten zu gelangen, kann dem Stream über die "),n("code",[this._v("subscribe()")]),this._v(" Methode gelauscht werden. Erst nachdem jemand auf den Stream\nsubscribed hat, fängt der Stream an, Werte auszugeben. Dabei wird der Callback innerhalb der Subscribe Methode\nin jedes mal ausgeführt, sobald ein neuer Wert von dem Stream emitted wurde.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('var numbers = [1,2,3];\nvar arrayStream. = Rx.Observable.form(numbers);\n\narrayStream.subscribe(number =>{\n    console.log("Number " + number); \n}); \n\n//Output:\n//Number 1\n//Number 2\n//Number 3\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("In diesem Beispiel wurde mit dem "),n("code",[this._v("fromArray()")]),this._v(" Operator aus einem Array ein Observable erstellt und das Array\nso als Stream verfügbar gemacht. Nach dem ein Observer den Stream abonniert (subscribed), emittet der Stream so lange Werte bis das Ende des Array erreicht ist.\nEin Mittel die Streams darzustellen sind die sogenannten Marble-Diagramme: Diese Diagramme bestehen aus einem\nPfeil, welcher eine Zeitleiste darstellt.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"der-observer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#der-observer","aria-hidden":"true"}},[this._v("#")]),this._v(" Der Observer")])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[e._v("Der Observer wird in den oberen beiden Beispielen impliziert erstellt. Ein Observer besteht im wesentlichen aus\ndrei Methoden: "),t("code",[e._v("onNext()")]),e._v(", "),t("code",[e._v("onError()")]),e._v(" und "),t("code",[e._v("onComplete()")]),e._v(". In den Beispielen wurde mit der "),t("code",[e._v("subscribe()")]),e._v(" Methode\nein neuer Observer erstellt, welcher nur die "),t("code",[e._v("onNext()")]),e._v(" Methode als anonyme Funktion übergeben bekommen hat. Damit wird der Observer nur über einen\nneue emitteten Wert des Streams informiert. Die "),t("code",[e._v("onComplete()")]),e._v(" Methode würde im Beispiel nach dem Ausgeben des letzten\nWertes aufgerufen um dem Observer mitzuteilen, dass auf diesem Stream keine neuen Werte mehr ausgegeben werden.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[n("img",{attrs:{src:t(65),alt:"Observable-Patter",title:"Das Observerpattern"}}),this._v("\nUm hier die parallele zur RxJS Bibliothek zu ziehen: Die mit "),n("code",[this._v("subscribe()")]),this._v(" übergeben Funktion ist in diesem Falle der Observer. Zu einen\nStream können beliebig viele Observer hinzugefügt werden. Das im UML angegebene Subject ist der eigentliche Stream. Die "),n("code",[this._v("registerObserver()")]),this._v("\nMethode ist die "),n("code",[this._v("subscribe()")]),this._v(" Methode des Observables.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"das-observable"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#das-observable","aria-hidden":"true"}},[this._v("#")]),this._v(" Das Observable")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("var buttonEvent = document.querySelector('.myButton');\nvar clickStream = Rx.Observable.fromEvent('buttonEvent', click);\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[this._v("from()        - Erstellt ein Observable von Datenstruktur und Iteriert über diese falls möglich")]),n("li",[this._v("just()        - Erstellt ein Observable von Datenstruktur und emittet eben diese")]),n("li",[this._v("fromEvent()   - Erstellt ein Observable von einer Eventsource und emittet das Event")]),n("li",[this._v("interval()    - Erstellt ein Observable welches in einem bestimmten Intervall aufsteigende Zahlen emittet")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"die-operatoren"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#die-operatoren","aria-hidden":"true"}},[this._v("#")]),this._v(" Die Operatoren")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Nehmen wird das Klickevent Beispiel von oben: Die Aufgabe soll es sein, die Anzahl der Klicks auf den Button zu zählen. Aber anstatt die\nkomplette Logik in die "),n("code",[this._v("subscribe()")]),this._v(" zu packen, können wir uns einer vielzahl an Operatoren bedienen, welche den Stream manipulieren.\nZunächst sollen alle Events, die auf dem Stream passieren auf einen neuen Wert abgebildet werden. Dazu kann der "),n("code",[this._v("map()")]),this._v(" Operator genutzt werden:")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("var buttonEvent = document.querySelector('.myButton');\nvar clickStream = Rx.Observable.fromEvent('buttonEvent', click);\n\nvar numberStream = clickStream.map(event => 1);\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("clickStream       ---x----x-x----x-x--\x3e"),n("br"),this._v("\n          map()"),n("br"),this._v("\nnumberStream  ---1----1-1----1-1--\x3e")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Nun, da die Klickevents auf eine Zahl gemapped worden sind, müssen die vom numberStream emitteten Zahlen nur noch addiert werden. Dazu muss\nes State geben, in welchem das Ergebnis der vorheringen Addition gehalten wird. Ein Operator mit eingebautem State ist der "),n("code",[this._v("scan()")]),this._v("\nOperator.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("var buttonEvent = document.querySelector('.myButton');\nvar clickStream = Rx.Observable.fromEvent('buttonEvent', click);\n\nvar numberStream = clickStream.map(event => 1);\nvar numberClickStream = numberStream.scan((accumulator, current) => accumulator + current);\n\nnumberClickStream.subscribe(number => console.log(number));\n\n\\\\Output: \n\\\\1\n\\\\2\n\\\\3\n...\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("clickStream                 ---x----x-x----x-x--\x3e"),n("br"),this._v("\n          map()"),n("br"),this._v("\nnumberStream            ---1----1-1----1-1--\x3e"),n("br"),this._v("\n          scan()"),n("br"),this._v("\nnumberClickStream  ---1----2-3----4-5--\x3e")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("var buttonEvent = document.querySelector('.myButton');\nvar clickStream = Rx.Observable.fromEvent('buttonEvent', click)\n    .map(event => {\n        button: 'myButton',\n        Wert: 1,\n        eventDaten: event.data\n    })\n    .fold([], (acc, cur)=> acc.push(cur));\n")])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[e._v("Hier wird dem "),t("code",[e._v("fold()")]),e._v(" Operator als ersten Wert eine leere Liste übergeben. Diese dient als Seed für den State innerhalb des Operators.\nNachdem das erste Event den "),t("code",[e._v("fold()")]),e._v(" Operator erreicht, wird das Event-JSON zu der Liste hinzugefügt. Würde man nun den clickStream\nabonieren, so würde man bei jedem Klickevent eine Liste mit JSON Obejekten erhalten, deren länge davon anhängt, wie oft der Knopf\ngedrückt worden ist.\nDieses Beispiel zeigt zusätzlich das für jeden Operator nicht jedesmal ein neuer Stream erstellt werden muss. Operatoren können\nbeliebig lang auf einem Observable verkettet werden. Im oberen Fall wird das Oberservable mit dem "),t("code",[e._v("map()")]),e._v(" Operator und dem "),t("code",[e._v("fold()")]),e._v("\nOperator verknüpft.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"hot-und-cold-observables"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hot-und-cold-observables","aria-hidden":"true"}},[this._v("#")]),this._v(" Hot und Cold Observables")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"cyclejs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cyclejs","aria-hidden":"true"}},[this._v("#")]),this._v(" CycleJS")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"konzept"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#konzept","aria-hidden":"true"}},[this._v("#")]),this._v(" Konzept")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"driver-und-sinks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#driver-und-sinks","aria-hidden":"true"}},[this._v("#")]),this._v(" Driver und Sinks")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"side-effects"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#side-effects","aria-hidden":"true"}},[this._v("#")]),this._v(" Side effects")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h3",{attrs:{id:"sample-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sample-code","aria-hidden":"true"}},[this._v("#")]),this._v(" Sample Code")])}],i=t(0),s=Object(i.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[e._m(0),e._m(1),t("p",[e._v("In den letzten Jahren ist das Thema funktionales Programmieren immer stärker aufgekommen. Die Ziele,\nwelche beim funktionalen Programmieren sind dabei die selben wie sich auch beim objektorientierten Programmieren\nerreicht werden sollen:")]),e._m(2),t("p",[e._v("Auch wenn die Ziel der beiden Ansätze gleich sein, so sind die unterliegenden Paradigmen doch völlig unterschiedliche:\nBeim objektorientieren Ansatz wird versucht, die Daten und die damit verbundenen Verhalten miteinander zu vereinen.\nDie daraus resultierende Vereinigung ist die Grundlage des OOP-Ansatzes: Das Objekt.\nIn einem Objekt werden über Instanzvariablen Daten gehalten, die den Zustand des Objektes beschreiben. Zusätzlich\nenthält das Objekt Verhalten in Form von Methoden, mit deren Hilfe der Zustand des Objektes manipuliert werden kann.")]),t("p",[e._v("Ein einfach Beispiel ist die Klasse Arbeiter:")]),e._m(3),t("p",[e._v("Nun könnten die Instanzen dieses Arbeiterobjektes in einer Liste gehalten werden, um sie so beispielsweise zu verwalten.\nEin Anwendungsfall könnte es des weiteren sein, dass alle Arbeiter in dieser Liste eine Gehaltserhöhung bekommen sollen.\nUm dies in einer objektorientierten Sprache wie in diesem Falle Java zu realisieren, müsste das zu schreibende Programm\nüber die Liste der Arbeiter iterieren und für jeden Arbeiter die Methode zur Gehaltserhöhung aufrufen.")]),e._m(4),t("p",[e._v("Der selbe Sachverhalt kann natürlich auch mit einem funktionalen Ansatz abgebildet werden:")]),e._m(5),t("p",[e._v("Hier wird direkt der erste Unterschied zum objektorientieren Ansatz deutlich: Die Trennung von Daten und Verhalten.\nWo im OOP-Ansatz bei der Erstellung der Daten auch gleichzeitig die Methoden zum manipulieren der Daten mitliefern\nwerden musste, so bleiben im FP-Ansatz die Daten rein. Hier können die Daten durch den Einsatz von einfachen Arrays\nrepräsentiert werden.")]),t("p",[e._v("Zur Veränderung der Daten können nun verschiedene Funktionen geschrieben werden. Dabei sollten allerdings verschiedene\nSchlüsselkonzepte beachtet werden:")]),t("center",[t("b",[e._v("1. Funktionen haben eine einzige Aufgabe")])]),t("p",[e._v("Die geschriebenen Funktionen haben genau eine Aufgabe. Dadurch wird erreicht das verschiedene Funktionen\nmiteinander kombinierbar werden und so ein komplexeres Programm bilden. Zudem erhöht das Beschränken einer\nFunktion auf eine einzige Aufgabe die Testbarkeit des Codes. Für das Arbeiterbeispiel bedeutet dies, dass\nes eine Funktion names gehälter_erhöhen() geben wird, welche nur dafür Zuständig ist über die Arbeiter der\nListe zu iterieren. Diese Funktions erhält zwei Eingabeparameter: Eine Liste mit Arbeiters und der eigentliche\nGehaltserhöhung.\nZusätzlich wird es eine Funktion gehalt_erhöhen() implementiert, welche anschließend nur zur Aufgabe hat, das Gehalt eines einzelnen\nArbeiters zu erhöhen.")]),t("center",[t("b",[e._v("2. Daten sind Immutable")])]),t("p",[e._v('Durch den Funktionsaufruf von gehalt_erhöhen() wird kein Wert des originalen Arrays verändert. Immutable bedeutet,\ndass es keine Funktion geben kann, welche die Daten auf irgendeine weise verändern kann. Im OOP-Ansatz ist es übelich den\nZustand oder "state" eines Objektes beliebig zu verändern. Im FP-Ansatz hingegen werden nur Kopien der veränderten Daten\nerzeugt, mit denen im Verlauf des Programmes weiter gearbeitet wird. Der originale "state" in einem funktionalen Programm\nbleibt somit erhalten.\nDies hat zum Vorteile das einerseits ein Funktionsaufruf auf den selben Daten in jedem Fall den selben Output besitzt,\nzum anderen kann der Zustand so, falls gewünscht, über den gesamten Programmablauf verfolgt werden. Auch dieses\nKonzept trägt zur Lesbarkeit und Wartbarkeit des Codes bei.')]),t("center",[t("b",[e._v("3. Funktionen sind rein (Pure)")])]),t("p",[e._v("Funktionen verhalten sich im funktionalen Ansatz ähnlich wie mathemetische Funktionen. Bei einer mathematischen Funktion\nwird ein oder mehrere Eingabewerte genau einem Ausgabewert zugeordnet. Egal wie oft diese Funktion mit den selben\nEingabewerten berechnet wird, sie führt immer zu dem selben Ergebnis.\nDies trifft auch auf die Funktionen im funktionalen Ansatz zu: Mit den selben Eingabeparametern erhält der Aufrufer\njedesmal den selben Rückgabewert. Dabei geht es vor allem darum, dass Funktionsaufrufe nicht von dem globalen State\nder Applikation abhängen sollen, welcher sich zur Laufzeit ändern kann. Ein Funktionsaufruf muss unabhängig vom State\nzu jeder Zeit vorhersagbar sein.")]),e._m(6),t("center",[t("b",[e._v("4. Funktionen sind erste Klasse (First-Class)")])]),t("p",[e._v("Dieses Konzept wird nicht nur von rein funktionalen Programmiersprachen genutzt (z.b Javascript und PHP), ist allerdings\nunabdingbar für den funktionalen Ansatz. First-Class sind Funktionen, welcher einer Variable im Programm zugeordnet werden\nkönnen. Dadurch können Funktionen wie ein normaler Datentyp behandelt werden und zugleich im Verlauf des Programmes ausgeführt\nwerden.")]),t("p",[e._v("Ebenfalls wird es dadurch möglich eine Funktion einer anderen Funktion als Übergabeparameter zu übergeben. Auch wird es\ndadurch möglich Funktionen als Rückgabewert zu verwenden. So ist es beispielsweise möglich eine Filterfunktion zu erstellen,\nwelche als Parameter eine Funktion übergeben bekommt. Die übergebene Funktion entscheidet dann, ob Werte den Filter passieren\noder aussortiert werden.")]),e._m(7),e._m(8),e._m(9),e._m(10),e._m(11),e._m(12),e._m(13),e._m(14),t("p",[e._v("--------------\x3e")]),t("p",[e._v("Auf dieser Zeitleiste könnten Werte als Events dargestellt werden, um zu verdeutlichen das diese Werte\nüber einen bestimmten Zeitraum emitted worden sind. Für das obere Beispiel würde eine Zeitleiste mit Events\nfolgendermaßen aussehen:")]),t("p",[e._v("---1---2---3--\x3e")]),t("p",[e._v("Über einen bestimmten Zeitraum wurden also Events auf einem Stream ausgegeben. Da nach der 3 das Ende des\nArrays erreicht ist, endet (completed) der Stream nach diesem Event. Dies wird durch einen Senkrechten Strich\nin der Zeitleiste dargestellt.")]),t("p",[e._v("---1---2---3--|->")]),e._m(15),e._m(16),t("p",[e._v('Dieses Designpattern wird auch Observerpattern genannt, was sich vermutlich schon alleine vom Namen "Observable" ableiten ließ.\nDie untere Abbildung zeigt wie das Observerpattern in UML-Schreibweise aussieht.')]),e._m(17),e._m(18),t("p",[e._v("Das Observable ist ein Konstrukt mit der Aufgabe, die abonnierten Observer über neu erzeugte Werte zu informieren. Die Werte\nselbst stammen dabei von einem Producer, welcher im inneren des Observables Werte generiert.")]),e._m(19),t("p",[e._v("In diesem Beispiel wird ein Stream von Klicks auf einen Button erstellt. Der Producer des Stream ist in diesem Fall das Klickevent des\nKnopfes. Ein Observable ist also das bindeglied zwischen dem Producer, welcher die eigentlichen Werte emitted und den abonierten Observern,\nwelche die emitteten Werte konsumieren. RxJS biete viele Funktionen an, um aus einer Variablen oder einer Eventsource ein Observable mit dem\ndazu passendem Producer zu erstellen:")]),e._m(20),e._m(21),t("p",[e._v("Die Frage die man sich jetzt stellen kann, ist die, welchen Vorteil die Verwendung von Observables beziehungsweise Streams hat.\nÜber ein Array kann auch mit einer Schleife iteriert werden oder von einer Eventsource muss in der Regel kein Stream erstellt werden\num diesen auszuwerten. Das Ware Potential von RxJS und anderen reaktiven Bibliotheken liegt in der Bereitstellung der Operatoren, welche\nauf den Stream angewendet werden können.")]),e._m(22),e._m(23),t("p",[e._v("Im Diagramm würden die beiden Streams nun so aussehen:")]),e._m(24),e._m(25),e._m(26),e._m(27),t("p",[e._v("Der fold() Operator hält im ersten Parameter der übergeben Funktion (accumulator) den State. In dem zweiten Parameter (current) wird der\nvom Stream emittete Wert entgegen genommen. Anschließend muss in der Funktion lediglich der derzeitige Wert auf den State addiert werden.\nIn diesem Beispiel wurden nur Zahlen addiert, allerdings können auch komplexe Objekte oder sogar Streams selbst emitted werden.\nAnstatt das Event auf eine '1' zu mappen, könnte das Event ebensogut auf ein JSON Objekt gemapped werden:")]),e._m(28),e._m(29),e._m(30),e._m(31),e._m(32),e._m(33),e._m(34),e._m(35)],1)},r,!1,null,null,null);n.default=s.exports},65:function(e,n,t){e.exports=t.p+"assets/img/Observer_w_update.47f07abf.svg"}}]);