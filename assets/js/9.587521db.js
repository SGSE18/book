(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{100:function(e,n,r){e.exports=r.p+"assets/img/rest6.59a08d89.png"},101:function(e,n,r){e.exports=r.p+"assets/img/rest5.2b77a5b6.png"},102:function(e,n,r){e.exports=r.p+"assets/img/rest4.91a92ab0.png"},103:function(e,n,r){e.exports=r.p+"assets/img/rest3.3782e0eb.png"},104:function(e,n,r){e.exports=r.p+"assets/img/rest2.04fda497.png"},105:function(e,n,r){e.exports=r.p+"assets/img/rest1.36eade60.png"},106:function(e,n,r){e.exports=r.p+"assets/img/serverpush.22d384e7.gif"},107:function(e,n,r){e.exports=r.p+"assets/img/grpc.b52156ef.svg"},108:function(e,n,r){e.exports=r.p+"assets/img/eventloop.d422042c.png"},213:function(e,n,r){"use strict";r.r(n);var t=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"backend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#backend","aria-hidden":"true"}},[e._v("#")]),e._v(" Backend")]),t("h2",{attrs:{id:"node-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js","aria-hidden":"true"}},[e._v("#")]),e._v(" Node.js")]),t("h3",{attrs:{id:"allgemein"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#allgemein","aria-hidden":"true"}},[e._v("#")]),e._v(" Allgemein")]),t("p",[e._v("Node.js ist eine Plattform, die es ermöglicht JavaScript serverseitig laufen zu lassen und basiert auf Google's JavaScript-Laufzeitumgebung V8. V8 wurde ursprünglich für Google Chrome entwickelt und bietet daher eine schnelle und ressourcensparende Ausführung von JavaScript-Code, mithilfe der eine große Anzahl von parallelen Netzwerkverbindungen ermöglicht wird. "),t("a",[t("a",{attrs:{href:"#ref_DAY14"}},[e._v("[DAY14]")])])]),t("h3",{attrs:{id:"npm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm","aria-hidden":"true"}},[e._v("#")]),e._v(" NPM")]),t("p",[e._v("NPM ist ein Paket-Manager für JavaScript-Pakete und das weltgrößte Software-Register. Mit NPM können Pakete installiert, geteilt und Abhängigkeiten in Projekten gemanagt werden. "),t("a",[t("a",{attrs:{href:"#ref_NPM18"}},[e._v("[NPM18]")])]),e._v("\nDer Paket-Manager wird automatisch mit Node.js mitinstalliert und von diesem in großem Maße eingebunden. Um ein Paket zu installieren, muss lediglich der entsprechende Befehl auf der Kommandozeile ausgeführt werden:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install libraryname\n")])]),t("p",[e._v("Daraufhin ist es möglich über den "),t("code",[e._v("require")]),e._v("-Befehl die Bibliothek in das Node.js-Projekt einzubinden:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var lib = require('libraryname');\n")])]),t("p",[e._v("Mithilfe von NPM fällt die Entwicklung mit Node.js wesentlich leichter, da sehr simpel und schnell vorhandene Module installiert und genutzt oder eigene Bibliotheken verteilt werden können.")]),t("h3",{attrs:{id:"vorteile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vorteile","aria-hidden":"true"}},[e._v("#")]),e._v(" Vorteile")]),t("h4",{attrs:{id:"javascript-end-to-end"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-end-to-end","aria-hidden":"true"}},[e._v("#")]),e._v(" JavaScript End-To-End")]),t("p",[e._v("Durch große Fortschritte in der Ausführungsgeschwindigkeit, sind mittlerweile auch Skriptsprachen für serverseitige Anwendungen geeignet. Der Großteil der Web-Entwickler ist bereits mit JavaScript und der einhergehenden asynchronen Programmierung vertraut, wodurch die Einarbeitungszeit in Node.js minimal bleibt.\nDadurch, dass auf Client und Server JavaScript läuft, wird außerdem der Kontext-Wechsel in der Entwicklung reduziert und es kann sogar Code zwischen Server und Client geteilt werden. "),t("a",[t("a",{attrs:{href:"#ref_HOTA14"}},[e._v("[HOTA14]")])])]),t("h4",{attrs:{id:"event-driven-scalability"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#event-driven-scalability","aria-hidden":"true"}},[e._v("#")]),e._v(" Event-Driven Scalability")]),t("p",[e._v("Node.js benutzt einen einzigen Thread, um Netzwerk-Anfragen abzuarbeiten, indem ein Event-Model genutzt wird, welches in der folgenden Abbildung zu sehen ist.")]),t("img",{attrs:{src:r(108),title:"Node.js Eventloop"}}),t("p",[e._v("Single-Threaded EventLoop - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_SLDS16"}},[e._v("[SLDS16]")])])]),t("p",[e._v("Das Nutzen eines einzigen Threads hat den Vorteil, dass es im Gegensatz zu einem Multi-Thread-System ressourcensparender ist und kein Aufwand in die Implementierung von Ressource-Lock-Mechanismen gesteckt werden muss, da alle Anfragen nacheinander abgearbeitet werden. Hierdurch muss das System nicht darauf warten, dass eine Ressource freigegeben wird und kann so die Prozessorleistung effizienter verwenden. Mithilfe dieses Event-Models sind Node.js-Webserver somit in der Lage effizienter zu skalieren als Multi-Thread-Webserver."),t("br"),t("a",[t("a",{attrs:{href:"#ref_DAY14"}},[e._v("[DAY14]")])])]),t("h4",{attrs:{id:"erweiterbarkeit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#erweiterbarkeit","aria-hidden":"true"}},[e._v("#")]),e._v(" Erweiterbarkeit")]),t("p",[e._v("Dank der großen Beliebtheit, der sich Node.js in den letzten Jahren erfreut, gibt es eine große Entwicklercommunity, die kontinuierlich neue Module veröffentlicht. Diese Module können mithilfe von NPM simpel und schnell installiert und genutzt werden.")]),t("h3",{attrs:{id:"nachteile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nachteile","aria-hidden":"true"}},[e._v("#")]),e._v(" Nachteile")]),t("h4",{attrs:{id:"nur-experimenteller-multi-threading-support"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nur-experimenteller-multi-threading-support","aria-hidden":"true"}},[e._v("#")]),e._v(" Nur experimenteller Multi-Threading-Support")]),t("p",[e._v("Der ausgeführte JavaScript Code auf einem Node.js-Webserver läuft in der LTS-Version bisher nur Single-Threaded. Wenn in dieser Version multiple Threads genutzt werden sollen, müssen also auch multiple Prozesse eingesetzt werden, was sich mit Child-Prozessen bewerkstelligen lässt. "),t("a",[t("a",{attrs:{href:"#ref_NODE18"}},[e._v("[NODE18]")])])]),t("p",[e._v("Seit der Version 10.5, die Ende Juni 2018 herausgekommen ist, enthält Node.js auch nativ Multi-Threading-Support, welcher sich allerdings noch in einer experimentellen Phase befindet.\nEine weitere Möglichkeit zur Umsetzung multipler Threads ist das Einsetzen von JXCore "),t("a",[t("a",{attrs:{href:"#ref_JXC18"}},[e._v("[JXC18]")])]),e._v(", welches eine Erweiterung von Node.js ist und unter anderem speziell für den Multi-Thread-Support entwickelt wurde.")]),t("h2",{attrs:{id:"kommunikation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kommunikation","aria-hidden":"true"}},[e._v("#")]),e._v(" Kommunikation")]),t("p",[e._v("In dem folgenden Abschnitt werden verschiedene Methoden zur Umsetzung einer Netzwerk-API erläutert. Es werden Alleinstellungsmerkmale aufgeführt, sowie Vor- und Nachteile beschrieben. Zum Abschluss des Kapitels werden die Technologien einander gegenübergestellt und jeweils passende Anwendungsgebiete präsentiert.")]),t("h3",{attrs:{id:"grpc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#grpc","aria-hidden":"true"}},[e._v("#")]),e._v(" gRPC")]),t("h4",{attrs:{id:"allgemein-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#allgemein-2","aria-hidden":"true"}},[e._v("#")]),e._v(" Allgemein")]),t("p",[e._v("gRPC ist ein von Google entwickeltes modernes, performantes Open Source RPC (Remote Procedure Call) Framework, welches innerhalb vieler verschiedener Umgebungen laufen kann. "),t("a",[t("a",{attrs:{href:"#ref_GRPC18a"}},[e._v("[GRPC18a]")])])]),t("p",[e._v("Mithilfe von gRPC kann eine Client-Anwendung direkt Methoden einer Server-Anwendung aufrufen, als wäre es ein lokales Objekt. Hierzu wird ein gRPC-Server und ein oder mehrere gRPC-Clients implementiert. Der Server bietet hierbei dieselben Methoden an, wie der Client, wobei ein Client-Methodenaufruf automatisch zur Aufrufung der Server-Methode führt (siehe folgende Abbildung).\nDer Server und Client sind hierbei sprachunabhängig voneinander, was es ermöglicht, dass die Entwicklung eines neuen Clients oder Servers höchst flexibel bleibt. "),t("a",[t("a",{attrs:{href:"#ref_GRPC18b"}},[e._v("[GRPC18b]")])])]),t("img",{attrs:{src:r(107),title:"gRPC Methodenaufrufe",height:"200"}}),t("p",[e._v("Abbildung entnommen aus "),t("a",[t("a",{attrs:{href:"#ref_GRPC18b"}},[e._v("[GRPC18b]")])])]),t("p",[e._v("Besonders hervorstechende Merkmale von gRPC sind die Nutzung von HTTP/2 und Protocol Buffers.")]),t("h4",{attrs:{id:"http-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-2","aria-hidden":"true"}},[e._v("#")]),e._v(" HTTP/2")]),t("p",[e._v("HTTP/2 ist der Nachfolger von HTTP/1.1 und wurde 2015 veröffentlicht.\nDurch das neue Protokoll wird die Latenz bei der Kommunikation zwischen Client und Server verringert, welches zu einer schnelleren Datenübermittlung führt.\nDie größten Veränderungen gegenüber des Vorgängers können in die folgenden vier Punkte aufgeteilt werden.")]),t("h5",{attrs:{id:"server-push"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#server-push","aria-hidden":"true"}},[e._v("#")]),e._v(" Server Push")]),t("p",[e._v('"Server Push" ermöglicht dem Server von sich aus Daten an den Client zu senden, eine sogenannte "bidirektionale Kommunikation". Dies steht gegenüber dem Prinzip von HTTP/1, bei dem die Kommunikation "Pull only" ablief und nur vom Client gestartet werden konnte. Mithilfe dieser Funktionalität wird die Netzwerk-Kommunikation beschleunigt, indem unnötige Client-Anfragen und somit Paketumlaufzeit (Round Trip Time) eingespart werden kann. Sinnvoll ist dies vor allem, damit der Server bei dem initialen Seitenaufruf Dateien an den Browser mitsenden kann, die er sowieso zur Anzeige der Seite benötigt (siehe folgende Abbildung).'),t("br"),t("a",[t("a",{attrs:{href:"#ref_ZIM17"}},[e._v("[ZIM17]")])])]),t("img",{attrs:{src:r(106),title:"Server Push"}}),t("p",[e._v("Abbildung entnommen aus "),t("a",[t("a",{attrs:{href:"#ref_ZIM17"}},[e._v("[ZIM17]")])])]),t("p",[e._v("Ein Nachteil kann durch den Server Push auftreten, wenn die Funktionalität falsch eingesetzt wird. Dies kann vorkommen, wenn ein Server Push vor dem Seitenrendering genutzt wird, was die Aufbauzeit der Seite verlangsamt, oder wenn ein Server Push Daten absendet, die der Client bereits gecachet hatte und somit nicht noch einmal benötigte. Damit es nicht zu solchen Problemen kommt, ist es notwendig, dass der Entwickler sich an sinnvolle Strategien für einen Server-Push hält.\n"),t("a",[t("a",{attrs:{href:"#ref_ZIM17"}},[e._v("[ZIM17]")])])]),t("h5",{attrs:{id:"kommunikation-auf-einem-kanal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kommunikation-auf-einem-kanal","aria-hidden":"true"}},[e._v("#")]),e._v(" Kommunikation auf einem Kanal")]),t("p",[e._v("Die Kommunikation zwischen Browser und Server wird mit HTTP/2 über nur einen einzigen Kanal abgewickelt. In der Vorgängerversion wurden mehrere Verbindungen gleichzeitig aufgebaut, was zu einem Overhead und somit Performanceeinbußen führt.\n"),t("a",[t("a",{attrs:{href:"#ref_GRIG13"}},[e._v("[GRIG13]")])])]),t("h5",{attrs:{id:"stream-priorisierung"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-priorisierung","aria-hidden":"true"}},[e._v("#")]),e._v(" Stream Priorisierung")]),t("p",[e._v("Aufgrund der Reduzierung auf nur einen einzigen Kanal, ist es nun wichtiger in welcher Reihenfolge die Daten geladen werden. Mit HTTP/2 ist der Browser in der Lage dem Server mitzuteilen, welche der Dateien für ihn die höchste Priorität haben, damit er diese zuerst vom Server gesendet bekommt.\n"),t("a",[t("a",{attrs:{href:"#ref_GRIG13"}},[e._v("[GRIG13]")])])]),t("h5",{attrs:{id:"kompression-des-headers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kompression-des-headers","aria-hidden":"true"}},[e._v("#")]),e._v(" Kompression des Headers")]),t("p",[e._v("Weiterhin ermöglicht HTTP/2 die Kompression des Headers. Der HTTP-Header muss bei jeder Anfrage mitgesendet werden und durch die Kompression kann so auf Dauer eine Menge an Daten eingespart werden.\n"),t("a",[t("a",{attrs:{href:"#ref_GRIG13"}},[e._v("[GRIG13]")])])]),t("h4",{attrs:{id:"protocol-buffers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#protocol-buffers","aria-hidden":"true"}},[e._v("#")]),e._v(" Protocol Buffers")]),t("p",[e._v("Protocol Buffers sind von Google entworfene sprachunabhängige, plattform-neutrale, erweiterbare Mechanismen, um strukturierte Daten zu serialisieren. Es ähnelt somit XML, ist jedoch kleiner, schneller und einfacher zu lesen.\n"),t("a",[t("a",{attrs:{href:"#ref_GOOG18"}},[e._v("[GOOG18]")])])]),t("p",[e._v("Zu Beginn wird hierzu eine Struktur in einer "),t("em",[e._v(".proto")]),e._v("-Datei angelegt, die beispielsweise wie folgt aussehen könnte:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("message Person {\n  string name = 1;\n  int32 id = 2;\n  bool is_admin = 3;\n}\n")])]),t("p",[e._v("Nachdem die Struktur angelegt wurde, kann der Protocol-Buffer-Compiler "),t("em",[e._v("protoc")]),e._v(" genutzt werden, um eine Klasse für die gewünschte Programmiersprache zu generieren. Mithilfe der generierten Klasse kann auf die Daten mit Setter- und Getter-Methoden zugegriffen und das Objekt anschließend zur Übertragung serialisiert oder geparst werden. "),t("a",[t("a",{attrs:{href:"#ref_GRPC18b"}},[e._v("[GRPC18b]")])])]),t("h4",{attrs:{id:"designprinzipien"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#designprinzipien","aria-hidden":"true"}},[e._v("#")]),e._v(" Designprinzipien")]),t("p",[e._v("Zum Verständnis des Frameworks definierte Google während der Entwicklung eine Reihe an Prinzipien und Anforderungen, die gRPC prägen und einiges über die Funktionalitäten des Frameworks aussagen.\n"),t("a",[t("a",{attrs:{href:"#ref_GRPC18c"}},[e._v("[GRPC18c]")])])]),t("p",[t("strong",[e._v("Services statt Objekten, Messages statt Referenzen")]),e._v(" -\nEs soll die Mikroservice-Philosophie und das Nutzen der Proto-Buffer-Messages beworben werden, damit kein falsches Verständnis von Objekten und den Netzwerkeinschränkungen aufkommt. Auch wenn gRPC eine performante Kommunikation bietet, sollte an die Tücken einer Netzwerkanwendung gedacht und nicht so gearbeitet werden, als wären alle Objekte lokal verfügbar.")]),t("p",[t("strong",[e._v("Abdeckung und Simplizität")]),e._v(" -\nDas Framework sollte auf jeder beliebten Entwicklungsplattform verfügbar und leicht zu benutzen sein. Außerdem sollte das System auf performancelimitierten Geräten laufen können.")]),t("p",[t("strong",[e._v("Kostenlos und offen")]),e._v(" -\nDie fundamentalen Features sollen kostenlos und für alle zur Verfügung stehen. Alle Komponenten sollen als Open Source und mit Lizenzen zur freien Anpassung veröffentlicht werden.")]),t("p",[t("strong",[e._v("Interoperabel und Reichweite")]),e._v(" -\nDas Protokoll muss in der Lage sein verschiedene Internet-Infrastrukturen zu traversieren.")]),t("p",[t("strong",[e._v("Genereller Zweck und Performance")]),e._v(" -\nDas System sollte auf eine breite Klasse von Use-Cases passen, während so wenig Performance wie möglich, im Vergleich zu einem System für einen spezifischen Use-Case, verloren wird.")]),t("p",[t("strong",[e._v("Layered")]),e._v(" -\nHauptfacetten des Systems müssen unabhängig voneinander entwickelt werden können.")]),t("p",[t("strong",[e._v("Payload Agnostik")]),e._v(" -\nTrotz des Standard-Payloads, der Protocol Buffer nutzt, müssen auch andere Typen wie JSON oder XML unterstützt werden. Außerdem muss das System Payload-Kompression für variable Use-Cases unterstützen.")]),t("p",[t("strong",[e._v("Streaming")]),e._v(" -\nEine Streaming-Funktionalität muss geboten werden, da viele Systeme Streaming benötigen, um große Daten zu übertragen oder um Daten live zu aktualisieren.")]),t("p",[t("strong",[e._v("Blocken und Nicht-Blocken")]),e._v(" -\nEs muss sowohl asynchrones, als auch synchrones Abarbeiten von Nachrichten von Client und Server unterstützt werden. Dies ist essentiell für die Skalierung und zum Abarbeiten von Streams.")]),t("p",[t("strong",[e._v("Abbruch und Timeout")]),e._v(" -\nManche Operationen sind ressourcenaufwendig und haben eine lange Laufzeit. Durch den Abbruch von Operationen kann der Server notfalls Ressourcen freigeben, die durch einen einzelnen Client blockiert werden. Zusätzlich soll der Client ein Timeout angeben können, damit der Server die Operationen einem Zeitfenster entsprechend anpassen kann.")]),t("p",[t("strong",[e._v("Lameducking")]),e._v(" -\nServer müssen in der Lage sein in einem laufenden Übergang herunterzufahren. Dies bedeutet, dass keine neuen Anfragen mehr angenommen, aber die bestehenden Anfragen noch abgearbeitet werden.")]),t("p",[t("strong",[e._v("Datenflusssteuerung")]),e._v(" -\nRessourcen und Netzwerk-Kapazität sind meist im Ungleichgewicht zwischen Client und Server. Mithilfe von Datenflusssteuerung wird die Geschwindigkeit der Datenübertragung zwischen einem Client und dem Server so angepasst, dass optimal mit Buffern gearbeitet werden kann.")]),t("p",[t("strong",[e._v("Pluggable")]),e._v(" -\nFeatures für Sicherheit, Health-Checks, Load-Balancing, Monitoring, Tracing und Logging sollen alle über Erweiterungen aktivierbar sein und eine Beispielimplementierung bieten.")]),t("p",[t("strong",[e._v("Erweiterungen als APIs")]),e._v(" -\nErweiterungen die eine Zusammenarbeit von Services benötigen, sollten auf APIs setzen, anstatt das Protokoll zu erweitern.")]),t("p",[t("strong",[e._v("Metadaten-Austausch")]),e._v(" -\nIn manchen Fällen, wie bei der Authentifizierung, müssen Metadaten ausgetauscht werden, die nicht im Standardinterface eines Services beinhaltet sind. Diese Features müssen individuell entwickelbar sein.")]),t("p",[t("strong",[e._v("Standardisierte Status Codes")]),e._v(" -\nEs muss eine bestimmte Anzahl von standardisierten Status Codes geben, damit der Client entsprechend der Antwort des Servers reagieren kann. Falls ein System aussagekräftigere Status Codes benötigt, können diese zusätzlich implementiert und über den Metadaten-Austausch kommuniziert werden.")]),t("h4",{attrs:{id:"vorteile-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vorteile-2","aria-hidden":"true"}},[e._v("#")]),e._v(" Vorteile")]),t("h5",{attrs:{id:"performance-und-geringe-datengrosse"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#performance-und-geringe-datengrosse","aria-hidden":"true"}},[e._v("#")]),e._v(" Performance und geringe Datengröße")]),t("p",[e._v("Der Schwerpunkt von gRPC liegt darauf eine performante Netzwerk-Kommunikation zu ermöglichen. HTTP/2 und Proto Buffer sorgen dafür, dass die Anzahl der Anfragen und die zu übermittelnden Daten in der Größe reduziert und gleichzeitig die Geschwindigkeit erhöht werden kann. Diese Eigenschaften prägen gRPC somit als ein Kommunikations-Protokoll, welches besonders geeignet für Anwendungen ist, die den Hauptfokus auf eine hohe Performance legen.")]),t("h5",{attrs:{id:"simple-integration-von-erweiterungen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#simple-integration-von-erweiterungen","aria-hidden":"true"}},[e._v("#")]),e._v(" Simple Integration von Erweiterungen")]),t("p",[e._v("Das Pluggable-Prinzip ermöglicht es vorgefertigte Funktionen für Authentifizierung, Tracing, Load-Balancing und Health-Checking schnell und simpel zu integrieren.")]),t("h4",{attrs:{id:"nachteile-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nachteile-2","aria-hidden":"true"}},[e._v("#")]),e._v(" Nachteile")]),t("h5",{attrs:{id:"browser-support"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#browser-support","aria-hidden":"true"}},[e._v("#")]),e._v(" Browser-Support")]),t("p",[e._v("Zurzeit stehen verschiedene Versionen von gRPC-Bibliotheken zur Verfügung, um gRPC vom Browser aus einzusetzen. Hierzu zählen gRPC-js, gRPC-Web und gRPC-Web-Client. Leider verfügen alle drei Bibliotheken über technische Limitierungen, wie Browserinkompatibilität, wodurch eine native gRPC-Kommunikation nicht möglich ist und nur über einen Proxydienst abgehandelt werden kann. Diese Probleme sollen zwar in naher Zukunft durch nativen Browsersupport behoben werden, jedoch muss aktuell noch auf eine Proxy-Lösung zurückgegriffen werden.\n"),t("a",[t("a",{attrs:{href:"#ref_GWEB18"}},[e._v("[GWEB18]")])]),t("a",[t("a",{attrs:{href:"#ref_GJS18"}},[e._v("[GJS18]")])]),t("a",[t("a",{attrs:{href:"#ref_GWP18"}},[e._v("[GWP18]")])])]),t("h3",{attrs:{id:"rest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest","aria-hidden":"true"}},[e._v("#")]),e._v(" REST")]),t("h4",{attrs:{id:"allgemein-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#allgemein-3","aria-hidden":"true"}},[e._v("#")]),e._v(" Allgemein")]),t("p",[e._v("Representational State Transfer (REST) ist das am meisten verbreitete und genutzte Mittel, um Netzwerk-APIs zu realisieren. Vorgestellt wurde die Technologie im Jahr 2000 von Roy Thomas Fielding im Rahmen seiner Dissertation und hat sich seitdem durchgesetzt.  "),t("a",[t("a",{attrs:{href:"#ref_RITS17"}},[e._v("[RITS17]")])]),e._v("\nBei REST handelt es sich um einen Architektur-Style, welcher einen Leitfaden bilden soll, der vorgibt, wie eine zustandslose Kommunikation zwischen Client und Server ablaufen sollte.")]),t("h5",{attrs:{id:"nutzung"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nutzung","aria-hidden":"true"}},[e._v("#")]),e._v(" Nutzung")]),t("p",[e._v("Die Kommunikation zwischen Server und Client geschieht in dem Fall von REST mithilfe von Daten, die, wie der Name andeutet, einen Zustand wiederspiegeln.\nUm eine bestimmte Ressource anzufragen oder abzusenden sendet der Client eine HTTP-Anfrage an eine bereitgestellte URL. Die Art der HTTP-Anfrage hängt davon ab was für eine Art von Operation auf dem Server ausgeführt werden soll.")]),t("table",[t("thead",[t("tr",[t("th",[t("strong",[e._v("Anfrage-Art")])]),t("th",[t("strong",[e._v("Aktion")])])])]),t("tbody",[t("tr",[t("td",[e._v("GET")]),t("td",[e._v("Zugriff auf eine Ressource im Lesemodus")])]),t("tr",[t("td",[e._v("POST")]),t("td",[e._v("Senden einer neuen Ressource zum Server")])]),t("tr",[t("td",[e._v("PUT")]),t("td",[e._v("Aktualisieren einer vorhandenen Ressource")])]),t("tr",[t("td",[e._v("DELETE")]),t("td",[e._v("Löschen einer vorhandenen Ressource")])]),t("tr",[t("td",[e._v("HEAD")]),t("td",[e._v("Dient der Anfrage, ob eine Ressource existiert")])]),t("tr",[t("td",[e._v("OPTIONS")]),t("td",[e._v("Gibt eine Liste von möglichen Operationen auf einer Ressource zurück")])])])]),t("p",[t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("p",[e._v("Der Client sendet hierbei Zustandsrepräsentationen über Dateiformate wie JSON oder XML oder über URL-Parameter an den Server und der Server antwortet dementsprechend wieder mit einer Zustandsrepräsentation seinerseits.")]),t("h5",{attrs:{id:"prinzipien"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prinzipien","aria-hidden":"true"}},[e._v("#")]),e._v(" Prinzipien")]),t("p",[e._v("Um eine effiziente Architektur zu erreichen, definiert REST die folgenden sechs aufeinander aufbauenden Grundprinzipien, die F. Doglio in "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])]),e._v(" beschreibt.")]),t("h6",{attrs:{id:"client-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#client-server","aria-hidden":"true"}},[e._v("#")]),e._v(" Client-Server")]),t("p",[e._v("Das erste Grundprinzip behandelt die Netzwerk-Architektur Client-Server und damit auch die Separierung der Zuständigkeiten. Der Server bietet ein bestimmtes Set von Services bzw. Funktionalitäten an, welche vom Client aufgerufen werden können. Hierdurch stellt der Server Daten bereit, welche der Client abrufen und daraufhin darstellen und aufarbeiten kann. Mithilfe dieser Aufteilung können Client und Server unabhängig voneinander entwickelt werden und ermöglicht dadurch gleichzeitig, dass verschiedene Client-Applikationen für dieselben Server-Services genutzt werden können.")]),t("img",{attrs:{src:r(105),title:"Client-Server"}}),t("p",[e._v("Client-Server-Architektur - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("h6",{attrs:{id:"stateless"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stateless","aria-hidden":"true"}},[e._v("#")]),e._v(" Stateless")]),t("p",[e._v("Stateless bezeichnet die Eigenschaft, dass der Server keinen Status der Clients hält, sondern dass der Client bei jeder Anfrage alle zur Verständnis benötigten Daten an den Server senden muss.")]),t("p",[e._v("Durch diese Eigenschaft verbessern sich einige Punkte an der Architektur:")]),t("ul",[t("li",[e._v("Die "),t("strong",[e._v("Überwachung")]),e._v(" des Systems fällt leichter, wenn alle benötigten Informationen in der jeweiligen Anfrage enthalten sind.")]),t("li",[e._v("Das System "),t("strong",[e._v("skaliert")]),e._v(" besser, da Ressourcen nach jeder Anfrage direkt wieder freigegeben werden, anstatt den Zustand halten zu müssen.")]),t("li",[e._v("Das System ist "),t("strong",[e._v("verlässlicher")]),e._v(", da bei einem Systemabsturz keine Zustände wiederhergestellt werden müssen, sondern nur das System selbst.")]),t("li",[e._v("Das System ist "),t("strong",[e._v("leichter zu implementieren")]),e._v(", da keine Sessions extra gemanagt werden müssen.")])]),t("img",{attrs:{src:r(104),title:"Stateless"}}),t("p",[e._v("Jede Anfrage enthält alle State-Informationen - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("h6",{attrs:{id:"cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache","aria-hidden":"true"}},[e._v("#")]),e._v(" Cache")]),t("p",[e._v("Eine REST-API sollte die Möglichkeit von Cacheing bieten und Services dementsprechend markieren. Indem Antworten auf Anfragen gecachet werden, kann sich sowohl der Server einige Rechenoperationen sparen, als auch der Client die Daten schneller bereitstellen. Der Cache kann gleichzeitig Client- und Serverseitig genutzt werden, oder auch nur auf einer Seite des Systems. Ein Nachteil durch Cacheing kann auftreten, wenn die Cacheing-Regeln nicht optimal gesetzt sind, was zur Verarbeitung von veralteten Daten führen kann.")]),t("img",{attrs:{src:r(103),title:"Cache"}}),t("p",[e._v("Cache wird von Client und von Server genutzt - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("h6",{attrs:{id:"uniform-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uniform-interface","aria-hidden":"true"}},[e._v("#")]),e._v(" Uniform-Interface")]),t("p",[e._v('Die API sollte so gestaltet sein, dass es einen eindeutigen Identifier für die Services in Form einer URI, wie beispielsweise einer URL, gibt. Der Zugriff auf die Services geschieht durch die HTTP-Anfragemethoden (GET, POST, PUT, DELETE, etc.) und liefert repräsentative Daten mit standardisierten Content-Typen, wie beispielsweise XML, JSON oder HTML, zurück.\nUm durch die verschiedenen Services "navigiert" zu werden, stellt der Server dem Client nach Aufrufen eines Services Hyperlinks zu ähnlichen vorhandenen Services zur Verfügung. Diese Navigationshilfe nennt sich "Hypermedia As The Engine Of Application State (HATEOAS)".')]),t("p",[e._v("Das so geschaffene Interface kann universell von verschiedenen Geräten genutzt werden.\nDies hat zwar den Vorteil, dass man nur eine Schnittstelle pflegen muss, doch kann man als Nachteil anmerken, dass es teilweise performanter sein kann maßgeschneiderte Lösungen für die einzelnen Arten von Endgeräten zu haben.")]),t("img",{attrs:{src:r(102),title:"Uniform-Interface"}}),t("p",[e._v("Verschiedene Client-Arten nutzen gleiches Interface - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("h6",{attrs:{id:"layered-system"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#layered-system","aria-hidden":"true"}},[e._v("#")]),e._v(" Layered System")]),t("p",[e._v('Eine typische REST-API nutzt mehrere System-Layer, um die Logik verschiedener Bausteine voneinander zu entkoppeln. So besteht eine API meist aus einer "Business Logic Layer", einer "Session Information Layer" und einer "Storage Layer". Die Layers nutzen nur die jeweils untere Layer und kommunizieren die Ausgabe an die obere Layer. Hierdurch kann das Gesamtsystem simplifiziert werden und eine Weiterentwicklung vereinfachen.')]),t("p",[e._v("Der größte Nachteil an einem solchen System ist, dass es für kleine Systeme eventuell unnötige Komplexität hinzufügt und so die Performance mindert.")]),t("img",{attrs:{src:r(101),title:"Layered System"}}),t("p",[e._v("Multiple Layer innerhalb des Servers vereinfachen die Architektur - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("h6",{attrs:{id:"code-on-demand"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-on-demand","aria-hidden":"true"}},[e._v("#")]),e._v(" Code-On-Demand")]),t("p",[e._v("Code-On-Demand ist das einzige optionale Prinzip von REST. Hierbei geht es um das Prinzip, dass der Server Code bereitstellt, den der Client herunterladen und lokal ausführen kann. Dies bezieht sich meist auf JavaScript oder Java Applets.")]),t("img",{attrs:{src:r(100),title:"Code-On-Demand"}}),t("p",[e._v("Server können Clients Code bereitstellen, der optional lokal auf dem Gerät ausgeführt wird - Abbildung aus "),t("a",[t("a",{attrs:{href:"#ref_DOGL17"}},[e._v("[DOGL17]")])])]),t("h4",{attrs:{id:"vorteile-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vorteile-3","aria-hidden":"true"}},[e._v("#")]),e._v(" Vorteile")]),t("h5",{attrs:{id:"bewahrte-losung"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bewahrte-losung","aria-hidden":"true"}},[e._v("#")]),e._v(" Bewährte Lösung")]),t("p",[e._v("Durch seine große Popularität und mittlerweile jahrelange Nutzung ist REST eine bewährte Lösung für die Netzwerk-Kommunikation. Es lassen sich leicht Frameworks und Tools finden, die die Implementierung einer REST-API so simpel wie möglich gestalten und frei von Anfangsschwierigkeiten sind, wie sie viele neuere Technologien noch haben.")]),t("h5",{attrs:{id:"methoden-leitfaden"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#methoden-leitfaden","aria-hidden":"true"}},[e._v("#")]),e._v(" Methoden-Leitfaden")]),t("p",[e._v("Durch HATEOAS bietet REST einen leicht zu folgenden Leitfaden für Clients an. Eine ausgereifte Umsetzung ermöglicht eine sich selbst dokumentierende API, bei der der Client auf keine externe Hilfe angewiesen ist.")]),t("h4",{attrs:{id:"nachteile-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nachteile-3","aria-hidden":"true"}},[e._v("#")]),e._v(" Nachteile")]),t("h5",{attrs:{id:"fehlerhafte-rest-implementierungen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fehlerhafte-rest-implementierungen","aria-hidden":"true"}},[e._v("#")]),e._v(" Fehlerhafte REST-Implementierungen")]),t("p",[e._v('Viele Leute haben ein falsches Verständnis davon was REST bedeutet und kennen die Kernprinzipien nicht. Aufgrund dessen geben viele Entwickler ihren APIs den Namen "RESTful", obwohl sie nicht den Prinzipien von REST folgen. So werden beispielsweise oft Cookies benutzt, um States zu halten, was gegen das "Stateless"-Prinzip verstößt. Fielding selbst äußerte sich einige Jahre nach seiner Dissertation dazu, dass er von dem Trend API\'s RESTful zu nennen, obwohl sie lediglich normale RPC API\'s sind, frustriert sei. '),t("a",[t("a",{attrs:{href:"#ref_ROY08"}},[e._v("[ROY08]")])])]),t("h5",{attrs:{id:"overhead-durch-die-prinzipien"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overhead-durch-die-prinzipien","aria-hidden":"true"}},[e._v("#")]),e._v(" Overhead durch die Prinzipien")]),t("p",[e._v("Die Stateless-Eigenschaft einer REST-API sorgt dafür, dass alle benötigten Daten mit jedem Aufruf neu mitgesendet werden müssen. Aufgrund der fehlenden States ist es nicht möglich auf sessionübergreifende Daten zurückzugreifen, was zu einem Overhead bei den Netzwerk-Aufrufen führt, der mit States eingespart werden könnte.")]),t("p",[e._v('Zusätzlich sorgt die "Layered System"-Eigenschaft dazu, dass System teilweise komplexer werden, als sie müssten. Dies führt zu einem Performance- und Speicher-Overhead für kleinere Systeme.')]),t("h3",{attrs:{id:"graphql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graphql","aria-hidden":"true"}},[e._v("#")]),e._v(" GraphQL")]),t("h4",{attrs:{id:"allgemein-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#allgemein-4","aria-hidden":"true"}},[e._v("#")]),e._v(" Allgemein")]),t("p",[e._v("GraphQL ist eine von Facebook entwickelte Query-Sprache und Runtime, die 2015 veröffentlicht wurde. Mithilfe von GraphQL können Clients präzise definieren welche Daten sie von der API anfordern. Durch diese Methode lässt sich die Anzahl der Abfragen einschränken und gleichzeitig der Daten-Overhead minimieren, da der Client immer nur genau die Daten erhält, die angefordert wurden. "),t("a",[t("a",{attrs:{href:"#ref_GQL18"}},[e._v("[GQL18]")])])]),t("p",[e._v("Um GraphQL einzusetzen, wird ein Client, sowie ein Backend benötigt, welche beide mit der Query-Sprache umgehen können. Implementierungen der Technologie stehen auf beiden Seiten in vielen verschiedenen Programmier- und Skriptsprachen zur Verfügung.")]),t("p",[e._v("GraphQL stellt zwischen Client und Server eine zusätzliche Schicht dar, welche die Aufgabe der Kommunikation übernimmt. Es geschieht schnell, dass man die Technologie mit einer Datenbank-Technologie verwechselt. Tatsächlich handelt es sich aber um eine Query-Sprache für APIs, nicht für Datenbanken. "),t("a",[t("a",{attrs:{href:"#ref_RITS17"}},[e._v("[RITS17]")])]),e._v('\nGraphQL kann hierbei auf Backend-Logik aufgesetzt werden und so Query-Operationen auf den vom Backend gelieferten Daten, bereitstellen. Die Lese-Operationen werden von GraphQL "Queries" genannt und die Erstell- und Bearbeitungs-Operationen nennen sich "Mutationen".')]),t("h4",{attrs:{id:"vorteile-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vorteile-4","aria-hidden":"true"}},[e._v("#")]),e._v(" Vorteile")]),t("h4",{attrs:{id:"graphiql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graphiql","aria-hidden":"true"}},[e._v("#")]),e._v(" GraphiQL")]),t("p",[e._v("GraphiQL ist eine von GraphQL mitgelieferte Oberfläche, um schnell und simpel bereitgestellte Funktionalität auszuprobieren.\nAuf der Oberfläche kann ein Nutzer automatisch die Dokumentation der Schnittstelle einsehen. Anhand dieser Dokumentation weiß der Nutzer welche Queries er ausführen kann und kann diese direkt testen.\nDie Oberfläche nimmt sowohl dem Client-, als auch dem Server-Entwickler somit viel Arbeit ab, indem direkt in der Oberfläche gedebugged werden kann. Der Server-Entwickler kann Fehler in der Ausgabe aufdecken und der Client-Entwickler kann den in der Oberfläche getesteten Code in seine Client-Applikation übernehmen.\nGraphiQL hilft somit immens die Entwicklung zu vereinfachen.")]),t("h5",{attrs:{id:"effiziente-datenabfrage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#effiziente-datenabfrage","aria-hidden":"true"}},[e._v("#")]),e._v(" Effiziente Datenabfrage")]),t("p",[e._v("Der Grund, warum Facebook GraphQL entwickelt hat, war, dass durch die große und stark steigende Nutzeranzahl der Datenverkehr über das Netzwerk immer größer wurde und aktuelle Lösungen die Anfragen nur ineffizient abarbeiten konnte.\n"),t("a",[t("a",{attrs:{href:"#ref_HGQL18"}},[e._v("[HGQL18]")])])]),t("p",[e._v("Somit wurde eine Technologie entwickelt, die die zu übermittelnden Daten auf ein Minimum beschränkt und gleichzeitig die Anzahl der Anfragen so klein wie möglich hält.")]),t("p",[e._v('Die zu übermittelnde Datenmenge kann von GraphQL optimiert werden, indem sogenanntes "Over-Fetching" und "Under-Fetching" verhindert wird. "Over-Fetching" bezeichnet das Abrufen von zu viel Informationen, während "Under-Fetching" das Abrufen von zu wenig Informationen beschreibt, was in den meisten Fällen zu einer zusätzlichen Netzwerk-Anfrage führt. Beide Praktiken sorgen für eine stärkere Netzwerk-Auslastung und führen somit zu Performanceproblemen.')]),t("p",[e._v("Um diese Probleme zu verhindern, erlaubt es GraphQL dem Client die benötigten Daten selbst zu definieren.")]),t("p",[e._v("Wenn man diese Möglichkeit auf einen Use-Case für Facebook anwenden möchte, bietet sich als Beispiel eine Benutzersuche an. Ein normales Benutzerprofil umfasst viele verschiedene Daten. Ein Datensatzausschnitt hieraus könnte wie folgt aussehen:")]),t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"name"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"John Doe"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"location"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"Minden"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"birthday"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"24.02.1997"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"image"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"picture.jpg"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      ...\n    "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),t("p",[e._v("Ein Client, der anhand des Datensatzes eine Benutzersuche implementieren möchte, möchte allerdings nur das Profilbild, den Namen, sowie den Wohnort verwenden, um Vorschläge in der Auto-Vervollständigung anzuzeigen, also sieht seine Anfrage und das entsprechende Ergebnis wie folgt aus:")]),t("p",[t("strong",[e._v("Query:")])]),t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  users"),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    name\n    location\n    image\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),t("p",[t("strong",[e._v("Ergebnis:")])]),t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{attrs:{class:"token property"}},[e._v('"data"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{attrs:{class:"token property"}},[e._v('"users"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"name"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"John Doe"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"location"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"Minden"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),t("span",{attrs:{class:"token property"}},[e._v('"image"')]),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"picture.jpg"')]),e._v("\n    "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    ..."),t("span",{attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),t("p",[e._v("Dem Client ist es somit freigestellt selber festzulegen, welche Daten er benötigt. Bei einer Live-Benutzersuche, die performant bleiben muss, ist es hilfreich nur mit kleinen Objekten arbeiten zu müssen, während eine erweiterte Benutzersuche mit weiteren Filtermöglichkeiten Zugriff auf zusätzliche Eigenschaften benötigt. Beide Anwendungsfälle können mit GraphQL mit derselben Schnittstelle abgedeckt werden, ohne dass ein Mehraufwand für das Backend entsteht.")]),t("p",[e._v("Auch die Anzahl der Anfragen kann mit GraphQL klein gehalten werden, indem der Client die Möglichkeit hat mehrere Anfragen zu kombinieren und somit effektiv nur eine Anfrage über das Netzwerk an den Server senden muss.")]),t("p",[e._v("Als Beispiels-Anwendungsfall kann hier das Vergleichen zweier Profile gesehen werden. Um das Profil eines bestimmten Benutzers zu suchen, wird als Parameter der Name mitgegeben. Damit dieselbe Query zweimal genutzt werden kann, muss vor dem Methodennamen noch ein Alias geschrieben werden, damit die zwei Resultate voneinander zu unterscheiden sind.")]),t("p",[t("strong",[e._v("Query:")])]),t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  firstUser"),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" user(name"),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"John Doe"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    name\n    location\n    birthday\n    image\n    ...\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  secondUser"),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" user(name"),t("span",{attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{attrs:{class:"token string"}},[e._v('"Jane Doe"')]),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    name\n    location\n    birthday\n    image\n    ...\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),t("p",[e._v("Diese zusammengefasste Query kann innerhalb einer einzigen Netzwerk-Anfrage von der API abgehandelt werden, ohne dass die API eine entsprechende Funktion explizit bereitstellen muss. Mithilfe dieser Funktionalität kann GraphQL den Traffic zum API-Server geringhalten.")]),t("h5",{attrs:{id:"viele-unterstutzte-plattformen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#viele-unterstutzte-plattformen","aria-hidden":"true"}},[e._v("#")]),e._v(" Viele unterstützte Plattformen")]),t("p",[e._v("Wie bereits zu Beginn des Kapitels erwähnt, wird GraphQL in vielen verschiedenen Programmiersprachen durch entsprechende Bibliotheken unterstützt.")]),t("table",[t("thead",[t("tr",[t("th",[t("strong",[e._v("Clientseitig")])]),t("th",[t("strong",[e._v("Serverseitig")])])])]),t("tbody",[t("tr",[t("td",[t("ul",[t("li",[e._v("C# / .NET")]),t("li",[e._v("Go")]),t("li",[e._v("Java / Android")]),t("li",[e._v("JavaScript")]),t("li",[e._v("Swift / Objective-C iOS")]),t("li",[e._v("Python")])])]),t("td",[t("ul",[t("li",[e._v("C# / .NET")]),t("li",[e._v("Clojure")]),t("li",[e._v("Elixir")]),t("li",[e._v("Erlang")]),t("li",[e._v("Erlang")]),t("li",[e._v("Go")]),t("li",[e._v("Groovy")]),t("li",[e._v("Java")]),t("li",[e._v("JavaScript")]),t("li",[e._v("PHP")]),t("li",[e._v("Python")]),t("li",[e._v("Scala")]),t("li",[e._v("Ruby")])])])])])]),t("p",[t("a",[t("a",{attrs:{href:"#ref_GQLG18"}},[e._v("[GQLG18]")])])]),t("p",[e._v("Durch die Kompatibilität der GraphQL-Schnittstellen ist es irrelevant welche Sprache für Server oder Client ausgewählt wurde. Unabhängig von der Wahl können Client und Server ohne zusätzliche Konfigurationen miteinander kommunizieren.\nDie Auswahl der Technologie liegt dementsprechend ganz bei dem Entwickler des Clients beziehungsweise des Servers.")]),t("p",[e._v("Zur Einarbeitung in GraphQL auf Basis einer bestimmten Technologie stellt die Webseite "),t("a",{attrs:{href:"https://howtographql.com"}},[e._v("https://howtographql.com")]),e._v(" einen guten Einstiegspunkt dar.")]),t("p",[e._v("Auf der Seite werden verschiedene Software-Stacks für Backend und Frontend vorgestellt und kurze Tutorials für einen ersten Einstieg präsentiert.")]),t("p",[e._v("Eine beliebte Umsetzung von GraphQL bietet "),t("a",{attrs:{href:"https://www.apollographql.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apollo")]),e._v(', da Apollo einen Client "Apollo Client", eine Bibliothek zur Servererstellung "Apollo Server" und einen Gateway "Apollo Engine" bereitstellt. Mithilfe dieser drei Komponenten und den von Apollo gestellten Dokumentationen und Tutorials kann schnell eine End-To-End GraphQL-Anwendung implementiert werden, die dank Apollo Gateway sogar Caching-Funktionalitäten bietet, die mit GraphQL standardmäßig problematisch sind.')]),t("h5",{attrs:{id:"schnelle-funktionalitats-erweiterung"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#schnelle-funktionalitats-erweiterung","aria-hidden":"true"}},[e._v("#")]),e._v(" Schnelle Funktionalitäts-Erweiterung")]),t("p",[e._v("Die so durch GraphQL geschaffene Schnittstelle ist dementsprechend leicht anzupassen. Der Server kann an der Schnittstelle zusätzliche Informationen bereitstellen, ohne dass der Client dazu gezwungen ist seine Anfrage an die zusätzlichen Informationen anzupassen, da er sie einfach ignorieren kann. Ebenso kann der Client sich dazu entscheiden zuvor ungenutzte Daten mit abzurufen und somit neue Funktionalitäten implementieren ohne eine Schnittstellen-Änderung am Server anzufordern. Die Entwicklung von Client und Server ist somit voneinander entkoppelt, was für eine individuellere und schnellere Entwicklung sorgt, die durch kleine Anpassungen in den Queries geregelt werden kann.")]),t("h5",{attrs:{id:"datenbank-agnostik"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#datenbank-agnostik","aria-hidden":"true"}},[e._v("#")]),e._v(" Datenbank-Agnostik")]),t("p",[e._v("GraphQL setzt, wie standardmäßig eine REST-API auch, nicht direkt an der Datenbank an. Daher ist es für die GraphQL-Technologie nicht relevant von welcher Quelle der bereitgestellte Datensatz entstammt.")]),t("p",[e._v("Durch diese Vorgehensweise ist dem Entwickler die Freiheit gegeben zu wählen, welche Art der Datenspeicherung er nutzen möchte. Dies können relationale Datenbanken, als auch NoSQL-Datenbanken sein.")]),t("p",[e._v("Da die Syntax und Herangehensweise von GraphQL jedoch sehr nah an der von gängigen SQL-Datenbanken liegt, existieren auch zahlreiche Bibliotheken, die die Verbindung zwischen der Datenbank und GraphQL erleichtern, wie beispielsweise GraphQL-Sequelize oder PostGraphile.\n"),t("a",[t("a",{attrs:{href:"#ref_GQLS18"}},[e._v("[GQLS18]")])]),t("a",[t("a",{attrs:{href:"#ref_PGL18"}},[e._v("[PGL18]")])])]),t("h4",{attrs:{id:"nachteile-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nachteile-4","aria-hidden":"true"}},[e._v("#")]),e._v(" Nachteile")]),t("h5",{attrs:{id:"caching"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#caching","aria-hidden":"true"}},[e._v("#")]),e._v(" Caching")]),t("p",[e._v("Da GraphQL an einem einzigen POST-Endpunkt arbeitet, ist es schwer Netzwerk-Caching zu betreiben. Caching kann in diesem Fall clientseitig von Bibliotheken wie Apollo oder Relay bereitgestellt werden. Die Problematik hierbei ist jedoch, dass der Client nicht immer wissen kann, wann die Daten aktualisiert wurden und arbeitet somit eventuell mit veralteten Daten. "),t("a",[t("a",{attrs:{href:"#ref_RITS17"}},[e._v("[RITS17]")])])]),t("h5",{attrs:{id:"datei-upload"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#datei-upload","aria-hidden":"true"}},[e._v("#")]),e._v(" Datei-Upload")]),t("p",[e._v('Die GraphQL-Spezifikation beinhaltet aktuell standardmäßig leider keine Möglichkeit um Dateien hochzuladen, da nur mit serialisierbaren Daten gearbeitet werden kann. Als Lösung können Dateien Base64-Decodiert und als String übermittelt werden, was allerdings mehr Speicher und Rechenleistung benötigt oder es muss auf eine Erweiterung in Form einer zusätzlichen REST-API oder GraphQL-Bibliothek, wie beispielsweise "GraphQL-Multipart-Request-Spec" '),t("a",[t("a",{attrs:{href:"#ref_GQLM18"}},[e._v("[GQLM18]")])]),e._v(", gesetzt werden.")]),t("h3",{attrs:{id:"vergleich-der-technologien"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vergleich-der-technologien","aria-hidden":"true"}},[e._v("#")]),e._v(" Vergleich der Technologien")]),t("p",[e._v("Aus den vorangegangenen Kapiteln wird ersichtlich, dass alle Technologien ihre Vor- und Nachteile haben, sowie Spezialisierungen auf bestimmte Anwendungsfälle vorgesehen wurden.\nInnerhalb dieses Abschnittes wird noch einmal ein Vergleich zwischen den Technologien gezogen, um aufzuzeigen, welche Technologie für welchen Anwendungsfall besser und welche weniger gut geeignet ist.")]),t("h4",{attrs:{id:"geschwindigkeit-und-kompression"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#geschwindigkeit-und-kompression","aria-hidden":"true"}},[e._v("#")]),e._v(" Geschwindigkeit und Kompression")]),t("p",[e._v("Das RPC Framework gRPC legt seinen Fokus auf schnelle Kommunikation. HTTP/2 und ProtoBuffer gewähren gRPC einen Geschwindigkeits- und Datenkompressions-Vorteil gegenüber REST, welches mit dem Overhead durch seine Prinzipien, HTTP/1 und dem JSON-Format zu kämpfen hat. Problematisch an REST ist ebenfalls, dass durch generalisierte Schnittstellen große Payloads und oft mehrere Anfragen abgesendet werden müssen, um an die Daten zu kommen, die benötigt werden. GraphQL löst dieses Problem, indem der Client dank Queries nur die Daten zurückgeliefert bekommt, die er auch benötigt, was den Payload und die Anzahl der Anfragen gering hält. Dies geht allerdings mit dem Entfall der Cacheability einher, welche REST nutzt.")]),t("p",[e._v('gRPC bietet somit die meisten Vorteile in Anbetracht von Geschwindigkeit und Kompression. GraphQL bietet den Vorteil des "optimalen Payload" für effiziente Datenübertragung und REST liefert Cacheability auf Client- und Serverseite, die die Anzahl der Anfragen reduzieren kann.')]),t("h4",{attrs:{id:"flexibilitat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flexibilitat","aria-hidden":"true"}},[e._v("#")]),e._v(" Flexibilität")]),t("p",[e._v("GraphQL's Queries ermöglichen es den Clients genau die Daten anzufordern, die benötigt werden und auch mehrere Queries in einer Anfrage zu kombinieren. Mit dieser Eigenschaft schafft es GraphQL mit einer einzigen  Schnittstelle die Anforderungen vieler verschiedenen Clientarten zu erfüllen, welches der Grund für die Entwicklung durch Facebook und deren Wechsel von einer RESTful API zu GraphQL war. REST bietet zwar die Möglichkeit über Parameter die Rückgabewerte flexibel zu halten, doch ist dies in der Nutzung und Implementierung keineswegs optimal. gRPC ist in diesem Aspekt REST noch ein Stück voraus, da es sich nicht an Prinzipien, wie die Zustandslosigkeit halten muss und somit an Flexibilität gewinnt.")]),t("h4",{attrs:{id:"architektur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#architektur","aria-hidden":"true"}},[e._v("#")]),e._v(" Architektur")]),t("p",[e._v('Mithilfe von REST\'s Layered-Prinzip und der expliziten Trennung von Client und Server fällt die unabhängige Weiterentwicklung der einzelnen System-Komponenten leicht, da die Komponenten nicht ineinander gekoppelt sind. Ebenso können die Funktionen und Daten von GraphQL angepasst werden ohne dass der Client diese Neuerungen direkt nutzen muss. Zusätzlich setzt GraphQL meist auf einer vorhandenen Backend-Komponente auf, wodurch der Name "A query language for your API" entstanden ist. Beide Technologien sind dementsprechend innerhalb der Komponenten entkoppelt. Bei gRPC besteht, trotz eines Layered-Systems, eine stärkere Kopplung innerhalb der Komponenten, da die Clients und Server dieselben Methoden implementieren, um die Methodenaufrufe lokal wirken zu lassen.')]),t("h4",{attrs:{id:"dokumentation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dokumentation","aria-hidden":"true"}},[e._v("#")]),e._v(" Dokumentation")]),t("p",[e._v('Eine API, die sich an die Prinzipien von REST hält, benötigt dank HATEOAS nur wenig oder sogar keine Dokumentation, um genutzt zu werden. HATEOAS bietet "Discoverability", wodurch der Client nach Aufruf einer Methode eine Auflistung seiner nächsten möglichen Operationen bekommt und somit durch die API navigiert wird. Dementsprechend dokumentiert sich REST mehr oder weniger von selbst.')]),t("p",[e._v("Ebenso kann bei einer GraphQL-Schnittstelle GraphiQL eingesetzt werden, welche zum Testen und Einarbeiten in die Schnittstelle hilfreich ist. GraphiQL generiert automatisch eine Dokumentation der Queries, Mutationen und der Query-Objekte, welche auf der Schnittstelle oder direkt in der Oberfläche genutzt werden können und bietet so einen guten Startpunkt zur Einarbeitung in die API.")]),t("p",[e._v("gRPC hängt in diesem Aspekt den anderen Technologien leider nach und beinhaltet keine Discoverability oder einen Einstiegspunkt, wie die anderen beiden Technologien, weshalb eine Client-Entwicklung ein ausreichendes Wissen über die Server-Methoden voraussetzt.")]),t("h4",{attrs:{id:"verlasslichkeit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#verlasslichkeit","aria-hidden":"true"}},[e._v("#")]),e._v(" Verlässlichkeit")]),t("p",[e._v("Im Punkt Verlässlichkeit glänzt REST durch seine jahrelange Nutzung und der dementsprechenden Reife. Während die modernen Technologien GraphQL und gRPC noch Probleme aufweisen, wie GraphQL's Probleme mit Datei-Handling und gRPC's Browserinkompatibilität, ist REST nach jahrelanger Nutzung wesentlich ausgereifter.")]),t("h4",{attrs:{id:"uberblick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uberblick","aria-hidden":"true"}},[e._v("#")]),e._v(" Überblick")]),t("table",[t("thead",[t("tr",[t("th",[t("strong",[e._v("gRPC")])]),t("th",[t("strong",[e._v("REST")])]),t("th",[t("strong",[e._v("GraphQL")])])])]),t("tbody",[t("tr",[t("td",[e._v("+ Schnelle Datenübertragung")]),t("td",[e._v("+ Bewährte Technologie")]),t("td",[e._v("+ Effiziente Rückgabedaten")])]),t("tr",[t("td",[e._v("+ Weniger Anfragen durch HTTP/2")]),t("td",[e._v("+ Discoverability durch HATEOAS")]),t("td",[e._v("+ Weniger Anfragen durch Query-Dynamik")])]),t("tr",[t("td",[e._v("- Browsersupport")]),t("td",[e._v("- Overhead durch Prinzipien")]),t("td",[e._v("+ Dynamisch für viele verschiedene Clientarten")])]),t("tr",[t("td"),t("td",[e._v("- Große Payloads oder viele spezielle Methoden")]),t("td",[e._v("- Kein Fileupload")])]),t("tr",[t("td"),t("td",[e._v("- Viele Aufrufe")]),t("td",[e._v("- Kein Caching")])])])]),t("h4",{attrs:{id:"anwendungsfalle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#anwendungsfalle","aria-hidden":"true"}},[e._v("#")]),e._v(" Anwendungsfälle")]),t("p",[e._v("Aufgrund dieser verschiedenen Eigenschaften ist jede Technologie für verschiedene Arten von Anwendungsfällen geeignet.")]),t("p",[t("strong",[e._v("gRPC")]),e._v(" eignet sich für Mikroservices, bei denen eine hohe Anzahl an Anfragen versendet werden, da gRPC den Overhead der einzelnen Anfragen gering hält und somit effizient und schnell arbeiten kann.")]),t("p",[t("strong",[e._v("REST")]),e._v(" eignet sich für API's, die komplexe Methoden und Prozesse abbilden und ansonsten schwer navigierbar wären.")]),t("p",[t("strong",[e._v("GraphQL")]),e._v(" eignet sich für API's, die viele verschiedene Client-Arten mit verschiedenen Anforderungen unterstützen müssen oder für Anwendungsfälle, bei denen komplexe Datenstrukturen genutzt werden müssen.")]),t("p",[e._v("Zusammengefasst kann man sagen, dass keine Technologie perfekt ist und je nach Projekt die Anforderungen und Use-Cases analysiert werden müssen, um zu schauen, welche API-Technologie sich am besten für das Projekt eignet.")]),t("h1",{attrs:{id:"literaturverzeichnis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#literaturverzeichnis","aria-hidden":"true"}},[e._v("#")]),e._v(" Literaturverzeichnis")]),t("p",[t("a",{attrs:{name:"ref_DAY14"}},[e._v("[DAY14]")]),e._v(": Dayley, Brad: Node.js, MongoDB, and AngularJS Web Development, 2014, ISBN: 978-0-321-99578-0 "),t("a",{attrs:{href:"https://books.google.de/books?hl=de&lr=&id=8kTCAwAAQBAJ&oi=fnd&pg=PR6&dq=nodejs&ots=Hg5ff4UIdE&sig=Tldw6TM8yJIq4utBZyXlSIz5mcg#v=onepage&q=nodejs&f=false",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_DOGL17"}},[e._v("[DOGL17]")]),e._v(": Doglio, Fernando: Pro REST API Development with Node.js, 2015, ISBN: 978-1-4842-0918-9 "),t("a",{attrs:{href:"https://books.google.de/books?hl=de&lr=&id=kjUwCgAAQBAJ&oi=fnd&pg=PR7&dq=5.+Pro+REST+API+Development+with+Node.js&ots=f149Pu5Rua&sig=5C39PrLsUvNHatLVGiogA8Shtvk#v=onepage&q=5.%20Pro%20REST%20API%20Development%20with%20Node.js&f=false",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GJS18"}},[e._v("[GJS18]")]),e._v(": GRPC-JS, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js-core",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GOOG18"}},[e._v("[GOOG18]")]),e._v(": Protocol Buffers - Google Developers, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://developers.google.com/protocol-buffers/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GQL18"}},[e._v("[GQL18]")]),e._v(": GraphQL, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://graphql.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GQLG18"}},[e._v("[GQLG18]")]),e._v(": Code - GraphQL, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"http://graphql.github.io/code/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GQLM18"}},[e._v("[GQLM18]")]),e._v(": GraphQL-Multipart-Request-Spec, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/jaydenseric/graphql-multipart-request-spec",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GQLS18"}},[e._v("[GQLS18]")]),e._v(": GraphQL-Sequelize, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/mickhansen/graphql-sequelize",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GRIG13"}},[e._v("[GRIG13]")]),e._v(": Grigorik, Ilya: High Performance Browser Networking: : What every web developer should know about networking and web performance, 2013 "),t("a",{attrs:{href:"https://hpbn.co/http2/#",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GRPC18a"}},[e._v("[GRPC18a]")]),e._v(": gRPC - About, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://grpc.io/about/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GRPC18b"}},[e._v("[GRPC18b]")]),e._v(": gRPC - Guides, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://grpc.io/docs/guides/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GRPC18c"}},[e._v("[GRPC18c]")]),e._v(": gRPC - Motivation and Design Principles, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://grpc.io/blog/principles",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GWEB18"}},[e._v("[GWEB18]")]),e._v(": GRPC-WEB, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/grpc/grpc-web",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_GWP18"}},[e._v("[GWP18]")]),e._v(": GRPC-WEB-Protokoll, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_HGQL18"}},[e._v("[HGQL18]")]),e._v(": HowToGraphQL: Learn GraphQL Fundamentals, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://www.howtographql.com/basics/0-introduction/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_HOTA14"}},[e._v("[HOTA14]")]),e._v(": Hota, A.K.; Prabhu, D. Madan: NODE.JS:\nLightweight, Event driven I/O web development, 2014 "),t("a",{attrs:{href:"http://informatics.nic.in/uploads/pdfs/26b47a73_node.js.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_JXC18"}},[e._v("[JXC18]")]),e._v(": JXCore, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/jxcore/jxcore",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_NODE18"}},[e._v("[NODE18]")]),e._v(": NodeJS - Child Process, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"http://nodejs.org/api/child_process.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_NPM18"}},[e._v("[NPM18]")]),e._v(": NPMjs, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_PGL18"}},[e._v("[PGL18]")]),e._v(": Postgraphile, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://github.com/graphile/postgraphile",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_RITS17"}},[e._v("[RITS17]")]),e._v(": Ritsilä, Aleksi: GraphQL: The API Design Revolution, 2017 "),t("a",{attrs:{href:"https://www.theseus.fi/bitstream/handle/10024/141989/GraphQL-%20The%20API%20Design%20Revolution.pdf?sequence=1&isAllowed=y",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_ROY08"}},[e._v("[ROY08]")]),e._v(": Untangled: REST API's must be hypertext-driven, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_SLDS16"}},[e._v("[SLDS16]")]),e._v(": ElAchèche, Bedis, Node.js essentials, abgerufen am 30.06.2018 "),t("a",{attrs:{href:"https://www.slideshare.net/elachechebedis/nodejs-essentials",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])]),t("p",[t("a",{attrs:{name:"ref_ZIM17"}},[e._v("[ZIM17]")]),e._v(": Zimmermann, T. et al: How HTTP/2 pushes the web: An empirical study of HTTP/2 server push, 2017 IFIP Networking Conference (IFIP Networking) and Workshops, Stockholm, 2017, pp. 1-9. "),t("a",{attrs:{href:"https://ieeexplore.ieee.org/document/8264830/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Online")])])])}],i=r(0),a=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},t,!1,null,null,null);n.default=a.exports}}]);