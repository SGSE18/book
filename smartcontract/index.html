<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SGSE 18 | Smart Contracts</title>
    <meta name="description" content="Kursmaterial für das Fach &quot;Spezielle Gebiete zum Software Engineering&quot;">
    <link rel="icon" href="/book/logo.png">
    
    <link rel="preload" href="/book/assets/css/33.styles.e6fa9992.css" as="style"><link rel="preload" href="/book/assets/js/app.958102a5.js" as="script"><link rel="preload" href="/book/assets/js/3.88d2a985.js" as="script"><link rel="prefetch" href="/book/assets/js/0.7dbc1163.js"><link rel="prefetch" href="/book/assets/js/1.40f277cb.js"><link rel="prefetch" href="/book/assets/js/2.285d1c38.js"><link rel="prefetch" href="/book/assets/js/4.c38f4093.js"><link rel="prefetch" href="/book/assets/js/5.5cc732ce.js"><link rel="prefetch" href="/book/assets/js/6.021b868c.js"><link rel="prefetch" href="/book/assets/js/7.691c97c1.js"><link rel="prefetch" href="/book/assets/js/8.798630b5.js"><link rel="prefetch" href="/book/assets/js/9.3e1422b5.js"><link rel="prefetch" href="/book/assets/js/10.8bfb988c.js"><link rel="prefetch" href="/book/assets/js/11.fb048222.js"><link rel="prefetch" href="/book/assets/js/12.8879f166.js"><link rel="prefetch" href="/book/assets/js/13.b1643b22.js"><link rel="prefetch" href="/book/assets/js/14.acc76071.js"><link rel="prefetch" href="/book/assets/js/15.89471185.js"><link rel="prefetch" href="/book/assets/js/16.4a940de1.js"><link rel="prefetch" href="/book/assets/js/17.23221b74.js"><link rel="prefetch" href="/book/assets/js/18.efe61ee1.js"><link rel="prefetch" href="/book/assets/js/19.52c638d9.js"><link rel="prefetch" href="/book/assets/js/20.28bbf558.js"><link rel="prefetch" href="/book/assets/js/21.1bb1590f.js"><link rel="prefetch" href="/book/assets/js/22.75f2210b.js"><link rel="prefetch" href="/book/assets/js/23.2ac075a4.js"><link rel="prefetch" href="/book/assets/js/24.de9a7704.js"><link rel="prefetch" href="/book/assets/js/25.c0ec3cbc.js"><link rel="prefetch" href="/book/assets/js/26.0bb0be72.js"><link rel="prefetch" href="/book/assets/js/27.000a2b21.js"><link rel="prefetch" href="/book/assets/js/28.3ea3ba4e.js"><link rel="prefetch" href="/book/assets/js/29.f8721d68.js"><link rel="prefetch" href="/book/assets/js/30.27ec2b0f.js"><link rel="prefetch" href="/book/assets/js/31.e1164066.js"><link rel="prefetch" href="/book/assets/js/32.98d569e5.js">
    <link rel="stylesheet" href="/book/assets/css/33.styles.e6fa9992.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/book/" class="home-link router-link-active"><!----><span class="site-name">
      SGSE 18
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/kurs/" class="nav-link">Kursmaterial</a></div><a href="https://github.com/SGSE18/book" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>Grundlagen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Distributed Ledger</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/book/smartcontract/" class="active sidebar-link">Smart Contracts</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/smartcontract/#vulnerabilities" class="sidebar-link">Vulnerabilities</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/smartcontract/#call-stack-tiefe" class="sidebar-link">Call-Stack Tiefe</a></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#re-entrency-und-cross-function-race-conditions" class="sidebar-link">Re-Entrency und Cross-function Race Conditions</a></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#denial-of-service" class="sidebar-link">Denial of Service</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#sicherheitsmassnahmen" class="sidebar-link">Sicherheitsmaßnahmen</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/smartcontract/#checks-effects-interactions-pattern" class="sidebar-link">Checks-Effects-Interactions-Pattern</a></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#update-und-andere-schutzmechanismen" class="sidebar-link">Update- und andere Schutzmechanismen</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#formale-verifikation" class="sidebar-link">Formale Verifikation</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/smartcontract/#mythril" class="sidebar-link">Mythril</a></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#maian" class="sidebar-link">MAIAN</a></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#zusammenfassung" class="sidebar-link">Zusammenfassung</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/smartcontract/#referenzen" class="sidebar-link">Referenzen</a></li></ul></li><li><a href="/book/hyperledger/" class="sidebar-link">Hyperledger</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Continuous Software Engineering</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Architekturen</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Fullstack Development</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>AI - machine learning</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Embedded</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Blockchain</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="smart-contracts"><a href="#smart-contracts" aria-hidden="true" class="header-anchor">#</a> Smart Contracts</h1><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"><p>Autor: Cem Basoglu</p><p>Mit der Erweiterung der Blockchain und Distributed Ledger Technologien um <a href="/book/blockchain/usecases/#smart-contracts">Smart
Contracts</a>, ergeben sich vielseitige
Möglichkeiten für neue und bestehende Anwendungsbereiche
[<a href="#ref_reyn18">REYN18</a>, <a href="#ref_lask18">LASK18</a>, <a href="#ref_stru18">STRU18</a>]. Wie mit
jeder neuen Technologie, aus denen sich neue Möglichkeiten ergeben, gehen diese
auch bei Smart Contracts mit neuen Risiken einher. Neben rechtlicher und
finanzieller Risiken, nehmen Fehler im Design bzw. der Implementierung von
Smart Contracts, einen weitaus größeren Stellenwert ein. Im Gegensatz zu
klassischen Applikationen, lassen sich einmal veröffentlichte Smart Contracts
nicht mehr updaten und auch durch die Fehler verursachten Änderungen am
Distributed Ledger nicht mehr rückgängig machen. In diesem Zusammenhang wirkt
die positive <a href="/book/blockchain/technologie/#eigenschaften-einer-blockchain">Eigenschaft</a>
von Distributed Leders, der Unveränderlichkeit von Transaktionsblöcken,
kontraproduktiv auf die Entwicklung von Smart Contracts.</p><h2 id="vulnerabilities"><a href="#vulnerabilities" aria-hidden="true" class="header-anchor">#</a> Vulnerabilities</h2><p>Da Smart Contracts in der Regel ebenfalls Vermögenswerte verwalten, ist es
essenziell, mögliche Schwachstellen bereits im voraus zu erkennen. Dabei liegen
die meisten Schwachstellen nicht direkt in dem implementierten Codeblock,
sondern ergeben sich erst durch die unberücksichtigte Wechselwirkung, mit der
zugrunde liegenden Smart Contract Plattform.</p><p>Wie fatal die Folgen dieser Schwachstellen sind, zeigen die jüngsten Ereignisse.
So konnten Angreifer, Ethereum Tokens im Wert von rund 60 Millionen Dollar,
durch die Ausnutzung einer Schwachstelle im DAO (Dezentrale Autonome
Organisation) Smart Contract, entwenden [<a href="ref_cast16">CAST16</a>]. In einem
anderen Fall sorgte eine Schwachstelle im Smart Contract dafür, dass Tokens im
Wert von rund einer halben Millionen Dollar nicht mehr ausgezahlt werden
konnten [<a href="ref_gove16">GOVE16</a>].</p><p>Da Smart Contracts erst in den vergangen Jahren an Bedeutung gewonnen haben,
entstehen derartige Schwachstellen, durch den Mangel an Erfahrungen um diese
zu erkennen und zu vermeiden. In diesem Abschnitt werden daher zunächst die
häufigsten Fallstricke betrachtet und anschließend mögliche Vorgehensweisen
präsentiert.</p><h3 id="call-stack-tiefe"><a href="#call-stack-tiefe" aria-hidden="true" class="header-anchor">#</a> Call-Stack Tiefe</h3><p>Die Ethereum Virtual Machine (EVM) begrenzt die Call-Stack Tiefe einer
Transaktion auf 1024 Aufrufe. Somit kann ein Angreifer die Call.Stack Tiefe
einer Transaktion, mittels rekrusiven Aufrufen, künstlich vor die Limitierung
positionieren, um anschliessend Fehler in der darauf folgenden zu Verarbeitung
der Transaktion zu provozieren.</p><pre class="language-javascript"><code>contract auction <span class="token punctuation">{</span>
  <span class="token function">mapping</span><span class="token punctuation">(</span>address <span class="token operator">=&gt;</span> uint<span class="token punctuation">)</span> refunds<span class="token punctuation">;</span>
  <span class="token comment">// [...]</span>
  <span class="token keyword">function</span> <span class="token function">withdrawRefund</span><span class="token punctuation">(</span>address recipient<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    uint refund <span class="token operator">=</span> refunds<span class="token punctuation">[</span>recipient<span class="token punctuation">]</span><span class="token punctuation">;</span>
    refunds<span class="token punctuation">[</span>recipient<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    recipient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>refund<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Obwohl die Funktion in sich keine Fehler aufweist und auch dem Empfänger
vertraut werden kann, schlägt der Aufruf <code>recipient.send(refund)</code> fehl,
da <code>send(...)</code> ebenfalls die Call Stack Tiefe erhöht. Da jedoch alle zuvor
ausgeführten Änderungen erfolgreich waren, wird das Konto des Empfängers auf 0
gesetzt ohne den Betrag tatsächlich transferiert zu haben.</p><p>Um eine derartige Schwachstelle zu vermeiden, ist Empfehlenswert den
Rückgabewert der <code>send(...)</code>-Funktion auszuwerten und die Ausführung wie folgt
mit <code>throw</code> zu terminieren.</p><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>recipient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>refund<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre><p>Durch die Terminierung mit <code>throw</code>, werden durch die Transaktion, keine State-
Änderungen in den Distributed Ledger übernommen. Damit bleibt das Guthaben
des Empfängers auch dann erhalten, wenn der darauf folgende Transfer
fehlschlägt. Durch diesen Angriff kann sich der Angreifer zwar keinen
finanziellen Vorteil verschaffen, aber einen Schaden bei den Guthabenbesitzern
verursachen.</p><h3 id="re-entrency-und-cross-function-race-conditions"><a href="#re-entrency-und-cross-function-race-conditions" aria-hidden="true" class="header-anchor">#</a> Re-Entrency und Cross-function Race Conditions</h3><p>Auf den ersten Blick erfüllen beiden Funktionen im folgenden Smart Contract die
an die jeweilige Funktion gestellten Anforderungen. Der Benutzer darf mit der
Funktion <code>transfer(...)</code> einen Betrag, der sein eigenes Guthaben nicht
übersteigt, einer beliebige anderen Adresse zuordnen und mit der Funktion
<code>withdrawBalance()</code> das gesamte eigene Guthaben, an die hinterlegte Adresse
überweisen.</p><pre class="language-javascript"><code>contract auction <span class="token punctuation">{</span>
  <span class="token function">mapping</span> <span class="token punctuation">(</span>address <span class="token operator">=&gt;</span> uint<span class="token punctuation">)</span> <span class="token keyword">private</span> userBalances<span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span>address to<span class="token punctuation">,</span> uint amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>userBalances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         userBalances<span class="token punctuation">[</span>to<span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>
         userBalances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">withdrawBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">{</span>
      uint amountToWithdraw <span class="token operator">=</span> userBalances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">;</span>
      msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span>call<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>amountToWithdraw<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      userBalances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Mit der sogenannten Re-Entrency Attacke, kann sich ein Angreifer das gesamte
Guthaben in dem Smart Contract (Guthaben aller Benutzer) auszahlen lassen,
in dem er einen eigenen Smart Contract mit der Default-Funktion implementiert.
Die Default-Funktion in einem Smart Contract wird aufgerufen, sobald eine
Transaktion an die Smart Contract Adresse eingeht. Die Default-Funktion ruft
wiederum erneut die <code>withdrawBalance()</code>-Funktion auf. Da in der
<code>withdrawBalance()</code>-Funktion das Guthaben des Angreifers an die böswillige
Smart Contract Adresse überwiesen wird, ergibt sich somit eine rekursive
Schleife zwischen den beiden Smart Contracts. Damit wird die Zeile
<code>userBalances[msg.sender] = 0</code> erst erreicht, wenn das gesamte Guthaben im
Smart Contract aufgebraucht ist, wodurch die <code>call(...)</code>-Funktion fehlschlägt.</p><p>Statt dem erneuten Aufruf der <code>withdrawBalance()</code>-Funktion, kann der Angreifer
auch eine Cross-function Race Condition provozieren. Dazu wird erneut ein
böswilliger Smart Contract implementiert und stattdessen diesmal die
<code>transfer(...)</code>-Funktion in der Default-Funktion aufgerufen. Somit wird das
Guthaben einer anderen Adresse zugeordnet, bevor das seiner Adresse zugeordnete
Guthaben auf 0 gesetzt wird.</p><p>Beide Schwachstellen lassen sich beheben, in dem das Guthaben der aufrufenden
Adresse vor der Ausführung der Überweisung auf 0 gesetzt wird. Um im Fehlerfall
das Guthaben wiederherzustellen, empfiehlt es sich zusätzlich den Rückgabewert
der <code>send()</code>-Funktion zu prüfen, die Ausführung mit <code>throw</code> zu terminieren und
damit alle durch die Transaktion entstanden Änderungen am State, rückgängig zu
machen.</p><h3 id="denial-of-service"><a href="#denial-of-service" aria-hidden="true" class="header-anchor">#</a> Denial of Service</h3><p>Im folgenden Smart Contract sollen die Teilnehmer einer Auktion, mit dem Aufruf
der <code>bid()</code>-Funktion an der Auktion teilnehmen können. Dazu muss der Teilnehmer
einen Betrag größer als das aktuelle Höchstgebot überweisen. Wird das aktuelle
Höchstgebot überboten, erhält der alte Höchstbietende seinen zuvor überwiesenen
Betrag zurück. Bei der Implementierung werden alle zuvor genannten
Vorgehensweisen, wie die Prüfung des Rückgabewerts der <code>send(...)</code>-Funktion
und die Terminierung mit <code>throw</code> im Fehlerfall, entsprechend in der
<code>bid()</code>-Funktion implementiert.</p><pre class="language-javascript"><code>contract auction <span class="token punctuation">{</span>
  address currentLeader<span class="token punctuation">;</span>
  uint highestBid<span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">bid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> highestBid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentLeader<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>highestBid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

      currentLeader <span class="token operator">=</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">;</span>
      highestBid <span class="token operator">=</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>In diesem Fall kann ein Angreifer jedoch die Abgabe weitere Gebote blockieren,
in dem er einen Smart Contract mit einer Default-Funktion implementiert, die
immer zu einem Fehler, z.B durch die Überschreitung der Call Stack Tiefe, führt.
Wird nun ein neues Höchstgebot abgegeben, erhält der aktuelle Höchstbieter
(Angreifer) sein Gebot wieder, wodurch die Default-Funktion im Smart Contract
des Angreifers aufgerufen wird. Da diese jedoch fehlschlägt, liefert <code>send(...)</code>
einen Fehler zurück wodurch die Ausführung terminiert und alle Änderungen
rückgängig gemacht werden. Somit ist der Angreifer weiterhin der Höchstbietende
und neue Höchstgebote schlagen immer fehl.</p><p>Eine mögliche Lösung besteht darin, in diesem Fall keine Terminierung durch den
<code>throw</code> im Fehlerfall vorzunehmen. Alternativ kann aber auch eine Liste der
alten Höchstbietenden und deren Gebote geführt und ganz auf die automatische
Auszahlung verzichtet werden. Über eine zusätzliche Funktion können sich
anschließend die in dieser Liste geführten Höchstbieter ihr Gebot erstatten
lassen.</p><h2 id="sicherheitsmassnahmen"><a href="#sicherheitsmassnahmen" aria-hidden="true" class="header-anchor">#</a> Sicherheitsmaßnahmen</h2><p>Aus den bisherigen Erfahrungen mit Smart Contracts, im speziellen mit der
Ethereum Virtual Machine, haben sich bestimme Vorgehensweisen und -muster
ergeben. Einige wurden bereits in dem vorangegangen Abschnitten vorgestellt und
sollen in diesem Abschnitt weiter generalisiert werden.</p><h3 id="checks-effects-interactions-pattern"><a href="#checks-effects-interactions-pattern" aria-hidden="true" class="header-anchor">#</a> Checks-Effects-Interactions-Pattern</h3><p>Smart Contracts können direkt oder indirekt mit anderen Smart Contracts im
Distributed Ledger interagieren. Unabhängig davon, ob diese Interaktion
beabsichtigt ist oder durch die Default-Funktion eines Zahlungsempfänger
herbei geführt wird, sollte in jedem Fall bedacht werden dass durch den Aufruf
einer externen Funktion, auch der Kontrollfluss an diese übergeben wird. Um die
Risiken die damit einhergehen zu minimieren, kann das
Checks-Effects-Interactions-Muster angewandt werden [<a href="#ref_voll18">VOLL18</a>].</p><p>Diese ähneln den Coding Standards der <em>klassischen</em> Softwareentwicklung
[<a href="#ref_seac18">SEAC18</a>] mit der Ausnahme, dass die Änderungen am State schon
vorgenommen werden, bevor die damit verbundene Aktion erfolgreich durchgeführt
wurde. Das Muster wird in folgende Teilschritte unterteilt.</p><ol><li><p><strong>Eingabe Parameter und State prüfen</strong></p><p>Alle Eingabe Parameter der Funktion werden zunächst validiert und ggf. mit
dem State abgeglichen. Dazu zählt die Prüfung ob der Aufrufer überhaupt
diese Funktion aufrufen darf oder z.B. über genug Guthaben verfügt die er in
den Eingabe Parametern anfordert.</p></li><li><p><strong>State Änderungen vornehmen</strong></p><p>Nach erfolgreicher Validierung der Parameter, werden anschließend die
Änderungen am State vorgenommen, wie z.B. die</p></li><li><p><strong>Smart Contract Interaktionen durchführen</strong></p><p>Erst zum Schluss werden alle Aktionen durchgeführt, die zu einer direkten
oder indirekten Interaktion mit anderen Smart Contracts führen können. Im
Fehlerfall wird die Ausführung mit einem <code>throw</code> beendet, sodass Änderungen
am State aus Schritt 2 rückgängig gemacht werden.
Wie in Beispiel <a href="#denial-of-service">DoS</a> demonstriert, hängt die
Terminierung mit <code>throw</code> jedoch stark vom Anwendungsfall ab.</p></li></ol><h3 id="update-und-andere-schutzmechanismen"><a href="#update-und-andere-schutzmechanismen" aria-hidden="true" class="header-anchor">#</a> Update- und andere Schutzmechanismen</h3><p>Um auf neu entdeckte Sicherheitsrisiken reagieren zu können, bieten sich diverse
Maßnahmen an. Zum einen lassen sich Schutzmechanismen implementieren, die im
Ernstfall die Ausführung bestimmter Funktionen im Smart Contracts pausieren und
zum anderen können z.B. Auszahlungen in der Höhe oder Häufigkeit gedrosselt
werden, um im Ernstfall genug Zeit für Reaktionen zu haben. Zusätzlich kann ein
externer Dienst ausserhalb des Distributed Ledgers implementiert werden, der in
regelmäßigen Abständen die State-Integrität des Smart Contracts prüft und bei
unschlüßigen Zuständen die Verantwortlichen benachrichtigt.</p><p>Zwar helfen diese Mechanismen dabei verdächtige Aktivität im Smart Contract zu
erkennen, um die Sicherheitslücke jedoch zu schliessen ist es notwendig den
Smart Contract updaten zu können. Da dies, wie einleitend erwähnt, nicht von der
Ethereum Plattform vorgesehen ist, muss entsprechende Funktionalität im Smart
Contract implementiert werden. Hierzu kann eine Funktion implementiert werden,
die nur von bestimmten Personen (z.B. dem Besitzer) aufgerufen werden darf und
das aktuelle Guthaben und den State des Smart Contracts, an einen neuen Smart
Contract transferiert.</p><h2 id="formale-verifikation"><a href="#formale-verifikation" aria-hidden="true" class="header-anchor">#</a> Formale Verifikation</h2><p>Im Spektrum der qualitätssichernden Maßnahmen im Software-Entwurf gehören
formale Spezifikations- und Verifikationsmethoden heute zweifellos zu den
stärksten Waffen in puncto Fehlererkennung und Nachweis von
Korrektheitseigenschaften [<a href="#ref_reif99">REIF99</a>]. Dazu wird die zu überprüfende
Software und die Spezifikation in einem mathematisch Theorem formalisiert, um
automatisiert, mittels Theorembeweisern, eventuelle Abweichungen des
Softwaremodells von der Spezifikation nachzuweisen. Zu den bekanntesten
Theorembeweisern, gemessen an der bereits formalisierten
<a href="http://www.cs.ru.nl/~freek/100/" target="_blank" rel="noopener noreferrer">Top 100 mathematischer Sätze</a>, gehören
<a href="http://www.cl.cam.ac.uk/~jrh13/hol-light/" target="_blank" rel="noopener noreferrer">HOL Light</a> und
<a href="https://isabelle.in.tum.de/" target="_blank" rel="noopener noreferrer">Isabelle/HOL</a>.</p><p>Um für die Formalisierung eines Smart Contracts, nicht die gesamte Ethereum
Virtual Machine formalisieren zu müssen, existiert bereits ein Model der EVM für
diverse Theorembeweiser [<a href="#ref_hira17">HIRA17</a>] zu denen auch der Isabelle/HOL
zählt. Basierend auf diesem Modell der EVM, kann nun vielmehr nur der Smart
Contract formalisiert und gegen eine gegeben Spezifikation geprüft werden.
Darüber hinaus gibt es noch weitere Ansätze die EVM zu formalisieren
[<a href="#ref_hild17">HILD17</a>] und folgende Werkzeuge um Schwachstellen im Smart
Contract zu lokalisieren.</p><h3 id="mythril"><a href="#mythril" aria-hidden="true" class="header-anchor">#</a> Mythril</h3><p>Diese Tool ist spezialisiert auf die formale Verifikation von Smart Contracts
und bietet dazu sowohl eine API um eigene Spezifikationen zu definieren, als
auch ein CLI (Command Line Interface) um typische Fehler im Smart Contract
nachzuweisen. Angewandt auf das <a href="#re-entrency-und-cross-function-race-conditions">Re-Entrency Beispiel</a>
aus dem vorherigen Abschnitt, wird unteranderem folgender Hinweis generiert.</p><pre class="language-bash"><code>$ myth -x /tmp/test.sol

<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token operator">==</span><span class="token operator">==</span> State change after external call <span class="token operator">==</span><span class="token operator">==</span>
Type: Warning
Contract: Unknown
Function name: withdrawBalance<span class="token punctuation">(</span><span class="token punctuation">)</span>
PC address: 360
The contract account state is changed after an external call. Consider that the called contract could re-enter the <span class="token keyword">function</span> before this state change takes place. This can lead to business logic vulnerabilities.
--------------------
In file: /tmp/test.sol:12
userBalances<span class="token punctuation">[</span>msg.sender<span class="token punctuation">]</span> <span class="token operator">=</span> 0
--------------------
<span class="token punctuation">..</span><span class="token punctuation">..</span>

</code></pre><p>Neben einer Reihe weiterer Warnungen und Informationen, wird die Re-Entrancy
Schwachstelle korrekt erkannt und die entsprechende Zeile im Solidity Code
ausgegeben. Neben der Schwachstelle wird ebenfalls ein Hinweis auf die
Sicherheitsmaßnahme, in diesem Fall das <a href="#checks-effects-interactions-pattern">Checks-Effects-Interactions-Pattern</a>,
ausgegeben.</p><h4 id="smart-contract-graph"><a href="#smart-contract-graph" aria-hidden="true" class="header-anchor">#</a> Smart Contract Graph</h4><p>Ein weitere nützliche Funktion ist dass generieren von Kontrollfluss-Graphen
zu einem Smart Contract. Dazu kann entweder der Solidity Code oder Bytecode
verwendet werden und der Parameter <code>-g</code> der CLI übergeben werden.</p><p><img src="/book/assets/img/control_flow.1bd9d1fe.png" alt="Control Flow Graph" title="Control Flow Graph"></p><p>Abbildung 2.1.3.1 - Kontrollfluss Graph</p><p>Die Darstellung zeigt einen Ausschnitt aus dem Graphen, zu dem <a href="#re-entrency-und-cross-function-race-conditions">Re-Entrancy</a>
Beispiel aus dem vorherigen Abschnitt. Die Knoten stellen dabei Codeblöcke dar
und enthalten die EVM-Befehle [<a href="#ref_evm18">EVMO18</a>] die beim erreichen diesem
Knotens ausgeführt werden. Die Kanten repräsentieren den Pfad, die je nach
Erfüllung der an der Kante ausgewiesene Bedingung genommen wird. Die Bedingungen
in der Darstellung entsprechen der <code>if (userBalances[msg.sender] &gt;= amount)</code> in
der <code>transfer(...)</code>-Funktion.</p><h4 id="spezifikationen-definieren"><a href="#spezifikationen-definieren" aria-hidden="true" class="header-anchor">#</a> Spezifikationen definieren</h4><p>Neben den bereits verfügbaren Spezifikationen, die per CLI gegen eigene Smart
Contract ausgeführt werden können, ist es ebenfalls möglich eigene
Spezifikationen zu implementieren. Angenommen es soll laut Spezifikation
sichergestellt werden, dass eine bestimmte State-Variable nur von dem Smart
Contract Besitzer geändert werden kann. Unter Verwendung der im Ethereum Yellow
Paper [<a href="#ref_wood18">WOOD18</a>] eingeführten Notation, kann dies wie folgt als
Theorem ausgedrückt werden.</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>P</mi><mo>(</mo><mi>σ</mi><mo>)</mo><mo>∧</mo><mo>(</mo><msub><mi>I</mi><mi>b</mi></msub><mo>[</mo><msub><mi>μ</mi><mrow><mi>p</mi><mi>c</mi></mrow></msub><mo>]</mo><mo>=</mo><mo>=</mo><mi>S</mi><mi>S</mi><mi>T</mi><mi>O</mi><mi>R</mi><mi>E</mi><mo>)</mo><mo>∧</mo><mo>(</mo><msub><mi>μ</mi><mi>s</mi></msub><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>)</mo><mo>∧</mo><mo>(</mo><msub><mi>I</mi><mi>s</mi></msub><mo>!</mo><mo>=</mo><mi>σ</mi><mo>[</mo><msub><mi>I</mi><mi>a</mi></msub><msub><mo>]</mo><mi>s</mi></msub><mo>[</mo><mn>0</mn><mo>]</mo><mo>)</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{array}{c}
P(\sigma) \wedge (I_b[\mu_{pc}] == SSTORE) \wedge (\mu_s[0] == 1) \wedge (I_s != \sigma[I_a]_s[0])
\end{array}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span><span class="mbin">∧</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">b</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathit">μ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span><span class="mord mathit">c</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mbin">∧</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">μ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∧</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">!</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mopen">[</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose"><span class="mclose">]</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><span style="font-size:2px">_</span><p>Ein verstoß gegen die Spezifikation kann nachgewiesen werden, wenn zu einem
beliebigen Zeitpunkt diese logische Bedingung erfüllt werden kann. Dabei prüft
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>σ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(\sigma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span> ob es einen <a href="#smart-contract-graph">Pfad</a>, unter Verwendung des
Globalen-Zustand (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span>), zu der instruction (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>b</mi></msub><mo>[</mo><msub><mi>μ</mi><mrow><mi>p</mi><mi>c</mi></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">I_b[\mu_{pc}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">b</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathit">μ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span><span class="mord mathit">c</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span></span></span></span>) am aktuellen
Programmcounter gibt und ob dieser dem <code>SSTORE</code> EVM-Befehl entspricht. Diese
Instruction ist laut dem EVM-<em>Instruction-Set</em> der einzige Maschinenbefehl, der
den Speicher und damit die State-Variablen des Smart Contracts ändern kann. Die
Teilbedingung <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>μ</mi><mi>s</mi></msub><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu_s[0] == 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">μ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span> erfordert, dass die obersten Position im Stack
(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>μ</mi><mi>s</mi></msub><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\mu_s[0]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">μ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span></span></span></span>) mit dem Wert 1 befüllt ist. Da der <code>SSTORE</code>-Befehl, die Smart
Contract Speicheradresse von der obersten Position im Stack liesst, wird somit
geprüft ob die gewünschte State-Variable geändert werden soll. An welcher
Speicheradresse eine Variable persistiert wird, hängt von der Reihenfolge der
im Solidity-Code definierten Variablen ab. Sind alle bisherigen Teilbedingungen
erfüllt, kann somit nachgewiesen werden dass die aktuell auszuführende
Instruction die State-Variable an der Speicheradresse 1 beschreibt. Da
zusätzlich nachgewiesen werden soll, ob die State-Variable von jemand anderem
als dem Smart Contract Besitzer geändert wird, prüft die letzte Teilbedingung
ob der aktuelle Aufrufer (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">I_s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>) vom Besitzer abweicht. Da Smart Contracts das
Konzept eines Besitzer nicht nativ unterstützen, wird der Besitzer in der Regel
im Konstruktor des Smart Contracts in einer State-Variable gespeichert. In
diesem Beispiel wird mit <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo>[</mo><msub><mi>I</mi><mi>a</mi></msub><msub><mo>]</mo><mi>s</mi></msub><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sigma[I_a]_s[0]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mopen">[</span><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose"><span class="mclose">]</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span></span></span></span> angenommen, dass der Besitzer in der
Speicheradresse 0 des Smart Contracts <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">I_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> des Globalen-States <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo>[</mo><mi>x</mi><msub><mo>]</mo><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">\sigma[x]_s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose"><span class="mclose">]</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>
gehalten wird.
<span style="font-size:2px">_</span></p><p>Die Spezifikation wird in Pyhton implementiert und nachgewiesen. Dazu kann das
Mythril Framework im Python-Script geladen und anschließend der
<a href="#smart-contract-graph">Graph</a> und die jeweiligen Instructionen wie folgt
untersucht werden.</p><pre class="language-python"><code><span class="token keyword">from</span> mythril<span class="token punctuation">.</span>ether<span class="token punctuation">.</span>util <span class="token keyword">import</span> compile_solidity
<span class="token keyword">from</span> mythril<span class="token punctuation">.</span>ether<span class="token punctuation">.</span>ethcontract <span class="token keyword">import</span> ETHContract
<span class="token keyword">from</span> mythril<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>symbolic <span class="token keyword">import</span> StateSpace
<span class="token keyword">from</span> mythril<span class="token punctuation">.</span>analysis <span class="token keyword">import</span> solver
<span class="token keyword">from</span> mythril<span class="token punctuation">.</span>exceptions <span class="token keyword">import</span> UnsatError
<span class="token keyword">from</span> z3 <span class="token keyword">import</span> <span class="token operator">*</span>

name<span class="token punctuation">,</span> bytecode <span class="token operator">=</span> compile_solidity<span class="token punctuation">(</span><span class="token string">&quot;test.sol&quot;</span><span class="token punctuation">)</span>
contract <span class="token operator">=</span> ETHContract<span class="token punctuation">(</span>bytecode<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
statespace <span class="token operator">=</span> StateSpace<span class="token punctuation">(</span><span class="token punctuation">[</span>contract<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> node_id<span class="token punctuation">,</span> node <span class="token keyword">in</span> statespace<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># Knoten iterieren</span>
  <span class="token keyword">for</span> instr <span class="token keyword">in</span> node<span class="token punctuation">.</span>instruction_list<span class="token punctuation">:</span>                     <span class="token comment"># EVM-Befehle iterieren</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token string">'opcode'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'SSTORE'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                     <span class="token comment"># (Ib[μpc] == SSTORE)</span>
      adr <span class="token operator">=</span> instr<span class="token punctuation">[</span><span class="token string">'address'</span><span class="token punctuation">]</span>
      sstore_target <span class="token operator">=</span> node<span class="token punctuation">.</span>states<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          <span class="token comment"># μs​​[0]</span>
      caller <span class="token operator">=</span> BitVec<span class="token punctuation">(</span><span class="token string">&quot;caller&quot;</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span>                      <span class="token comment"># Is</span>
      storage_0 <span class="token operator">=</span> BitVec<span class="token punctuation">(</span><span class="token string">&quot;storage_0&quot;</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span>                <span class="token comment"># σ[I​a​]​s​​[0]</span>
      constr <span class="token operator">=</span> node<span class="token punctuation">.</span>constraints
      constr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sstore_target <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                   <span class="token comment"># (μ​s​​[0] == 1)</span>
      constr<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>UDiv<span class="token punctuation">(</span>storage_0<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> caller<span class="token punctuation">)</span>     <span class="token comment"># (I​s​​ != σ[I​a​]​s​​[0])</span>
      <span class="token keyword">try</span><span class="token punctuation">:</span>
          model <span class="token operator">=</span> solver<span class="token punctuation">.</span>get_model<span class="token punctuation">(</span>constr<span class="token punctuation">)</span>                <span class="token comment"># P(σ)</span>
          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Abweichung von der Spezifikation in &quot;</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>function_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">except</span> UnsatError<span class="token punctuation">:</span>
          <span class="token keyword">pass</span>
</code></pre><p>Auf diese Weise lassen sich Smart Contracts flexible und automatisiert formal
verifizieren. Über die hier dargestellten Möglichkeiten hinaus, bietet das
Mythril Framework auch noch  weitere nützliche Funktionen, wie das Testen von
bereits in der Blockchain veröffentlichten Smart Contracts, als auch das
Durchsuchen aller veröffentlichten Smart Contracts nach bestimmten EVM-Befehlen.</p><h3 id="maian"><a href="#maian" aria-hidden="true" class="header-anchor">#</a> MAIAN</h3><p>Wie <a href="#mythril">Mythril</a> ist auch dieses Tool spezialisiert auf die formale
Verifikation von Ethereum Smart Contracts. Während Mythril jedoch eine
Transaktion isoliert betrachtet, verwendet MAIAN eine Kette von systematisch
angelegten State und Stack Kombinationen um Schwachstellen im Smart Contract
aufzuspüren [<a href="#ref_niko18">NIKO18</a>]. Dabei ordnet Mythril die Schwachstellen
in die folgenden Kategorien ein.</p><ul><li><p><strong>Prodigal Contracts</strong></p><p>In diese Klasse werden Smart Contracts eingeordnet, die Zahlungen an Empfänger
schicken die keine Besitzer sind, jemals eine Einzahlung getätigt haben oder
Funktions-Parameter erwarten die nicht auch von einem beliebigen User stammen
können.</p></li><li><p><strong>Suicidal Contracts</strong></p><p>Sind Smart Contracts die von einem beliebigen User zerstört werden können, in
dem eine Funktion aufgerufen wird, die den <code>SELFDESTRUCT</code> EVM-Befehl ausführt.</p></li><li><p><strong>Greedy Contracts</strong></p><p>In die Kategorie fallen alle Smart Contracts, die einmal getätigte
Einzahlungen, unter keinen Umständen mehr ausgezahlt werden können.</p></li></ul><p>Um einen Smart Contract in eine oder mehrere Kategorien einzuordnen, arbeitet
sich MAIAN durch die EVM-Befehle im Smart Contract, beginnend mit dem ersten
EVM-Befehl, und spannt dabei rekursiv einen Suchbaum auf mit den nötigen State
Variablen Stack Zuständen um diese Verzweigung im Bytecode zu repräsentieren.
Wird ein terminierender EVM-Befehl wie z.B RETURN oder REVERT erreicht oder die
Suche in einem Pfad kann nicht in einem vorgegeben Zeitrahmen abgeschlossen
werden, so wird die Suche in dem aktuellen Pfad beendet und per Backtracking
der nächste Pfad untersucht. Wird nun in einem Pfad der gesucht EVM-Befehl, wie
z.B. <code>SELFDESTRUCT</code> für Suicidal Contracts oder <code>CALL</code> für Prodigal Contracts,
gefunden, wird die Ausführung beendet und die entsprechende Schwachstelle
inkl. der Parameter um den Pfad zu erreichen ausgegeben.</p><h3 id="zusammenfassung"><a href="#zusammenfassung" aria-hidden="true" class="header-anchor">#</a> Zusammenfassung</h3><p>Beim Vergleich der beiden Tools lässt sich zusammenfassend sagen, dass sich
Mythril Bottom-Up durch die EVM-Befehle in einem Smart Contract arbeitet,
während MAIAN Top-Down durch alle Befehle arbeitet und diese dabei auch
ausführt, um den Suchbaum, Stack und State entsprechend aufzubauen. Dies führt
dazu, dass die Ausführung einer Spezifikation längere Zeit beansprucht. Mythril
hingegen sucht zunächst den entsprechenden EVM-Befehl (<code>SELFDESTRUCT</code>, <code>CALL</code>,
etc..) in einer flachen Liste und arbeitet sich dann Rückwärts den Pfad hoch,
um die Bedingungen für alle möglichen Pfade zu analysieren.</p><p>Beide Tools sind kaum dokumentiert und nur Mythril besitzt eine Github-Wiki
Seite mit den grundlegenden Informationen zur Installation und Nutzung. Die
Verifikation-API von Mythril ist auch ohne Dokumentation noch gut verständlich,
während MAIAN undokumentierte globale Variablen für die Kommunikation zwischen
den einzelnen Komponenten nutzt, dessen Verantwortlichkeiten sich erst nach dem
einlesen in den Quellcode der einzelnen Komponenten offenbaren.</p><p>In der Benutzung sind beide Tools gleich einfach aufgebaut. Bei der Installation
dagegen ist Mythril, aufgrund des Docker-Images, zügiger Einsatzbereit und
vereinfacht durch das APT/Brew Package-Repository die native Installation auf
dem System. MAIAN beschränkt sich hierbei auf das Clonen des GIT-Repositories
und die manuelle Installation der benötigten Abhängigkeiten in den
entsprechenden Versionen.</p><table><thead><tr><th>Tool</th><th>Mythril</th><th>MAIAN</th></tr></thead><tbody><tr><td>Kosten</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">O</mi></mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">O</mi></mrow><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>Untersuchte Schwachstellen</td><td>19</td><td>3</td></tr><tr><td>Dokumentation*</td><td>+</td><td></td></tr><tr><td>Verifikation API*</td><td>++</td><td>+</td></tr><tr><td>Usability*</td><td>+++</td><td>+++</td></tr><tr><td>Installation*</td><td>+++</td><td></td></tr></tbody></table><p>*max. Bewertung: +++</p><h2 id="referenzen"><a href="#referenzen" aria-hidden="true" class="header-anchor">#</a> Referenzen</h2><p><a name="ref_cast16">[CAST16]</a>: Michael del Castillo: The DAO Attacked: Code Issue Leads to $60 Million Ether Theft</p><p><a name="ref_evm18">[EVMO18]</a>: Ethereum VM (EVM) Opcodes and Instruction Reference. <a href="https://github.com/trailofbits/evm-opcodes" target="_blank" rel="noopener noreferrer">Online</a></p><p><a name="ref_gove16">[GOVE16]</a>: Governmental’s 1100eth jackpot payout is stuck because it uses too much gas. <a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/" target="_blank" rel="noopener noreferrer">Online</a></p><p><a name="ref_hild17">[HILD17]</a>: Everett Hildenbrandt, et al.: KEVM: A Complete Semantics of the Ethereum Virtual Machine</p><p><a name="ref_hira17">[HIRA17]</a>: Yoichi Hirai: Defining the Ethereum Virtual Machine for Interactive Theorem Provers</p><p><a name="ref_lask18">[LASK18]</a>: Henry M., Kim Marek Laskowski: Toward an ontology‐driven blockchain design for supply‐chain provenance.</p><p><a name="ref_niko18">[NIKO18]</a>: Ivica Nikolic, Aashish Kolluri, Ilya Sergey: Finding The Greedy, Prodigal, and Suicidal Contracts at Scale</p><p><a name="ref_reif99">[REIF99]</a>: Wolfgang Reif: Formale Methoden für sicherheitskritische Software – Der KIV-Ansatz</p><p><a name="ref_reyn18">[REYN18]</a>: Ana Reyna, Cristian Martín, Jaime Chen, Enrique Soler, Manuel Díaz: On blockchain and its integration with IoT. Challenges and opportunities.</p><p><a name="ref_seac18">[SEAC18]</a>: Robert Seacord: Top 10 Secure Coding Practices. <a href="https://wiki.sei.cmu.edu/confluence/display/seccode/Top+10+Secure+Coding+Practices" target="_blank" rel="noopener noreferrer">Online</a></p><p><a name="ref_stru18">[STRU18]</a>: Strugar,  D., Hussain, R., Mazzara, M., Rivera, V.: M2M billing for electric autonomous vehicles.</p><p><a name="ref_voll18">[VOLL18]</a>: Franz Volland: Checks Effects Interactions. <a href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html" target="_blank" rel="noopener noreferrer">Online</a></p><p><a name="ref_wood18">[WOOD18]</a>: Gavin Wood: ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION <a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="noopener noreferrer">Online</a></p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/book/dezentralisierung/" class="prev">
          Dezentralisierung
        </a></span><span class="next"><a href="/book/hyperledger/">
          Hyperledger
        </a> →
      </span></p></div></div></div></div>
    <script src="/book/assets/js/3.88d2a985.js" defer></script><script src="/book/assets/js/app.958102a5.js" defer></script>
  </body>
</html>
